<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
    <meta content="width=device-width, initial-scale=1, user-scalable=no" name="viewport">
    <meta name="description" content="Todd Anderson makes things for web, mobile, desktop and land with a passion of application architecture and development workflows.">
    <meta name="keywords" content="todd anderson, anderson, programmer, developer, architect, engineer, software, software development, programming, application, ria, architecture, javascript, html5, css, web, mobile, desktop, arduino, actionscript, flex, flash, python">
    <link rel="stylesheet" type="text/css" href="http://custardbelly.com/blog/style/main.css" media="all" />
    <link rel="stylesheet" type="text/css" href="http://custardbelly.com/blog/lib/highlight/styles/github.css" media="all" />
    <link rel="alternate" type="application/rss+xml" title="Todd Anderson - feed" href="http://custardbelly.com/blog/index.xml" />
    <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Playfair+Display">
    <title>Todd Anderson - The Making of a Test-Driven Grocery List Application in JS: Part IV</title>
  </head>
  <body>
    <header>
      <h1><a class="header-link" href="http://custardbelly.com/blog/">Todd Anderson</a></h1>
      <h2>I make things for the web, mobile, desktop and land.</h2>
      <ul id="media-list">
        <li><a href="http://custardbelly.com/blog/index.xml"><img src="http://custardbelly.com/blog/asset/social70.svg" onerror="this.src=http://custardbelly.com/blog/asset/social70.png"></a></li>
        <li><a href="http://twitter.com/_toddanderson_"><img src="http://custardbelly.com/blog/asset/twitter12.svg" onerror="this.src=http://custardbelly.com/blog/asset/twitter12.png"></a></li>
        <li><a href="https://github.com/bustardcelly"><img src="http://custardbelly.com/blog/asset/github7.svg" onerror="this.src=http://custardbelly.com/blog/asset/github7.png"></a></li>
        <li><a href="https://plus.google.com/113716114429928674625/posts"><img src="http://custardbelly.com/blog/asset/google21.svg" onerror="this.src=http://custardbelly.com/blog/asset/google21.png"></a></li>
        <li><a href="http://lnkd.in/6GCvvR"><img src="http://custardbelly.com/blog/asset/linkedin2.svg" onerror="this.src=http://custardbelly.com/blog/asset/linkedin2.png"></a></li>
      </ul>
    </header>
    <nav>
      <a href="http://custardbelly.com/blog/">home</a>&nbsp;&nbsp;|&nbsp;&nbsp;<a href="http://custardbelly.com/blog/archive.html">archives</a>&nbsp;&nbsp;|&nbsp;&nbsp;<a href="http://custardbelly.com/blog/blog-pages/about.html">about</a>
    </nav>

    <article class="post">
  <div class="title">
    <h1><a href="http://custardbelly.com/blog/blog-posts/2012/12/17/the-making-of-a-test-driven-grocery-list-application-in-js-part-iv/index.html">The Making of a Test-Driven Grocery List Application in JS: Part IV</a></h1>
    <p>
      2012 December 17th
      
        by todd anderson
      
    </p>
  </div>
  <section>
    <p><em>This is the fourth installment in a series of building a Test-Driven Grocery List application using <a href="http://pivotal.github.com/jasmine/">Jasmine</a> and <a href="http://requirejs.org">RequireJS</a>. To learn more about the intent and general concept of the series please visit <a href="http://custardbelly.com/blog/2012/11/26/the-making-of-a-test-driven-grocery-list-application-in-javascript-part-i/">The Making of a Test-Driven Grocery List Application in JavaScript: Part I</a></em><br>—</p>
<h1 id="introduction">Introduction</h1>
<p>In the <a href="http://custardbelly.com/blog/2012/12/06/the-making-of-a-test-driven-grocery-list-application-in-js-part-iii/">previous</a> article we developed a new feature for the <strong>Grocery List</strong> application: <em>Mark Off Item</em>. In the process of doing so, or at least when we went from the tests to implementation, we added more responsibility to the <em>list-controller</em> as it pertained to individual view and model items.</p>
<p>In this article, we are going to refactor out that responsibility into its own <em>list-item-controller</em> that will be responsible for managing the relationship of a list item view to a single <em>grocery-ls-item</em> model.</p>
<h2 id="refactoring">Refactoring</h2>
<p>As it stands , I think the design of the <em>list-controller</em> is fine: exposing an API to modify the list. It’s the internals that are starting to bug me. If the current behaviour and responsibilities were all that was needed, I suppose we could walk away and feel confident about our application as is. However, in forward thinking other operations that could involve list items – such as deletion – I feel the responsibilities of the <em>list-controller</em> will quickly outgrow its intent. </p>
<p>I suppose, some would argue, that if the responsibilities of the list-controller grow to more operations that are tightly coupled with singular pieces of data, then we could just write more tests to verify its soundness. Not entirely a bad argument – i mean that is what we are trying to justify in this series, essentially. But it is not a 1:1 correlation of more tests to better design. It is preferred to separate concerns as much as possible in order to properly test. The maintenance of complex tests can be a bigger burden than the maintenance of complex code – so much so that testing stops all together.</p>
<h3 id="list-item-controller">list-item-controller</h3>
<p>Before we dive in to creating a <em>list-item-controller</em>, let’s take a look at what concerns within <em>list-controller</em> we want to move out. Looking from the <a href="https://github.com/bustardcelly/grocery-ls/blob/0.1.3/script/controller/list-controller.js">0.1.3 tagged list-controller</a>, we mainly want to cut out the item view creation – so the following node declarations and any associated item creation and item management:</p>
<p><em>/script/controller/list-controller.js tagged at 0.1.3</em></p>
<pre><code>itemFragment          = '<span class="tag">&lt;<span class="title">li</span> <span class="attribute">class</span>=<span class="value">"grocery-item"</span> /&gt;</span>',

editableItemFragment  = '<span class="tag">&lt;<span class="title">li</span> <span class="attribute">class</span>=<span class="value">"editable-grocery-item"</span>&gt;</span>' +

                                           '<span class="tag">&lt;<span class="title">input</span> <span class="attribute">id</span>=<span class="value">"editableItem"</span> <span class="attribute">name</span>=<span class="value">"editableItem"</span> ' +

                                               '<span class="attribute">class</span>=<span class="value">"editable-item"</span> <span class="attribute">placeholder</span>=<span class="value">"Enter item name..."</span>&gt;</span>' +

                                          '<span class="tag">&lt;/<span class="title">input</span>&gt;</span>' +

                                        '<span class="tag">&lt;/<span class="title">li</span>&gt;</span>'</code></pre>
<p>These declarations and management of view will be moved to the <em>list-item-controller</em>. The UI and usability of a list item will be driven by the model and should provide an API that is a level of abstraction from the model for any outside parties (ie, the <em>list-controller</em>). As well, the model drives the internal state of edit-ability and marked-off-ed-ness (<em>they’re words, alright</em>!), and the <em>list-item-controller</em> will dispatch events related to its change of state. Lofty goals, but let’s see if we can’t address them.</p>
<h4 id="a-bit-of-uncertainty">a bit of uncertainty</h4>
<p>We currently created specs for <em>Add Item</em> and <em>Mark Off Item</em> features. These were a little high-level in that they described features using the BDD syntax of <a href="http://pivotal.github.com/jasmine/">Jasmine</a> but did involve tests around how to interact with the <em>list-controller</em> API; so they do involve integration to some respect – we kind of ignore the whole UI and User Interaction aspect within the tests. </p>
<p>Now here is where I have an internal struggle with writing specs: should the tests we need for the <em>list-item-controller</em> be added to these specs? Or should a new spec focused on <em>list-item-controller</em> API and usability be born? I ask, because from outside-looking-in, the creation, editability and mark-off of an item will still be feasible through the <em>list-controller</em> and to any other third parties – that API provides a facade to modifying a grocery list. So, the current specs we have serve as a nice example of how to interact with the application from the outside… and if they are passing, we know that from higher-level things <em>should</em>* work <img src="http://custardbelly.com/blog/wp-includes/images/smilies/icon_smile.gif" alt=":)"></p>
<p>When we get down to the implementation of the <em>list-item-controller</em>, from a design perspective we know that a dependency will be introduced: <em>list-controller</em> will have n-number of <em>list-item-controller</em> instances, and will be responsible for the creation and maintenance of each <em>list-item-controller</em>. The state and <em>grocery-ls-item</em> model maintenance which we established in the previous articles as the responsibility of the <em>list-controller</em> will, as well, become the responsibility of the <em>list-item-controller</em>.</p>
<p>Knowing this, I start to feel that this is closer to testing the implementation and behaviour of a component, rather then one of the ’system’, and would push for its own spec. But I am very much open to ideas, so please leave a comment.</p>
<h3 id="list-item-controller-design">list-item-controller design</h3>
<p>In my <em>bit of uncertainty</em>, I basically described the design of the <em>list-item-controller</em>. Now, we’ll flesh out its behaviour and API in a spec and eventually move it to its own AMD implementation. To start out slowly we’ll create a new spec suite and define the <em>list-item-controller</em> attributes:</p>
<p><em>/test/jasmine/spec/list-item-controller.spec.js</em></p>
<pre><code>define([<span class="string">'jquery'</span>, <span class="string">'script/model/grocery-ls-item'</span>], function($, modelFactory) {



  describe(<span class="string">'list-item-controller'</span>, function() {



    function createStateEvent(oldState, newState) {

        <span class="keyword">var</span> <span class="keyword">event</span> = <span class="keyword">new</span> $.Event(<span class="string">'state-change'</span>);

        <span class="keyword">event</span>.oldState = oldState;

        <span class="keyword">event</span>.newState = newState;

        <span class="keyword">return</span> <span class="keyword">event</span>;

    }



    <span class="keyword">var</span> itemControllerFactory = {

        create: function(node, model) {

          <span class="keyword">var</span> itemController = Object.create(Object.prototype);



          (function(controller, stateEventCreator) {

            <span class="keyword">var</span> _state = <span class="string">'normal'</span>;

            Object.defineProperties(controller, {

              <span class="string">"model"</span>: {

                <span class="keyword">value</span>: model,

                writable: <span class="keyword">false</span>,

                enumerable: <span class="keyword">true</span>

              },

              <span class="string">"parentView"</span>: {

                <span class="keyword">value</span>: node,

                writable: <span class="keyword">false</span>,

                enumerable: <span class="keyword">true</span>

              },

              <span class="string">"state"</span>: {

                <span class="keyword">set</span>: function(<span class="keyword">value</span>) {

                  <span class="keyword">var</span> <span class="keyword">event</span> = stateEventCreator.call(<span class="keyword">this</span>, <span class="keyword">this</span>.state, <span class="keyword">value</span>);

                  _state = <span class="keyword">value</span>;

                  $(<span class="keyword">this</span>).trigger(<span class="keyword">event</span>);

                },

                <span class="keyword">get</span>: function() {

                  <span class="keyword">return</span> _state;

                }

              }

            });

          }(itemController, createStateEvent));



          <span class="keyword">return</span> itemController;

        }

      };

  });

});</code></pre>
<p>The object declared – <em>itemControllerFactory</em> – is a factory instance that will generate new instances of a <em>list-item-controller</em>. The factory pattern should be familiar to you if you look at the <em>grocery-ls-item</em> AMD we created in the second article in the series. When creating an instance of a <em>list-item-controller</em>, we have defined that a parent DOM node and a model should be passed in during creation, as can be seen in <em>itemControllerFactory:create()</em>. If we look at the <em>defineProperties</em>, we have also defined a few characteristics of the <em>list-item-controller</em> here. It has:</p>
<ul>
<li>Parent Node reference – DOM instance of which to modify view state.</li>
<li>Model reference – Model of which the View is driven by.</li>
<li>State – State of View within the DOM representing the Model.</li>
</ul>
<p>We have designed the <em>state</em> property a little differently than you may have seen before, at least in this series. We declared the implicit getter/setters so as to keep track of state internally and dispatch an event of <em>’state-change’</em>. By ‘<em>internally</em>‘, I mean I used an <a href="http://benalman.com/news/2010/11/immediately-invoked-function-expression/">IIFE</a> to enclose a ‘<em>private</em>‘ member storing state.</p>
<p>If you know of event-driven design – whether or not you are familiar with <a href="http://api.jquery.com/category/Events/?rdfrom=http%3A%2F%2Fdocs.jquery.com%2Fmw%2Findex.php%3Ftitle%3DAPI%2F1.3%2FEvents%26redirect%3Dno">jQuery Events</a>, which the <em>state</em> property employs – then this will look familiar. Essentially, we want to allow any client who wants to know about the change of state to a <em>list-item-controller</em> instance to be notified through an event of <em>’state-change’</em>. This will become more apparent later on in development, but just keep in mind that it is the responsibility of the <em>list-controller</em> to maintain n-number of <em>list-item-controller_s; and part of that maintenance is being aware of each _list-item-controller</em>’s state – and since binding is not inherently available in JavaScript, and I don’t want to introduce any new libraries that could handle binding, listening on events is an easy way to go about tracking state. <em>You feel adventurous enough, we can build a binding mechanism on top of this event system… just make sure it’s got tests <img src="http://custardbelly.com/blog/wp-includes/images/smilies/icon_smile.gif" alt=":)"> </em></p>
<h2 id="tests">Tests</h2>
<p>Before we begin creating the tests for the <em>list-item-controller</em>, you may be wondering where the feature stories and scenarios are. We could definitely define those, however – and of course, I can always be wrong – I feel those are more business-facing… well, stories at least. They are used to define some type of behaviour that is accepted as part of the software, with scenarios describing the various outcomes of a behaviour. Still valid for the case in hand of integrating the <em>list-item-controller</em>, but I tend to think this closer to testing on the implementation of behaviour. It’s a gray area to me, as well, if this all sounds confusing – I invite someone to step in and either clarify my understanding to set me straight. </p>
<p>Basically, our goal here is to verify the design and implementation of <em>list-item-controller</em>. If done properly this will pass, as well as the specs for the <em>Add Item</em> and <em>Mark Off Item</em> features we created in <a href="http://custardbelly.com/blog/2012/11/26/the-making-of-a-test-driven-grocery-list-application-in-js-part-ii/">previous</a> <a href="http://custardbelly.com/blog/2012/12/06/the-making-of-a-test-driven-grocery-list-application-in-js-part-iii/">articles</a>.</p>
<p>That said, let’s flesh out some tests that verify:</p>
<ol>
<li>Factory generates unique instances of list-item-controller</li>
<li>Model is preserved and immutable on list-item-controller</li>
<li>State is mutable through implicit getter/setters</li>
<li>Change to state is dispatched</li>
</ol>
<p><em>/test/jasmine/spec/list-item-controller.spec.js</em></p>
<pre><code>describe('Grocery <span class="type">list</span>-<span class="property">item</span>-controller', function() {



  var model,

      newController,

      async = new AsyncSpec(this);



  beforeEach( function() {

    model = modelFactory.create();

    newController = itemControllerFactory.create(parentNode, model);

  });



  describe('<span class="type">list</span>-<span class="property">item</span>-controller factory creation', function() {



    <span class="keyword">it</span>('should <span class="constant">return</span> a new instance <span class="keyword">of</span> <span class="type">list</span>-<span class="property">item</span>-controller', function() {

      expect(newController).<span class="keyword">not</span>.toBeUndefined();

    });



    <span class="keyword">it</span>('should <span class="constant">return</span> unique instances <span class="keyword">of</span> <span class="type">list</span>-<span class="property">item</span>-controllers', function() {

      var nextController = itemControllerFactory.create(parentNode, model);

      nextController.state = 'testing';

      expect(nextController).<span class="keyword">not</span>.toBe(newController);

      expect(nextController.state).<span class="keyword">not</span>.toBe(newController.state);

    });



  });



  describe('new <span class="type">list</span>-<span class="property">item</span>-controller instance', function() {



    <span class="keyword">it</span>('should expose model provided <span class="keyword">in</span> creation', function() {

      expect(newController.model).<span class="keyword">not</span>.toBeUndefined();

      expect(newController.model).toBe(model);

    });



    <span class="keyword">it</span>('should expose non-writable model', function() {

      var newModel = modelFactory.create();

      newController.model = newModel;

      expect(newController.model).<span class="keyword">not</span>.toBe(newModel);

      expect(newController.model).toBe(model);

    });



  describe('<span class="type">list</span>-<span class="property">item</span>-controller notifies <span class="function_start"><span class="keyword">on</span> <span class="title">state</span></span>-change', function() {



    async.<span class="keyword">it</span>('should provide old <span class="keyword">and</span> new state values <span class="function_start"><span class="keyword">on</span> <span class="title">state</span></span>-change', function(done) {

      var previousState = newController.state,

          newState = 'editable';



      $(newController).<span class="keyword">on</span>('state-change', function(event) {

        $(newController).off('state-change');



        expect(event.oldState).toBe(previousState);

        expect(event.newState).toBe(newState);

        expect(newController.state).toBe(newState);

        done();

      });

      newController.state = newState;

    });



  });



  });



  afterEach( function() {

    model = undefined;

    newController = undefined;

  });



});</code></pre>
<p>The last spec declared, as you may notice, runs asynchronously in order to test the state notification:</p>
<pre><code>async.<span class="keyword">it</span>('should provide old <span class="keyword">and</span> new state values <span class="function_start"><span class="keyword">on</span> <span class="title">state</span></span>-change', function(done) {</code></pre>
<p>The <em>AsyncSpec</em> object comes from the <a href="https://github.com/derickbailey/jasmine.async">jasmine.async library</a> we’ve previously included in the specrunner page. By invoking the spec (<em>it()</em>) through an instance of <em>AsyncSpec</em>, the spec is suspended until either it fails or the <em>done</em> delegate method is invoked. Since notification of state change is event-based, we use it in the spec to verify that the <em>list-item-controller</em> does dispatch that event.</p>
<p>Add that spec to the list:<br><em>/test/jasmine/specrunner.html</em></p>
<pre><code><span class="keyword">require</span>( [<span class="string">'spec/newitem.spec.js'</span>, <span class="string">'spec/markitem.spec.js'</span>, <span class="string">'spec/list-item-controller.spec.js'</span>], <span class="keyword">function</span>() {



  var jasmineEnv = jasmine.getEnv(),

     <span class="keyword">...</span>

  jasmineEnv.execute();



});</code></pre>
<p><img src="http://custardbelly.com/blog/images/tdd_js/part_iv_1.png" alt="passing list-item-controller spec"></p>
<h2 id="list-item-controller-implementation">list-item-controller implementation</h2>
<p>We’ve verified our design for the <em>list-item-controller</em> with passing tests, but we have yet to incorporate it into our system and offload the responsibilities (addressed earlier in this article) from the <em>list-controller</em> to it. Before we get there, however, let’s move the implementation of the <em>list-item-controller</em> (and the factory) out into its own AMD module. To start we’ll just move the <em>itemControllerFactory</em> declaration into a new file:</p>
<p><em>/script/controller/list-item-controller.js</em></p>
<pre><code>define([<span class="string">'jquery'</span>], function($) {



  function createStateEvent(oldState, newState) {

    <span class="keyword">var</span> <span class="keyword">event</span> = <span class="keyword">new</span> $.Event(<span class="string">'state-change'</span>);

    <span class="keyword">event</span>.oldState = oldState;

    <span class="keyword">event</span>.newState = newState;

    <span class="keyword">return</span> <span class="keyword">event</span>;

  }



  <span class="keyword">return</span> {

    create: function(node, model) {

      <span class="keyword">var</span> itemController = Object.create(Object.prototype);



      (function(controller, stateEventCreator) {

        <span class="keyword">var</span> _state;

        Object.defineProperties(controller, {

          <span class="string">"model"</span>: {

            <span class="keyword">value</span>: model,

            writable: <span class="keyword">false</span>,

            enumerable: <span class="keyword">true</span>

          },

          <span class="string">"parentView"</span>: {

            <span class="keyword">value</span>: node,

            writable: <span class="keyword">false</span>,

            enumerable: <span class="keyword">true</span>

          },

          <span class="string">"state"</span>: {

            <span class="keyword">set</span>: function(<span class="keyword">value</span>) {

              <span class="keyword">var</span> <span class="keyword">event</span> = stateEventCreator.call(<span class="keyword">this</span>, <span class="keyword">this</span>.state, <span class="keyword">value</span>);

              _state = <span class="keyword">value</span>;

              $(<span class="keyword">this</span>).trigger(<span class="keyword">event</span>);

            },

            <span class="keyword">get</span>: function() {

              <span class="keyword">return</span> _state;

            }

          }

        });

      }(itemController, createStateEvent));



      <span class="keyword">return</span> itemController.init();

    }

  };



});</code></pre>
<p>With that in place, we could modify the <em>list-item-controller.spec.js</em> file to include the <em>list-item-controller</em> dependency for testing:</p>
<p><em>/test/jasmine/spec/list-item-controller.spec.js</em></p>
<pre><code>define([<span class="string">'jquery'</span>, <span class="string">'script/model/grocery-ls-item'</span>, <span class="string">'script/controller/list-item-controller'</span>],

          <span class="keyword">function</span>($, modelFactory, itemControllerFactory) {

  // moved to script/controller/list-item-controller.js



  describe(<span class="string">'Grocery list-item-controller'</span>, <span class="keyword">function</span>() {

    <span class="keyword">...</span>

  });

});</code></pre>
<p>And our tests still pass! But… we want to move all the view and item management out of <em>list-controller</em> and have that handled by a <em>list-item-controller</em>. So let’s transfer over those view fragments and flesh out the <em>list-item-controller</em> object that is generated from the factory:</p>
<p><em>/script/controller/list-item-controller.js</em></p>
<pre><code>define([<span class="string">'jquery'</span>], <span class="keyword">function</span>($) {



  <span class="function"><span class="keyword">function</span> <span class="title">createStateEvent</span><span class="params">(oldState, newState)</span> {</span>

    <span class="keyword">var</span> event = <span class="keyword">new</span> $.Event(<span class="string">'state-change'</span>);

    event.oldState = oldState;

    event.newState = newState;

    <span class="keyword">return</span> event;

  }



   <span class="keyword">var</span> stateEnum = {

        UNEDITABLE: <span class="number">0</span>,

        EDITABLE: <span class="number">1</span>

      },

      uneditableItemFragment  = <span class="string">'&lt;p class="grocery-item" /&gt;'</span>,

      editableItemFragment    = <span class="string">'&lt;p class="editable-grocery-item"&gt;'</span> +

                                                  <span class="string">'&lt;input name="editableItem" '</span> +

                                                      <span class="string">'class="editable-item" placeholder="Enter item name..."&gt;'</span> +

                                                  <span class="string">'&lt;/input&gt;'</span> +

                                               <span class="string">'&lt;/p&gt;'</span>,

      listItemController = {

        $editableView: <span class="literal">undefined</span>,

        $uneditableView: <span class="literal">undefined</span>,

        init: <span class="keyword">function</span>() {

          <span class="keyword">this</span>.$editableView = $(editableItemFragment);

          <span class="keyword">this</span>.$uneditableView = $(uneditableItemFragment);



          <span class="comment">// default to undeditable state.</span>

          <span class="keyword">this</span>.state = stateEnum.UNEDITABLE;

          <span class="keyword">return</span> <span class="keyword">this</span>;

        }

      };



  <span class="keyword">return</span> {

    state: stateEnum,

    create: <span class="keyword">function</span>(node, model) {

      <span class="keyword">var</span> itemController = Object.create(listItemController);



      (<span class="keyword">function</span>(controller, stateEventCreator) {

        <span class="keyword">var</span> _state = <span class="string">'normal'</span>;

        Object.defineProperties(controller, {

          <span class="string">"model"</span>: {

            value: model,

            writable: <span class="literal">false</span>,

            enumerable: <span class="literal">true</span>

          },

          <span class="string">"parentView"</span>: {

            value: node,

            writable: <span class="literal">false</span>,

            enumerable: <span class="literal">true</span>

          },

          <span class="string">"state"</span>: {

            <span class="keyword">set</span>: <span class="keyword">function</span>(value) {

              <span class="keyword">var</span> event = stateEventCreator.call(<span class="keyword">this</span>, <span class="keyword">this</span>.state, value);

              _state = value;

              $(<span class="keyword">this</span>).trigger(event);

            },

            <span class="keyword">get</span>: <span class="keyword">function</span>() {

              <span class="keyword">return</span> _state;

            }

          }

        });

      }(itemController, createStateEvent));



      <span class="keyword">return</span> itemController.init();

    }

  };



});</code></pre>
<p>The <em>init()</em> method of a new <em>list-item-controller</em> is invoked upon creation and return in order to define the view references and default state. The fragment declarations have changed slightly as well – the list item wrappers have been removed. Basically, even though the name suggest that the view will reside in a list, we don’t want to tie the idea that they need to be <em>li</em> DOM elements since they also have no concept of what type of DOM element the <em>parentView</em> is.</p>
<p>As it stands with <a href="https://github.com/bustardcelly/grocery-ls/blob/0.1.3">our current work from the previous article</a>, the <em>list-controller</em> was responsible for listening on UI events of a list item – such as <em>‘blur’</em> on input and <em>‘click’</em>. It is the intent to relive the <em>list-controller</em> of such responsibility so we’ll transfer that over, as well:</p>
<p><em>/script/controller/list-item-controller.js</em></p>
<pre><code>listItemController = {

  $editableView: <span class="literal">undefined</span>,

  $uneditableView: <span class="literal">undefined</span>,

  init: <span class="reserved">function</span>() {

    <span class="keyword">this</span>.$editableView = $(editableItemFragment);

    <span class="keyword">this</span>.$uneditableView = $(uneditableItemFragment);



    <span class="regexp">//</span> view handlers.

    <span class="keyword">this</span>.$uneditableView.<span class="literal">on</span>(<span class="string">'click'</span>, (<span class="reserved">function</span>(controller) {

      <span class="keyword">return</span> <span class="reserved">function</span>(event) {

        <span class="reserved">var</span> toggled = controller.$uneditableView.css(<span class="string">'text-decoration'</span>) === <span class="string">'line-through'</span>;

        controller.model.marked = !toggled;

      };

    }(<span class="keyword">this</span>)));

    $(<span class="string">'input'</span>, <span class="keyword">this</span>.$editableView).<span class="literal">on</span>(<span class="string">'blur'</span>, (<span class="reserved">function</span>(controller) {

      <span class="keyword">return</span> <span class="reserved">function</span>(event) {

        controller.model.name = $(<span class="keyword">this</span>).val();

        controller.state = stateEnum.UNEDITABLE;

      };

    }(<span class="keyword">this</span>)));



    <span class="regexp">//</span> <span class="reserved">default</span> to undeditable state.

    <span class="keyword">this</span>.state = stateEnum.UNEDITABLE;

    <span class="keyword">return</span> <span class="keyword">this</span>;

  }

};</code></pre>
<p>Again, we are using an <strong>IIFE</strong>, and in this case to pass in a reference to the controller instance. I could have easily defined a new variable like</p>
<pre><code><span class="keyword">var</span> <span class="keyword">self</span> = <span class="keyword">this</span>;</code></pre>
<p>but that always makes me cry a little inside. Anyway, so we are listening on click of the uneditable view item in order to update value of the <em>marked</em> property on the model and we have assigned a <em>blur</em> handler on the input of the editable view item that updates the value of the <em>name</em> property of the model and flips the state. Now we have to respond to those changes <img src="http://custardbelly.com/blog/wp-includes/images/smilies/icon_smile.gif" alt=":)"></p>
<p><em>/script/controller/list-item-controller.js</em></p>
<pre><code><span class="attribute">init</span>: <span class="string">function() {</span>

<span class="coffeescript">  <span class="keyword">this</span>.$editableView = $(editableItemFragment);

  <span class="keyword">this</span>.$uneditableView = $(uneditableItemFragment);



  <span class="regexp">//</span> view handlers.

  <span class="keyword">this</span>.$uneditableView.<span class="literal">on</span>(<span class="string">'click'</span>, (<span class="reserved">function</span>(controller) {

    <span class="keyword">return</span> <span class="reserved">function</span>(event) {

      <span class="reserved">var</span> toggled = controller.$uneditableView.css(<span class="string">'text-decoration'</span>) === <span class="string">'line-through'</span>;

      controller.model.marked = !toggled;

    };

  }(<span class="keyword">this</span>)));

  $(<span class="string">'input'</span>, <span class="keyword">this</span>.$editableView).<span class="literal">on</span>(<span class="string">'blur'</span>, (<span class="reserved">function</span>(controller) {

    <span class="keyword">return</span> <span class="reserved">function</span>(event) {

      controller.model.name = $(<span class="keyword">this</span>).val();

      controller.state = stateEnum.UNEDITABLE;

    };

  }(<span class="keyword">this</span>)));

  <span class="regexp">//</span> state &amp; model handlers.

  $(<span class="keyword">this</span>).<span class="literal">on</span>(<span class="string">'state-change'</span>,  (<span class="reserved">function</span>(controller) {

    <span class="keyword">return</span> <span class="reserved">function</span>(event) {

      handleStateChange.call(<span class="literal">null</span>, controller, event);

    };

  }(<span class="keyword">this</span>)));

  $(<span class="keyword">this</span>.model).<span class="literal">on</span>(<span class="string">'property-change'</span>, (<span class="reserved">function</span>(controller) {

    <span class="keyword">return</span> <span class="reserved">function</span>(event) {

      handlePropertyChange.call(<span class="literal">null</span>, controller, event);

    };

  }(<span class="keyword">this</span>)));

  <span class="regexp">//</span> <span class="reserved">default</span> to undeditable state.

  <span class="keyword">this</span>.state = stateEnum.UNEDITABLE;

  <span class="keyword">return</span> <span class="keyword">this</span>;

}</span></code></pre>
<p>The <em>handleStateChange</em> delegate is responsible for updating the view based on a change to state: either <em>EDITABLE</em> or <em>UNEDITABLE</em> from the <em>stateEnum</em> object:</p>
<pre><code>function handleStateChange(controller, <span class="keyword">event</span>) {

  <span class="comment">// remove state-based item.</span>

  <span class="keyword">if</span>( typeof <span class="keyword">event</span>.oldState !== <span class="string">'undefined'</span>) {

    <span class="keyword">if</span>(<span class="keyword">event</span>.oldState === stateEnum.UNEDITABLE) {

      controller.<span class="variable">$uneditableView</span>.detach();

    }

    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">event</span>.oldState === stateEnum.EDITABLE) {

      controller.<span class="variable">$editableView</span>.detach();

    }

  }

  <span class="comment">// append state-based item.</span>

  <span class="keyword">if</span>(<span class="keyword">event</span>.newState === stateEnum.UNEDITABLE) {

    controller.parentView.append(controller.<span class="variable">$uneditableView</span>);

  }

  <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">event</span>.newState === stateEnum.EDITABLE) {

    var inputTimeout = setTimeout( function()  {

      clearTimeout(inputTimeout);

      <span class="variable">$(</span><span class="string">'input'</span>, controller.<span class="variable">$editableView</span>).focus();

    }, <span class="number">100</span>);

    controller.parentView.append(controller.<span class="variable">$editableView</span>);

  }

}</code></pre>
<p>The <em>handlePropertyChange</em> delegate is responsible for updating the views based on the <em>model</em> property values:</p>
<pre><code>function handlePropertyChange(controller, <span class="keyword">event</span>) {

  <span class="keyword">if</span>(<span class="keyword">event</span>.property === <span class="string">"name"</span>) {

    <span class="comment">// update view based on model change.</span>

    <span class="variable">$(</span><span class="string">'input'</span>, controller.<span class="variable">$editableView</span>).val(controller.model.name);

    controller.<span class="variable">$uneditableView</span>.<span class="keyword">text</span>(<span class="keyword">event</span>.newValue);

  }

  <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">event</span>.property === <span class="string">"marked"</span>) {

    <span class="comment">// update view based on model change.</span>

    controller.<span class="variable">$uneditableView</span>.css(<span class="string">'text-decoration'</span>, (<span class="keyword">event</span>.newValue) ? <span class="string">'line-through'</span> : <span class="string">'none'</span>);

  }

}</code></pre>
<p>That pretty much shores up the implementation for the <em>list-item-controller</em> taking on the responsibilities of view creation and management based on state and model updates. But running the tests from this point will fail. The reason being a change to design on the model.</p>
<h2 id="grocery-ls-item-modification">grocery-ls-item Modification</h2>
<p>One particular change to design introduced in the implementation for <em>list-item-controller</em> is response to <em>‘property-change’</em> event from the model. In our work up to this point, the <em>grocery-ls-item</em> is a basic object; we’ll use the same paradigm that we implemented for notification of state for the <em>grocery-ls-item</em> in order to respond to changes on model properties. Although a simple change, we need to first test our design before modifying the code for the <em>grocery-ls-item</em>. Lets create a new spec file for our model:</p>
<p><em>/test/jasmine/spec/grocery-ls-item.spec.js</em></p>
<pre><code>define(['jquery', '<span class="keyword">script</span>/model/grocery-ls-<span class="property">item</span>'], function($, modelFactory) {



  describe('Grocery grocery-ls-<span class="property">item</span> model', function() {



    var model,

        <span class="property">name</span> = 'grapes',

        async = new AsyncSpec(this);



    beforeEach( function() {

      model = modelFactory.create();

      model.<span class="property">name</span> = <span class="property">name</span>;

      model.marked = <span class="constant">false</span>;

    });



    describe('grocery-ls-<span class="property">item</span> factory model creation', function() {



      <span class="keyword">it</span>('should generate unique instances <span class="keyword">of</span> model', function() {

        var newModel = modelFactory.create();

        expect(model).<span class="keyword">not</span>.toBeUndefined();

        expect(newModel).<span class="keyword">not</span>.toBeUndefined();

        expect(model).<span class="keyword">not</span>.toBe(newModel);

      });



      async.<span class="keyword">it</span>('should auto generate unique ids <span class="function_start"><span class="keyword">on</span> <span class="title">models</span></span>', function(done) {

        var newModel,

            creationTimeout;



        // Offload creation because ids are generated based <span class="function_start"><span class="keyword">on</span> <span class="title">time</span></span>.

        // This allows <span class="keyword">for</span> timestamp <span class="keyword">to</span> progess.

        creationTimeout = setTimeout(function() {

          clearTimeout(creationTimeout);

          newModel = modelFactory.create();

          expect(model.<span class="property">id</span>).<span class="keyword">not</span>.toBeUndefined();

          expect(typeof model.<span class="property">id</span>).toBe('<span class="type">number</span>');

          expect(model.<span class="property">id</span>).<span class="keyword">not</span>.toEqual(newModel.<span class="property">id</span>);

          done();

        }, <span class="number">100</span>);

      });



    });



    describe('grocery-ls-<span class="property">item</span> properties', function() {



      <span class="keyword">it</span>('should <span class="keyword">contain</span> an immutable <span class="property">id</span> <span class="keyword">property</span>, created <span class="keyword">at</span> instantiation', function() {

        var newID = <span class="number">1234567</span>;

        model.<span class="property">id</span> = newID;



        expect(model.<span class="property">id</span>).<span class="keyword">not</span>.toEqual(newID);

      });



    });



    describe('grocery-ls-<span class="property">item</span> <span class="keyword">property</span> change notification', function() {



      async.<span class="keyword">it</span>('should notify <span class="keyword">with</span> \'<span class="keyword">property</span>-change\' upon change <span class="keyword">to</span> <span class="property">name</span> <span class="keyword">property</span>', function(done) {

        var oldName = model.<span class="property">name</span>,

            newName = 'apples';

        $(model).<span class="keyword">on</span>('<span class="keyword">property</span>-change', function(event) {

          expect(event.<span class="keyword">property</span>).toEqual('<span class="property">name</span>');

          expect(event.oldValue).toEqual(oldName);

          expect(event.newValue).toEqual(newName);

          $(model).off('<span class="keyword">property</span>-change');

          done();

        });

        model.<span class="property">name</span> = newName;

      });



      async.<span class="keyword">it</span>('should notify <span class="keyword">with</span> \'<span class="keyword">property</span>-change\' upon change <span class="keyword">to</span> marked <span class="keyword">property</span>', function(done) {

        var oldValue = model.marked,

            newValue = <span class="constant">true</span>;

        $(model).<span class="keyword">on</span>('<span class="keyword">property</span>-change', function(event) {

          expect(event.<span class="keyword">property</span>).toEqual('marked');

          expect(event.oldValue).toEqual(oldValue);

          expect(event.newValue).toEqual(newValue);

          $(model).off('<span class="keyword">property</span>-change');

          done();

        });

        model.marked = newValue;

      });



    });



    afterEach( function() {

      model = undefined;

    });



  });



});</code></pre>
<p>We have a few suites there to verify:</p>
<ol>
<li>Model generation from factory produces unique items</li>
<li>Model property immutability for auto-assigned IDs</li>
<li>Event notification on property change</li>
</ol>
<p>We add that to our spec runner:</p>
<pre><code><span class="keyword">require</span>( [<span class="string">'spec/newitem.spec.js'</span>, <span class="string">'spec/markitem.spec.js'</span>,

          <span class="string">'spec/item-controller.spec.js'</span>, <span class="string">'spec/grocery-ls-item.spec.js'</span>], <span class="keyword">function</span>() {



  var jasmineEnv = jasmine.getEnv(),

     <span class="keyword">...</span>

  jasmineEnv.execute();



});</code></pre>
<p>… and it fails. Whoopee! It’s supposed to. Now we just take the knowledge we know of wiring up event notification on state of the <em>list-item-controller</em>, and apply it to <em>property-change</em> on the model:</p>
<p><em>/script/model/grocery-ls-item.js</em></p>
<pre><code>define([<span class="string">'jquery'</span>], function($) {



  <span class="keyword">var</span> propertyEvent = {

      create: function(property, oldValue, newValue) {

        <span class="keyword">var</span> <span class="keyword">event</span> = $.Event(<span class="string">'property-change'</span>);

        <span class="keyword">event</span>.property = property;

        <span class="keyword">event</span>.oldValue = oldValue;

        <span class="keyword">event</span>.newValue = newValue;

        <span class="keyword">return</span> <span class="keyword">event</span>;

      }

    },

    properties = function(id) {

      <span class="keyword">return</span> {

        <span class="string">"id"</span>: {

          <span class="keyword">value</span>: id,

          writable: <span class="keyword">false</span>,

          enumerable: <span class="keyword">true</span>

        },

        <span class="string">"name"</span>: {

          enumerable: <span class="keyword">true</span>,

          <span class="keyword">set</span>: function(<span class="keyword">value</span>) {

            <span class="keyword">var</span> oldValue = <span class="keyword">this</span>._name;

            <span class="keyword">this</span>._name = <span class="keyword">value</span>;

            $(<span class="keyword">this</span>).trigger(propertyEvent.create(<span class="string">'name'</span>, oldValue, <span class="keyword">value</span>));

          },

          <span class="keyword">get</span>: function() {

            <span class="keyword">return</span> <span class="keyword">this</span>._name;

          }

        },

        <span class="string">"marked"</span>: {

          enumerable: <span class="keyword">true</span>,

          <span class="keyword">set</span>: function(<span class="keyword">value</span>) {

            <span class="keyword">var</span> oldValue = <span class="keyword">this</span>._marked;

            <span class="keyword">this</span>._marked = <span class="keyword">value</span>;

            $(<span class="keyword">this</span>).trigger(propertyEvent.create(<span class="string">'marked'</span>, oldValue, <span class="keyword">value</span>));

          },

          <span class="keyword">get</span>: function() {

            <span class="keyword">return</span> <span class="keyword">this</span>._marked;

          }

        }

      };

    };



  <span class="keyword">return</span> {

    create: function() {

      <span class="keyword">return</span> Object.create(Object.prototype, properties(<span class="keyword">new</span> Date().getTime()));

    }

  };



});</code></pre>
<p>The modification to <em>grocery-ls-item</em> was perhaps our first introduction to writing failing tests due to a change in design prior to actually modifying the implementation. That feeling you’re feeling right now… that’s what makes this all worth it <img src="http://custardbelly.com/blog/wp-includes/images/smilies/icon_wink.gif" alt=";)"></p>
<p>Anyway… hold on to that feeling until the next post, because we are not done and it will go away quickly… just kidding <img src="http://custardbelly.com/blog/wp-includes/images/smilies/icon_smile.gif" alt=":)"></p>
<p><strong>Tagged</strong>: 0.1.5 <a href="https://github.com/bustardcelly/grocery-ls/tree/0.1.5"><a href="https://github.com/bustardcelly/grocery-ls/tree/0.1.5">https://github.com/bustardcelly/grocery-ls/tree/0.1.5</a></a></p>
<h2 id="blinders">Blinders</h2>
<p>If you were to run the tests again… they still pass!<br><img src="http://custardbelly.com/blog/images/tdd_js/part_iv_2.png" alt="passing grocery-ls-item spec"></p>
<p>That is because we have not changed <em>list-controller</em> at all <img src="http://custardbelly.com/blog/wp-includes/images/smilies/icon_smile.gif" alt=":)"></p>
<p>Our <em>list-item-controller.spec.js</em> is happily oblivious to our recent additions and modifications, and the tests we wrote previously for the <em>Add Item</em> and <em>Mark Off Item</em> features still pass. </p>
<p>Before we just start chopping out and inserting code from <em>list-controller</em>, I want to go over the API and specs currently defined and see if they still hold water – meaning we might be able to cut some tests out. We might not. We might even add more… That’s what i plan to address in the next article of this series.</p>
<p>—</p>
<h1 id="link-dump">Link Dump</h1>
<h2 id="reference">Reference</h2>
<p><a href="http://tddjs.com/">Test-Driven JavaScript Development by Christian Johansen</a><br><a href="http://dannorth.net/introducing-bdd/">Introducing BDD by Dan North</a><br><a href="http://benalman.com/news/2010/11/immediately-invoked-function-expression/">Immediately-Invoked Function Expression (IIFE) by Ben Alman</a><br><a href="http://requirejs.org/">RequireJS</a><br><a href="https://github.com/amdjs/amdjs-api/wiki/AMD">AMD</a><br><a href="http://pivotal.github.com/jasmine/">Jasmine</a><br><a href="http://sinonjs.org/">Sinon</a><br><a href="https://github.com/derickbailey/jasmine.async">Jasmine.Async</a></p>
<h2 id="post-series">Post Series</h2>
<p><a href="https://github.com/bustardcelly/grocery-ls">grocery-ls github repo</a><br><a href="http://custardbelly.com/blog/2012/11/26/the-making-of-a-test-driven-grocery-list-application-in-javascript-part-i">Part I – Introduction</a><br><a href="http://custardbelly.com/blog/2012/11/26/the-making-of-a-test-driven-grocery-list-application-in-js-part-ii">Part II – Feature: Add Item</a><br><a href="http://custardbelly.com/blog/2012/12/06/the-making-of-a-test-driven-grocery-list-application-in-js-part-iii">Part III – Feature: Mark-Off Item</a><br><a href="http://custardbelly.com/blog/2012/12/17/the-making-of-a-test-driven-grocery-list-application-in-js-part-iv">Part IV – Feature: List-Item-Controller</a><br><a href="http://custardbelly.com/blog/2012/12/31/the-making-of-a-test-driven-grocery-list-application-in-js-part-v/">Part V – Feature: List-Controller Refactoring</a><br><a href="http://custardbelly.com/blog/2013/01/08/the-making-of-a-test-driven-grocery-list-application-in-js-part-vi/">Part VI – Back to Passing</a><br><a href="http://custardbelly.com/blog/2013/01/17/the-making-of-a-test-driven-grocery-list-application-in-js-part-vii/">Part VII – Remove Item</a><br><a href="http://custardbelly.com/blog/2013/01/22/the-making-of-a-test-driven-grocery-list-application-part-viii/">Part VIII – Bug Fixing</a><br><a href="http://custardbelly.com/blog/2013/02/15/the-making-of-a-test-driven-grocery-list-application-in-js-part-ix/">Part IX – Persistence</a><br><a href="http://custardbelly.com/blog/2013/03/06/the-making-of-a-test-driven-grocery-list-application-in-js-part-x/">Part X – It Lives!</a></p>
<p>Posted in <a href="http://custardbelly.com/blog/category/amd/">AMD</a>, <a href="http://custardbelly.com/blog/category/javascript/">JavaScript</a>, <a href="http://custardbelly.com/blog/category/requirejs/">RequireJS</a>, <a href="http://custardbelly.com/blog/category/grocery-ls/">grocery-ls</a>, <a href="http://custardbelly.com/blog/category/jasmine/">jasmine</a>, <a href="http://custardbelly.com/blog/category/unit-testing/">unit-testing</a>.</p>

  </section>
  <section class="navigation">
      
        <span class="newer"><a href="http://custardbelly.com/blog/blog-posts/2012/12/31/the-making-of-a-test-driven-grocery-list-application-in-js-part-v/index.html">&#8672;&nbsp;newer</a></span>
      
      
        <span class="older"><a href="http://custardbelly.com/blog/blog-posts/2012/12/06/the-making-of-a-test-driven-grocery-list-application-in-js-part-iii/index.html">older&nbsp;&#8674;</a></span>
      
    </section>
  <section class="comments">
    
      <div id="disqus_thread"></div>
      <script type="text/javascript">
        window.disqus_identifier="";
        window.disqus_url="http://custardbelly.com/blog/blog-posts/2012/12/17/the-making-of-a-test-driven-grocery-list-application-in-js-part-iv/index.html";
        window.disqus_title="The Making of a Test-Driven Grocery List Application in JS: Part IV";
      </script>
        <script type="text/javascript" src="http://disqus.com/forums/custardbelly/embed.js"></script>
        <noscript><a href="http://custardbelly.disqus.com/?url=ref">View the discussion thread.</a></noscript>
    
  </section>
</article>

    <footer>
      Copyright Todd Anderson, 2014.
      <div>Icon made by <a href="http://www.flaticon.com/free-icon/google-plus-symbol-in-a-circle_24171" title="Icomoon">Icomoon</a> from <a href="http://www.flaticon.com" title="Flaticon">www.flaticon.com</a></div>
      <div>Icon made by <a href="http://www.flaticon.com/free-icon/social-rss-circle-internet_10010" title="Elegant Themes">Elegant Themes</a> from <a href="http://www.flaticon.com" title="Flaticon">www.flaticon.com</a></div>
    </footer>
    <script src="http://custardbelly.com/blog/lib/highlight/highlight.pack.js"></script>
    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-29061897-1']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();

    </script>
  </body>
</html>
