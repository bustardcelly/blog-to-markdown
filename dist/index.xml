<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Todd Anderson]]></title><description><![CDATA[ramblings about making things for web, mobile, desktop and land.]]></description><link>http://custardbelly.com/blog</link><generator>RSS for Node</generator><lastBuildDate>Fri, 10 Jan 2014 14:13:04 GMT</lastBuildDate><atom:link href="http://custardbelly.com/blog/index.xml" rel="self" type="application/rss+xml"/><author><![CDATA[Todd Anderson]]></author><item><title><![CDATA[BDD in JavaScript: CucumberJS]]></title><description><![CDATA[<p>I have previously written about <strong>TDD</strong> in JavaScript, most notably using the BDD-style library <a href="https://github.com/pivotal/jasmine">Jasmine</a> in a series on <a href="http://custardbelly.com/blog/blog-pages/category/grocery-ls.html">building a Test-Driven Grocery List Application</a>. In that posts series I went through thinking of User Stories for features and scenarios as actual development tasks, and - reading back on it - it&#39;s all very green in my finding a way to deliver test-driven code. Nothing wrong with that and I will most likely look upon this and subsequent posts in the same manner. That said, I still hold true that TDD is the best way to deliver concise, tested and well thought-out code.</p>
<p>Since that time, however, I have incorporated a different tool into my <strong>TDD</strong> workflow for JavaScript-based projects that affords me the integration of feature specs more closely to my development and truly encompasses my current ideal of <strong>Behaviour Driven Development</strong>: <a href="https://github.com/cucumber/cucumber-js">CucumberJS</a>.</p>
<h2 id="gherkin">Gherkin</h2>
<h2 id="step-definitions">Step Definitions</h2>
<h2 id="world">World</h2>
<h2 id="grunt-tasks">Grunt Tasks</h2>
<h2 id="conclusion">Conclusion</h2>
<p>In a following post I want to address how I use cucumberjs to run tests that rely on browser integration - ie, window and document access.</p>
<p>In the past I have used zombie to much success, but oscar has tipped me to him karma solution that I am excited to test-drive.</p>
]]></description><link>http://custardbelly.com/blog/blog-posts/2014/01/08/bdd-in-js-cucumberjs/index.html</link><guid isPermaLink="true">http://custardbelly.com/blog/blog-posts/2014/01/08/bdd-in-js-cucumberjs/index.html</guid><dc:creator><![CDATA[Todd Anderson]]></dc:creator><pubDate>Invalid Date</pubDate></item><item><title><![CDATA[A slight obsession over page speed]]></title><description><![CDATA[<p>Lately, several projects (both personal and work-related) have ignited an increasing obsession over page load speed and performance. I wanted to highlight a few tools and resources I find useful in analyzing performance and delivering web pages in production with optimal load time.</p>
<h2 id="where-d-this-hat-come-from-">Where&#39;d this hat come from?</h2>
<p>Over the past decade I primarily have been a client-side application developer. Sometimes my business card changes or personal introductions are made that get &#39;engineer&#39; and &#39;architect&#39; thrown in there, but truthfully I spend my days coding applications, regardless of language. I enjoy writing and shipping code under certain practices and methodologies and ocassionally pause to assess my current workflow and modify where bottlenecks are prevelant.</p>
<p>Up until recent years I was primarily concerned with code performance; rendering pipelines and element lifecycles, user-perceived performance cases for remote or off-loaded operations, optimizing algorithms for sorting, mapping, analyzing data, etc. I still am, but I also have become increasingly focused on delivery and load perfomance - especially in today&#39;s climate of people viewing web content on handheld devices without WiFi available. </p>
<p>Perhaps it is due the increasing work of web-based clients over desktop or native applications, but - if I am being honest - I never really paid attention to load time for older web-based application projects for several reasons:</p>
<ul>
<li>Flash plugin (preload, skip intro)</li>
<li>Desktop browser targets</li>
<li>Blind naivete</li>
</ul>
<p>However, as an end-user myself (don&#39;t like the term much, either) trying to access web content on my phone while on my bus ride home, my world is consumed with <code>waiting...</code>. As such, I wised up rather quick when I started to think about how someone would be absolutely frustrated and move on after 1/4 second without seeing any visible load response from a web application I lovingly crafted to in some way (hopefully) make their life easier.</p>
<p>That&#39;s when I started incorporating page load analysis to my deployment workflow.</p>
<h2 id="best-practices">Best Practices</h2>
<p>There is excellent documentation out there regarding best practices in delivering web pages with optimal performance. Some of the best known ones are below:</p>
<p>Yahoo: <a href="http://developer.yahoo.com/performance/rules.html">Best Practices for Speeding Up Your Web Site</a><br>Google: <a href="https://developers.google.com/speed/docs/best-practices/rules_intro">Web Perfomance Best Practices; Google</a><br>Steve Souders: <a href="http://stevesouders.com/hpws/rules.php">14 Rules for Faster-Loading Web Sites</a></p>
<p>I won&#39;t rehash the tidbits those articles provide, so please visit those links for a wealth of information and follow the following blogs to keep abreast of the latest in research and development of web performance:</p>
<ul>
<li><a href="http://stevesouders.com/">Steve Souders</a></li>
<li><a href="http://calendar.perfplanet.com/">Perfomance Calendar</a>  </li>
</ul>
<p>One aspect I find interesting is that a handful of the preferred optimizations described in those articles - such as concatenation, data-uris and script and styles placement on pages - have actually become part of the build phase of my development workflow, especially with the rise of tools such as <a href="http://gruntjs.com">Grunt</a> and the developer community creating post-process tasks. </p>
<p>It is not taken for granted that I can select tools and code under certain architectural principles I perceive as providing a comfortable development environment and have these tools at my disposal to deliver the end product in an optimal fashion. <em>Another resolution for this year is to contribute more to the libraries and tools I use often - whether through code or monetary donations.</em></p>
<h2 id="manual-performance-analysis">Manual Performance Analysis</h2>
<p>There are a few sites and tools I visit that will perform analysis on a site while in development:</p>
<ul>
<li><a href="http://www.webpagetest.org/">WebPageTest</a></li>
<li><a href="http://gtmetrix.com/">GTmetrix</a></li>
<li><a href="http://tools.pingdom.com/">pingdom</a></li>
<li><a href="https://developers.google.com/speed/docs/insights/using_chrome">PageSpeed Chrome Developer Tool</a></li>
</ul>
<p>Additonally, <a href="http://www.feedthebot.com/tools/">feedthebot</a> has a handful of neat little tools to test some things - specifically if gzip is working on your site.</p>
<p>They all - along with various other metrics - provide a scoring based on some criteria which, as far as I can tell, are defined either by <strong>Yahoo!</strong> (via <a href="http://developer.yahoo.com/yslow/">yslow</a>) or <strong>Google</strong> (via <a href="https://developers.google.com/speed/pagespeed/?csw=1">PageSpeed</a>).</p>
<p>Typically I stick to opening and running <a href="https://developers.google.com/speed/pagespeed/?csw=1">PageSpeed</a> when developing in Chrome to get a overall recommndation of optimizations and then visit <a href="http://www.webpagetest.org/">WebPageTest</a> when I want some serious analysis and am busy updating my <strong>.htaccess</strong> file with rewrites and expiries.</p>
<h2 id="integrating-performance-reporting-in-workflow">Integrating Performance Reporting in Workflow</h2>
<p>Running analysis using tools described above is a great way to see some metrics and determine what solutions to take to better the load performance of your site/application, but I like to automate all the things when I can as well as provide reporting to Continuous Integration servers so that we can document progress or failures. To provide such value, I am a strong proponent of using <a href="http://www.sitespeed.io/">sitespeed.io</a>.</p>
<p>I have nothing bad to say about <a href="http://www.sitespeed.io/">sitespeed.io</a>. It&#39;s built on top of <a href="https://github.com/ariya/phantomjs">PhantomJS</a>, <a href="https://github.com/marcelduran/yslow/">yslow</a>, <a href="https://github.com/tobli/browsertime">browsertime</a> and <a href="https://github.com/twbs/bootstrap/">bootstrap</a>. You can alternatively use the <a href="http://yslow.org/phantomjs/">yslow script for PhantomJS</a> if you want something more stripped down, but <a href="http://www.sitespeed.io/">sitespeed.io</a> generates a nice set of web documents that provide performance summaries along with being able to produce a <strong><a href="http://www.sitespeed.io/documentation/#junit">JUnit</a></strong> report for CI.</p>
<p>The documentation for <strong>sitespeed.io</strong> is thorough and easy to follow along and the <a href="http://www.sitespeed.io/documentation/#configuration">configuration options</a> are insanely helpful in finding possible pages on your site that may be of issue.</p>
<h3 id="grunt-integration">Grunt integration</h3>
<p>I am sure there is some <a href="http://gruntjs.com">Grunt</a> task out there in the wild that hooks into running <strong>sitespeed.io</strong> (or I should probably just stop being lazy and make one), but I have yet to find or search for one. I personally just use <a href="https://github.com/jharding/grunt-exec">grunt-exec</a> to run the command during a build and deploy. With the proper <a href="http://www.sitespeed.io/documentation/#installation">installation of sitespeed.io</a>, I have the following subtask under <code>exec</code> task:</p>
<pre><code>grunt.initConfig({
  <span class="hljs-keyword">...</span>
  exec: {
    sitespeed: {
      cmd: <span class="hljs-string">'sitspeed.io -u http://staging.mysite.com -r ./doc/metrics'</span>
    }
  }
}
});

grunt.loadNpmTasks(<span class="hljs-string">'grunt-exec'</span>);
grunt.registerTask(<span class="hljs-string">'dryrun'</span>, <span class="hljs-string">'Build, deploy and analyze.'</span>,\ 
  [<span class="hljs-string">'build'</span>, <span class="hljs-string">'deploy:staging'</span>, <span class="hljs-string">'exec:sitespeed'</span>]);
</code></pre><p>That generates the JUnit report and summary documentation artifacts that can be consumed and presented by your CI server of choice. I also have a tendency to use the <a href="https://github.com/marcelduran/yslow/">yslow</a> script for <a href="https://github.com/ariya/phantomjs">PhantomJS</a> in tandem on the <code>exec</code> task as that will print out my perfomance grade in the console after issuing my <strong>grunt</strong> deployment.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Sometimes, especially when working with 3rd party libraries, web fonts, etc, it is unrealistic to hit 100 for your performance grading - who am I kidding, it is damn near impossible. I try to stay above 90 and feel satisfied. </p>
<p>As well, it should be stated that the final test is actually physically visiting the sites on handheld devices over a data plan. As I mentioned previously, I usually do some perceived perfomance testing while on the bus ride home, ensuring that I don&#39;t get frustrated with the load time on my own work (and I hope I am more critical of my own stuff than others are ;)).</p>
<p>This is just the tip of the iceberg when it comes to analyzing load performance and with developments coming out of Google, such as <a href="http://www.chromium.org/spdy/spdy-whitepaper">SPDY</a> and <a href="https://code.google.com/p/modpagespeed/">mod_pagespeed</a>, an exciting space to keep an eye on in order to deliver your content faster and keep end-users happily enjoying your sites and applications.</p>
]]></description><link>http://custardbelly.com/blog/blog-posts/2014/01/06/obsession-over-page-speed/index.html</link><guid isPermaLink="true">http://custardbelly.com/blog/blog-posts/2014/01/06/obsession-over-page-speed/index.html</guid><dc:creator><![CDATA[Todd Anderson]]></dc:creator><pubDate>Invalid Date</pubDate></item><item><title><![CDATA[So long WordPress]]></title><description><![CDATA[<p>Originally a resolution for 2012, then 2013, I am making good early this year on getting rid of my reliance on <a href="http://wordpress.org/">WordPress</a> as my blog engine - in fact, getting rid of <em>any</em> engine to manage and serve blog posts; I converted all my old posts to static files and will be writing posts in markdown from now on.</p>
<h2 id="out-with-the-old">Out with the old</h2>
<p>Within the past couple years it just felt laborious to maintain my blog - not so much in actually writing content, but rather in dealing with spam, upgrading WordPress to ward off attacks until the next upgrade, finding syntax highlight replacements and other plugins as interests changed/grew. As a consequence, I think it did affect me actually wanting to log into the admin console to write posts.</p>
<p>Along with maintenance of the my self-host WordPress being a bothersome heft, the WYSIWYG editor and all the extra bells and whistles in the admin console it provided just seemed to be a lot of useless noise. I have grown quite comfortable writing documentation in <a href="http://daringfireball.net/projects/markdown/">markdown</a> (due, in most part, to the rise of <a href="https://github.com/">GitHub</a>) and felt the experience of writing in such a context much more liberating and free-flowing. </p>
<p>As such, I started looking at what else was out there that would allow me to:</p>
<ul>
<li>get rid of the dynamicism of serving blog posts  </li>
<li>throw out requirement of a database to store and maintain information  </li>
<li>write posts in markdown  </li>
<li>easily generate and maintain static files</li>
</ul>
<h2 id="the-solution">The solution</h2>
<p>As I mentioned previously, I started investigating solutions for the line items above a few years ago. Sitting on my desire to get rid of WordPress for so long has afforded me two things:</p>
<ul>
<li>growing frustration that I still have to deal with WordPress</li>
<li>keeping track of the climate of tools that allow for generating static content from markdown</li>
</ul>
<p>Naturally, the first one I gave a shot at back in 2012 was <a href="http://jekyllrb.com/">Jekyll</a>, and then the <a href="http://octopress.org/">Octopress</a> framework. Truly great software which you should check out if you haven&#39;t had a chance. It was most likely the involvement of Octopress and maintenance that started to weigh down on me continuing to pursue it as an option and look for something more lightweight.</p>
<p>Within the time frame, as well, saw the rise of <a href="http://gruntjs.com/">Grunt</a>, a task-based utility built on <a href="http://nodejs.org/">nodejs</a>, and a tool I essentially use everyday in my work and personal projects. It was only natural that over the past couple years (or rather half-year) that I kept an eye out for any Grunt tasks that would generate markup from markdown; that&#39;s when <a href="https://github.com/testdouble/grunt-markdown-blog">grunt-markdown-blog</a> which utilizes the <a href="https://github.com/chjj/marked">marked</a> node module, along with <a href="https://github.com/jashkenas/underscore/">underscore</a> templating, entered my life.</p>
<h2 id="the-implementation">The implementation</h2>
<p>Though I had settled on a solution to turn markdown into markup, I had sort of started working backwards - there were more pertinent issues I had to address in order to preserve the past history of my bloggin - since 2005! (spoiler: not all <em>good</em> content).</p>
<h3 id="conversion-of-wp-posts-to-markdown">Conversion of WP posts to markdown</h3>
<p>The first thing I had to accomplish was turning all my old posts stored in a database into static content. To do just that, I found the wonderful <a href="https://github.com/mossiso/WP-Static">wpstatic</a> script. Dropping that script on my server in the same location as the <em>wp-config.php</em> file of my WordPress install - along with turning on 1000 posts per page in my WP admin console - allowed me to spit out the whole full history of posts since I started blogging by simply issuing the following:</p>
<pre><code>./wpstatic
</code></pre><p>With a full history of posts held in a single HTML file, I then used <a href="http://phantomjs.org/download.html">PhantomJS</a> to consume that file and spit out each post into a directory structure that was relative to the naming convention used for posting in WordPress.</p>
<p>I then used <a href="https://github.com/aaronsw/html2text">html2text</a> - a python module - to convert each post markup into markdown.</p>
<h3 id="conversion-of-markdown-back-to-markup">Conversion of markdown back to markup</h3>
<p>I know, I know. It seems really odd that in my first two steps I had generated valid markup and then went ahead and converted that to markdown only wanting to convert it back to markup... there is a good reason :) I wanted the markup to be consistent across previous posts and any new posts I would be writing in markdown. Using <a href="https://github.com/aaronsw/html2text">html2text</a> allowed me to conform previous HTML documents to the structure of markdown I would be using going forward.</p>
<p>With the static markdown content produced, all it takes now is running the <a href="https://github.com/testdouble/grunt-markdown-blog">grunt-markdown-blog</a> task on those files to generate static HTML documents.</p>
<p>And with that, all my previous work is preserved and available as it once was.</p>
<h2 id="the-downside">The downside</h2>
<p>The biggest benefit a database provides is being able to reference information categorically. Data stored with reference to other data stored allows for ease in generating new views and relationships. Admittedly, this is the big downside of moving my blog to static content - I do love analyzing and presenting data in new ways (its part of my job!). But, as mentioned previously, the weight of maintenance involved in the engine and tooling farly outweighed the need to move to static content than the need to access blog post data.</p>
<p>Another downside is the loss of comment association to post - and specifically the &quot;google-ability&quot; of providing a post of mine as a result of a comment being relevant to a search query. Even further, all previous comments are lost :( For that, I feel truly sorry to those of you out there who have added to the discussion on previous posts; I apologize for throwing them out with the bath water. If the previous comments corrected some information with the post or provided valuable insight, I did make it a habit of ammending the post and those should still be part of the static replacement. If you see something that is out of place or would like to be added, please get in touch.</p>
<h2 id="the-brightside">The brightside</h2>
<p>I am free of WordPress :)</p>
<p>I do want to state that WordPress is not bad or evil - far from it. It had just become a burden for me; I much prefer just writing thoughts out in markdown and then issuing a command to generate and deploy new, static content.</p>
<p>If you are interested in all the details, you can checkout the Github repo I have set up to store my tools and blog content:<br><a href="https://github.com/bustardcelly/blog-to-markdown"><a href="https://github.com/bustardcelly/blog-to-markdown">https://github.com/bustardcelly/blog-to-markdown</a></a></p>
]]></description><link>http://custardbelly.com/blog/blog-posts/2014/01/03/so-long-wordpress/index.html</link><guid isPermaLink="true">http://custardbelly.com/blog/blog-posts/2014/01/03/so-long-wordpress/index.html</guid><dc:creator><![CDATA[Todd Anderson]]></dc:creator><pubDate>Invalid Date</pubDate></item><item><title><![CDATA[The Making of a Test-Driven Grocery List Application in JS: Part X]]></title><description><![CDATA[<p><em>This is the tenth installment in a series of building a Test-Driven Grocery List application using <a href="http://pivotal.github.com/jasmine/">Jasmine</a> and <a href="http://requirejs.org">RequireJS</a>. To learn more about the intent and general concept of the series please visit <a href="http://custardbelly.com/blog/2012/11/26/the-making-of-a-test-driven-grocery-list-application-in-javascript-part-i/">The Making of a Test-Driven Grocery List Application in JavaScript: Part I</a></em><br>—</p>
<h2 id="introduction">Introduction</h2>
<p>When we last left, we properly modified <code>list-controller</code> to support event notification upon change to its collection as well as created a <code>storage-service</code> communication layer with <code>localStorage</code>. That gave us some great passing tests, but nothing to show off as the service was not integrated into the <strong>Grocery List</strong> application. In this article, we’ll do just that, but…</p>
<h2 id="before-we-hook-up-list-controller-events-to-storage-service-operations-">Before we hook up list-controller events to storage-service operations…</h2>
<p>We need a way to supply the <code>list-controller</code> with the stored items. The <code>list-controller</code> has a <code>createNewItem()</code> method, but no methods to provide a previously created item. Since we are not burdening the <code>list-controller</code> in communicating with the <code>storage-service</code> directly, we’ll need to open up the API to allow items to be added – at least at the onset.</p>
<h3 id="tests">Tests</h3>
<p>First we’ll include all our tests in our <em>specrunner</em> again as changes to <code>list-controller</code> may impact tests across multiple specs. And while we are poking around, let’s add a spec suite for <code>setItems()</code> on the <code>list-controller</code> and watch it fail:</p>
<p><em>/test/jasmine/spec/list-controller.spec.js</em></p>
<pre><code><span class="hljs-function">describe(<span class="hljs-string">'setItems()'</span>, <span class="hljs-function">function()</span> {



  var itemOne = modelFactory.<span class="hljs-function">create()</span>,

      itemTwo = modelFactory.<span class="hljs-function">create()</span>;



  <span class="hljs-function">beforeEach( <span class="hljs-function">function()</span> {

    itemOne.name = <span class="hljs-string">'apples'</span>;

    itemTwo.name = <span class="hljs-string">'oranges'</span>;

    listController.<span class="hljs-function">setItems([itemOne, itemTwo])</span>;

  })</span>;



  <span class="hljs-function">afterEach( <span class="hljs-function">function()</span> {

    listController.<span class="hljs-function">getItemList()</span>.<span class="hljs-function">removeAll()</span>;

  })</span>;



  <span class="hljs-function">it(<span class="hljs-string">'should fill list with provided items'</span>, <span class="hljs-function">function()</span> {

    var items = listController.<span class="hljs-function">getItemList()</span>;

    <span class="hljs-function">expect(items.<span class="hljs-function">itemLength()</span>)</span>.<span class="hljs-function">toEqual(<span class="hljs-number">2</span>)</span>;

    <span class="hljs-function">expect(items.<span class="hljs-function">getItemAt(<span class="hljs-number">0</span>)</span>)</span>.<span class="hljs-function">toBe(itemOne)</span>;

    <span class="hljs-function">expect(items.<span class="hljs-function">getItemAt(<span class="hljs-number">1</span>)</span>)</span>.<span class="hljs-function">toBe(itemTwo)</span>;

  })</span>;



})</span>;
</code></pre><p>This simple first spec tells us that an array of items can be provided to the <code>list-controller</code> using <code>setItems()</code> and should be accessible by its collection. And we fail with no surprises:<br><img src="http://custardbelly.com/blog/images/tdd_js/part_ix_17.png" alt="Failing on setItems of list-controller"></p>
<h3 id="list-controller-modification">list-controller modification</h3>
<p>Throughout this series I have employed a quasi-<a href="http://coderetreat.org/facilitating/activities/tdd-as-if-you-meant-it"><em>“TDD as if you mean it”</em></a> approach when creating new components and modifying the API on existing ones. With this modification to the <code>list-controller</code>, I am going to stick to getting the tests to pass by modifying the <code>list-controller</code> directly as I feel it is going to get a little more involved and will require some refactoring that would be better suited by focusing on true implementation.</p>
<p>With that said, let’s modify <code>list-controller</code> to get that new spec passing:</p>
<p><em>/script/controller/list-controller.js</em></p>
<pre><code>listController = {

  $view: <span class="hljs-literal">undefined</span>,

  getItemList: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

    <span class="hljs-keyword">return</span> collection;

  },

  getRendererFromItem: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(item)</span> {</span>

    <span class="hljs-keyword">var</span> i = rendererList.itemLength(),

        renderer;

    <span class="hljs-keyword">while</span>( --i &gt; -<span class="hljs-number">1</span> ) {

      renderer = rendererList.getItemAt(i);

      <span class="hljs-keyword">if</span>(renderer.model === item) {

        <span class="hljs-keyword">return</span> renderer;

      }

    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;

  },

  createNewItem: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

    <span class="hljs-keyword">var</span> model = modelFactory.create();

    collection.addItem(model);

    <span class="hljs-keyword">return</span> model;

  },

  removeItem: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(item)</span> {</span>

    <span class="hljs-keyword">return</span> collection.removeItem(item);

  },

  setView: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(view)</span> {</span>

    <span class="hljs-keyword">this</span>.$view = (view <span class="hljs-keyword">instanceof</span> $) ? view : $(view);

  },

  setItems: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(items)</span> {</span>

    collection = collectionFactory.create(items);

  }

};
</code></pre><p>Well, that was easy enough!<br><img src="http://custardbelly.com/blog/images/tdd_js/part_ix_18.png" alt="Passing on setItems() of list-controller"></p>
<h3 id="tests">Tests</h3>
<p>Not so fast… I think our single spec may be deceiving our expectations. Let’s add a few more and make sure we are on the right path. To start, we expect changes to these new models to propagate events when it is modified – such as in the work we have done previously.</p>
<p><em>/test/jasmine/spec/list-controller.spec.js</em></p>
<pre><code>async.it(<span class="hljs-string">'should dispatch events of property-change from provided items'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(done)</span> {</span>

  <span class="hljs-keyword">var</span> items = listController.getItemList(),

      itemOne = items.getItemAt(<span class="hljs-number">0</span>);

  $(listController).on(<span class="hljs-string">'save-item'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(event)</span> {</span>

    $(listController).off(<span class="hljs-string">'save-item'</span>);

    expect(event.item).toBe(itemOne);

    done();

  });

  itemOne.marked = <span class="hljs-literal">true</span>;

});
</code></pre><p>This spec tells us that changes to an item should be notified through the <code>list-controller</code> – basically the work we had done previously in getting the <code>list-controller</code> to dispatch events related to its underlying collection so as to be captured by observing parties.<br><img src="http://custardbelly.com/blog/images/tdd_js/part_ix_19.png" alt="Failing on async timeout of event from item"></p>
<p>This test actually reveals some refactoring that is required within the <code>list-controller</code>. In essence, creating a new collection from the provided items in <code>setItems()</code> is not enough to have the application work as expected – each individual item needs to be managed by a <code>list-item-controller</code> which responds and notifies of changes accordingly. We had previously paired an item with a item controller within the <code>collection-change</code> event handler of the collection in <code>list-controller</code>:</p>
<p><em>/script/controller/list-controller.js</em></p>
<pre><code><span class="hljs-list">(<span class="hljs-title">function</span> assignCollectionHandlers<span class="hljs-list">($collection)</span> {



  var EventKindEnum = collectionFactory.collectionEventKind,

      isValidValue = function<span class="hljs-list">(<span class="hljs-title">value</span>)</span> {

        return value <span class="hljs-keyword">&amp;&amp;</span> <span class="hljs-list">(<span class="hljs-title">value</span>.hasOwnProperty<span class="hljs-list">('length')</span> <span class="hljs-keyword">&amp;&amp;</span> value.length &gt; <span class="hljs-number">0</span>)</span><span class="hljs-comment">;</span>

      }<span class="hljs-comment">;</span>



  $collection.on<span class="hljs-list">('collection-change', function<span class="hljs-list">(<span class="hljs-title">event</span>)</span> {

    var model,

        itemController,

        $itemController,

        $itemView<span class="hljs-comment">;</span>

    switch<span class="hljs-list">( event.kind )</span> {

      case EventKindEnum.ADD:

        $itemView = $<span class="hljs-list">('&lt;li&gt;')</span><span class="hljs-comment">;</span>

        model = event.items.shift<span class="hljs-list">()</span><span class="hljs-comment">;</span>

        itemController = itemControllerFactory.create<span class="hljs-list">($itemView, model)</span><span class="hljs-comment">;</span>

        $itemController = $<span class="hljs-list">(<span class="hljs-title">itemController</span>)</span><span class="hljs-comment">;</span>



        $itemView.appendTo<span class="hljs-list">(<span class="hljs-title">listController</span>.$view)</span><span class="hljs-comment">;</span>

        rendererList.addItem<span class="hljs-list">(<span class="hljs-title">itemController</span>)</span><span class="hljs-comment">;</span>

        $<span class="hljs-list">(<span class="hljs-title">listController</span>)</span>.trigger<span class="hljs-list">(<span class="hljs-title">createSaveEvent</span><span class="hljs-list">(<span class="hljs-title">model</span>)</span>)</span><span class="hljs-comment">;</span>

        itemController.state = itemControllerFactory.state.EDITABLE<span class="hljs-comment">;</span>



        $itemController.on<span class="hljs-list">('remove', function<span class="hljs-list">(<span class="hljs-title">event</span>)</span> {

          listController.removeItem<span class="hljs-list">(<span class="hljs-title">model</span>)</span><span class="hljs-comment">;</span>

        })</span><span class="hljs-comment">;</span>

        $itemController.on<span class="hljs-list">('commit', function<span class="hljs-list">(<span class="hljs-title">event</span>)</span> {

          if<span class="hljs-list">(!isValidValue<span class="hljs-list">(<span class="hljs-title">model</span>.name)</span>)</span> {

            listController.removeItem<span class="hljs-list">(<span class="hljs-title">model</span>)</span><span class="hljs-comment">;</span>

          }

          else {

            $<span class="hljs-list">(<span class="hljs-title">listController</span>)</span>.trigger<span class="hljs-list">(<span class="hljs-title">createSaveEvent</span><span class="hljs-list">(<span class="hljs-title">model</span>)</span>)</span><span class="hljs-comment">;</span>

          }

        })</span><span class="hljs-comment">;</span>

        break<span class="hljs-comment">;</span>

      case EventKindEnum.REMOVE:

        model = event.items.shift<span class="hljs-list">()</span><span class="hljs-comment">;</span>

        itemController = listController.getRendererFromItem<span class="hljs-list">(<span class="hljs-title">model</span>)</span>,

        $itemController = $<span class="hljs-list">(<span class="hljs-title">itemController</span>)</span><span class="hljs-comment">;</span>



        if<span class="hljs-list">(<span class="hljs-title">itemController</span>)</span> {

          $itemView = itemController.parentView<span class="hljs-comment">;</span>

          $itemView.remove<span class="hljs-list">()</span><span class="hljs-comment">;</span>

          itemController.dispose<span class="hljs-list">()</span><span class="hljs-comment">;</span>

          $itemController.off<span class="hljs-list">('remove')</span><span class="hljs-comment">;</span>

          $itemController.off<span class="hljs-list">('commit')</span><span class="hljs-comment">;</span>

          rendererList.removeItem<span class="hljs-list">(<span class="hljs-title">itemController</span>)</span><span class="hljs-comment">;</span>

          $<span class="hljs-list">(<span class="hljs-title">listController</span>)</span>.trigger<span class="hljs-list">(<span class="hljs-title">createRemoveEvent</span><span class="hljs-list">(<span class="hljs-title">model</span>)</span>)</span><span class="hljs-comment">;</span>

        }

        break<span class="hljs-comment">;</span>

      case EventKindEnum.RESET:

        break<span class="hljs-comment">;</span>

    }

  })</span><span class="hljs-comment">;</span>



}<span class="hljs-list">($<span class="hljs-list">(<span class="hljs-title">collection</span>)</span>)</span>)</span><span class="hljs-comment">;</span>
</code></pre><p>That <a href="http://benalman.com/news/2010/11/immediately-invoked-function-expression/">IIFE</a> was run in the module prior to returning the <code>list-controller</code> instance. Now, we could just copy that code from the <code>EventKindEnum.ADD</code> case and shove it into <code>setItems()</code>, applying it to each item in a loop, but that wouldn’t be very efficient, not to mention a cry-inducing solution for anyone (including yourself) which need to revisit your code.</p>
<h3 id="list-controller-refactor">list-controller refactor</h3>
<p>I think we are going to have to get rid of this <strong>IIFE</strong>, but let’s do that modification in piecemeal; first, let’s strip out the item management when added to a collection:</p>
<p><em>/script/controller/list-controller.js</em></p>
<pre><code><span class="hljs-keyword">var</span> collection = collectionFactory.create(),

    rendererList = collectionFactory.create(),

    manageItemInList = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(item, listController)</span> {</span>

      <span class="hljs-keyword">var</span> <span class="hljs-variable">$itemView</span> = $(<span class="hljs-string">'&lt;li&gt;'</span>),

          itemController = itemControllerFactory.create(<span class="hljs-variable">$itemView</span>, item),

          <span class="hljs-variable">$itemController</span> = $(itemController),

          isValidValue = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(value)</span> {</span>

            <span class="hljs-keyword">return</span> value &amp;&amp; (value.hasOwnProperty(<span class="hljs-string">'length'</span>) &amp;&amp; value.length &gt; <span class="hljs-number">0</span>);

          };



      <span class="hljs-variable">$itemView</span>.appendTo(listController.<span class="hljs-variable">$view</span>);

      rendererList.addItem(itemController);



      <span class="hljs-variable">$itemController</span>.on(<span class="hljs-string">'remove'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(event)</span> {</span>

        listController.removeItem(item);

      });

      <span class="hljs-variable">$itemController</span>.on(<span class="hljs-string">'commit'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(event)</span> {</span>

        <span class="hljs-keyword">if</span>(!isValidValue(item.name)) {

          listController.removeItem(item);

        }

        <span class="hljs-keyword">else</span> {

          $(listController).trigger(createSaveEvent(item));

        }

      });

      <span class="hljs-keyword">return</span> itemController;

    },

    listController = {

      <span class="hljs-variable">$view</span>: undefined,

      ...

    };
</code></pre><p>Most of what was held in the <code>EventKindEnum.ADD</code> case of the <code>collection-change</code> handler has been moved to its own function expression – <code>manageItemInList()</code>. If we look at how this case is modified we see that we have left state initialization and event dispatching:</p>
<p><em>/script/controller/list-controller.js</em></p>
<pre><code>case EventKindEnum<span class="hljs-preprocessor">.ADD</span>:

  model = event<span class="hljs-preprocessor">.items</span><span class="hljs-preprocessor">.shift</span>()<span class="hljs-comment">;</span>

  itemController = manageItemInList(model, listController)<span class="hljs-comment">;</span>

  itemController<span class="hljs-preprocessor">.state</span> = itemControllerFactory<span class="hljs-preprocessor">.state</span><span class="hljs-preprocessor">.EDITABLE</span><span class="hljs-comment">;</span>

  $(listController)<span class="hljs-preprocessor">.trigger</span>(createSaveEvent(model))<span class="hljs-comment">;</span>

  <span class="hljs-keyword">break</span><span class="hljs-comment">;</span>
</code></pre><p>When an item is added to the collection and the list-controller is notified, it creates a new <code>list-item-controller</code> using <code>manageItemInList()</code>, sets the controller’s state to <code>EDITABLE</code> and notifies of its addition. The last two operations are of note, as they only pertain to <em>new</em> additions to the collection – we don’t want such things for existing items being added to the list from <code>setItems()</code>.</p>
<p><em>/script/controller/list-controller.js</em></p>
<pre><code><span class="hljs-attribute">setItems</span>: <span class="hljs-string">function(items) {</span>

<span class="matlab">  var <span class="hljs-built_in">i</span>, <span class="hljs-built_in">length</span> = <span class="hljs-transposed_variable">items.</span><span class="hljs-built_in">length</span>;

  collection = <span class="hljs-transposed_variable">collectionFactory.</span>create();

  <span class="hljs-keyword">for</span>( <span class="hljs-built_in">i</span> = <span class="hljs-number">0</span>; <span class="hljs-built_in">i</span> &lt; <span class="hljs-built_in">length</span>; <span class="hljs-built_in">i</span>++ ) <span class="hljs-cell">{

    manageItemInList(items[i], this);

    collection.addItem(items[i]);

  }</span>

}</span>
</code></pre><p>Now if we run the tests again:<br><img src="http://custardbelly.com/blog/images/tdd_js/part_ix_20.png" alt="Passing on modifications to item management in list-controller"></p>
<p>Passing! </p>
<h3 id="tests">Tests</h3>
<p>I don’t think we are out of the woods yet, however… Let’s continue to add more expectations about setting the collection through <code>setItems()</code>on <code>list-controller</code>:</p>
<p><em>/test/jasmine/spec/list-controller.spec.js</em></p>
<pre><code>async.it(<span class="hljs-string">'should dispatch event of remove-item from collection'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(done)</span> {</span>

  $(listController).on(<span class="hljs-string">'remove-item'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(event)</span> {</span>

    $(listController).off(<span class="hljs-string">'remove-item'</span>);

    expect(event.item).toBe(itemOne);

    done();

  });

  listController.removeItem(itemOne);

});
</code></pre><p>This test ensures that the <code>list-controller</code> should still be responding to and notifying of changes to the new collection created through <code>setItems()</code> just as it should if the <code>list-controller</code> was only being instructed to modify the collection through calls to <code>createNewItem()</code>.</p>
<h3 id="list-controller-refactoring">list-controller refactoring</h3>
<p>To save you some time in downloading more images, believe me when I tell you I just put us back in red <img src="http://custardbelly.com/blog/wp-includes/images/smilies/icon_smile.gif" alt=":)"> The reason being that dang <code>assignCollectionHandlers</code> <a href="http://benalman.com/news/2010/11/immediately-invoked-function-expression/">IIFE</a>. The collection that is created in <code>setItems()</code> is not being observed. The <strong>IIFE</strong> to assign events handlers is only run upon load of the module and only targets the collection instantiated in its declaration. In other words, any new collections will not be observed.</p>
<p>I say we move that <strong>IIFE</strong> out into its own expression:</p>
<p><em>/script/controller/list-controller.js</em></p>
<pre><code><span class="hljs-keyword">var</span> collection = collectionFactory.create(),

    rendererList = collectionFactory.create(),

    assignCollectionHandlers = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(<span class="hljs-variable">$collection</span>)</span> {</span>

      <span class="hljs-keyword">var</span> EventKindEnum = collectionFactory.collectionEventKind;

      <span class="hljs-variable">$collection</span>.on(<span class="hljs-string">'collection-change'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(event)</span> {</span>

        <span class="hljs-keyword">var</span> model,

            itemController,

            <span class="hljs-variable">$itemController</span>,

            <span class="hljs-variable">$itemView</span>;

        <span class="hljs-keyword">switch</span>( event.kind ) {

          <span class="hljs-keyword">case</span> EventKindEnum.ADD:

            model = event.items.shift();

            itemController = manageItemInList(model, listController);

            itemController.state = itemControllerFactory.state.EDITABLE;

            $(listController).trigger(createSaveEvent(model));

            <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">case</span> EventKindEnum.REMOVE:

            model = event.items.shift();

            itemController = listController.getRendererFromItem(model),

            <span class="hljs-variable">$itemController</span> = $(itemController);



            <span class="hljs-keyword">if</span>(itemController) {

              <span class="hljs-variable">$itemView</span> = itemController.parentView;

              <span class="hljs-variable">$itemView</span>.remove();

              itemController.dispose();

              <span class="hljs-variable">$itemController</span>.off(<span class="hljs-string">'remove'</span>);

              <span class="hljs-variable">$itemController</span>.off(<span class="hljs-string">'commit'</span>);

              rendererList.removeItem(itemController);

              $(listController).trigger(createRemoveEvent(model));

            }

            <span class="hljs-keyword">break</span>;

          <span class="hljs-keyword">case</span> EventKindEnum.RESET:

            <span class="hljs-keyword">break</span>;

        }

      });

    },

    manageItemInList = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(item, listController)</span> {</span>

      <span class="hljs-comment">// implementation removed to reduce noise</span>

    },

    listController = {

      <span class="hljs-comment">// implementation removed to reduce noise</span>

    }
</code></pre><p>We basically took what was the named <code>assignCollectionHandlers</code> <strong>IIFE</strong> and added it to the variable declarations within the <code>list-controller</code> module. That changes the code between those declarations and the return of the <code>listController</code> instance to:</p>
<p><em>/script/controller/list-controller.js</em></p>
<pre><code><span class="hljs-keyword">var</span> collection = collectionFactory.create(),

    rendererList = collectionFactory.create(),

    assignCollectionHandlers = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">($collection)</span> {</span>

      <span class="hljs-comment">// implementation removed to reduce noise</span>

    },

    manageItemInList = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(item, listController)</span> {</span>

      <span class="hljs-comment">// implementation removed to reduce noise</span>

    },

    listController = {

      <span class="hljs-comment">// implementation removed to reduce noise</span>

    };



assignCollectionHandlers($(collection));



<span class="hljs-keyword">return</span> listController;
</code></pre><p>With those changes we are still failing on the last spec we created, but more importantly we have not caused any other tests to fail!<br><img src="http://custardbelly.com/blog/images/tdd_js/part_ix_21.png" alt="Still failing, but failing well!"></p>
<p>Let’s get that last spec to pass:</p>
<p><em>/script/controller/list-controller.js</em></p>
<pre><code><span class="hljs-attribute">setItems</span>: <span class="hljs-string">function(items) {</span>

<span class="matlab">  var <span class="hljs-built_in">i</span>, <span class="hljs-built_in">length</span> = <span class="hljs-transposed_variable">items.</span><span class="hljs-built_in">length</span>;

  collection = <span class="hljs-transposed_variable">collectionFactory.</span>create();

  <span class="hljs-keyword">for</span>( <span class="hljs-built_in">i</span> = <span class="hljs-number">0</span>; <span class="hljs-built_in">i</span> &lt; <span class="hljs-built_in">length</span>; <span class="hljs-built_in">i</span>++ ) <span class="hljs-cell">{

    manageItemInList(items[i], this);

    collection.addItem(items[i]);

  }</span>

  assignCollectionHandlers($(collection));

}</span>
</code></pre><p>Hurrah!<br><img src="http://custardbelly.com/blog/images/tdd_js/part_ix_22.png" alt="Passing again!"></p>
<p>Tagged <strong>0.1.13</strong>: <a href="https://github.com/bustardcelly/grocery-ls/tree/0.1.13"><a href="https://github.com/bustardcelly/grocery-ls/tree/0.1.13">https://github.com/bustardcelly/grocery-ls/tree/0.1.13</a></a></p>
<h2 id="hooking-it-all-together">Hooking it all together</h2>
<p>We have created our <code>storage-service</code> to communicate with <code>localStorage</code>, modified <code>list-controller</code> to dispatch events and accept initial items for its collection and all our tests are still passing! It’s a wonderous feeling. Now let’s get to actually hooking them up so that the <code>storage-service</code> is told how to handle changes to the list by responding to <code>list-controller</code> events.</p>
<p>Normally, in such situations I would create another component to the application that would serve as an mediator for such integration, receiving events from <code>list-controller</code> and invoking the <code>storage-service</code>. Naturally, that would also call for more tests in assuring that the mediator did its job correctly. I am not going to do that here. This is a small application meant for our own personal use and this series has gotten quite long; I don’t want to scare you away by adding more dependencies, but I would encourage you to do so on your own if you feel so…. just don’t forget the tests!</p>
<p>I think modifying the main JavaScript file (<em>/script/grocery-ls.js</em>) that defines the module dependencies and initializes the <strong>Grocery List</strong> application is fine enough for the task at hand:</p>
<p><em>/script/grocery-ls.js</em></p>
<pre><code><span class="hljs-list">(<span class="hljs-title">function</span><span class="hljs-list">(<span class="hljs-title">window</span>, require)</span> <span class="hljs-collection">{



  require.config<span class="hljs-list">(<span class="hljs-collection">{

    baseUrl: <span class="hljs-string">"."</span>,

    paths: <span class="hljs-collection">{

      <span class="hljs-string">"lib"</span>: <span class="hljs-string">"./lib"</span>,

      <span class="hljs-string">"script"</span>: <span class="hljs-string">"./script"</span>,

      <span class="hljs-string">"jquery"</span>: <span class="hljs-string">"./lib/jquery-1.8.3.min"</span>

    }</span>

  }</span>)</span><span class="hljs-comment">;</span>



  require<span class="hljs-list">( <span class="hljs-collection">['jquery', 'script/controller/list-controller', 'script/service/storage-service']</span>,

            function<span class="hljs-list">(<span class="hljs-title">$</span>, listController, storageService)</span> <span class="hljs-collection">{



    var $listController = $<span class="hljs-list">(<span class="hljs-title">listController</span>)</span><span class="hljs-comment">;</span>

    listController.setView<span class="hljs-list">(<span class="hljs-title">$</span><span class="hljs-list">(<span class="hljs-title">'section.groceries</span> ul')</span>)</span><span class="hljs-comment">;</span>



    storageService.getItems<span class="hljs-list">()</span>.then<span class="hljs-list">(<span class="hljs-title">function</span><span class="hljs-list">(<span class="hljs-title">items</span>)</span> <span class="hljs-collection">{

      listController.setItems<span class="hljs-list">(<span class="hljs-title">items</span>)</span><span class="hljs-comment">;</span>

    }</span>)</span><span class="hljs-comment">;</span>

    $listController.on<span class="hljs-list">(<span class="hljs-title">'save-item'</span>, function<span class="hljs-list">(<span class="hljs-title">event</span>)</span> <span class="hljs-collection">{

      storageService.saveItem<span class="hljs-list">(<span class="hljs-title">event.item</span>)</span>.then<span class="hljs-list">(<span class="hljs-title">function</span><span class="hljs-list">(<span class="hljs-title">item</span>)</span> <span class="hljs-collection">{

        console.log<span class="hljs-list">(<span class="hljs-title">'Item</span> saved! ' + item.name)</span><span class="hljs-comment">;</span>

      }</span>, function<span class="hljs-list">(<span class="hljs-title">error</span>)</span> <span class="hljs-collection">{

        console.log<span class="hljs-list">(<span class="hljs-title">'Item</span> not saved: ' + error)</span>

      }</span>)</span><span class="hljs-comment">;</span>

    }</span>)</span><span class="hljs-comment">;</span>

    $listController.on<span class="hljs-list">(<span class="hljs-title">'remove-item'</span>, function<span class="hljs-list">(<span class="hljs-title">event</span>)</span> <span class="hljs-collection">{

      storageService.removeItem<span class="hljs-list">(<span class="hljs-title">event.item</span>)</span>.then<span class="hljs-list">(<span class="hljs-title">function</span><span class="hljs-list">(<span class="hljs-title">item</span>)</span> <span class="hljs-collection">{

        console.log<span class="hljs-list">(<span class="hljs-title">'Item</span> removed! ' + item.name)</span><span class="hljs-comment">;</span>

      }</span>, function<span class="hljs-list">(<span class="hljs-title">error</span>)</span> <span class="hljs-collection">{

        console.log<span class="hljs-list">(<span class="hljs-title">'Item</span> not removed: ' + error)</span><span class="hljs-comment">;</span>

      }</span>)</span><span class="hljs-comment">;</span>

    }</span>)</span><span class="hljs-comment">;</span>

    $<span class="hljs-list">(<span class="hljs-title">'#add-item-button'</span>)</span>.on<span class="hljs-list">(<span class="hljs-title">'click'</span>, function<span class="hljs-list">(<span class="hljs-title">event</span>)</span> <span class="hljs-collection">{

      listController.createNewItem<span class="hljs-list">()</span><span class="hljs-comment">;</span>

    }</span>)</span><span class="hljs-comment">;</span>



  }</span>)</span><span class="hljs-comment">;</span>



}</span><span class="hljs-list">(<span class="hljs-title">window</span>, requirejs)</span>)</span><span class="hljs-comment">;</span>
</code></pre><p>Just a slight modification to the main file. We added <code>storage-service</code> as an initial dependency, request and supply stored items to the list-controller and respond to <code>save-item</code> and <code>remove-item</code> events, forwarding actions along to the <code>storage-service</code> appropriately.</p>
<p>If we run the application now, we can add, mark-off, remove items from the list. Same as before, but now, if we refresh the page, items and their state a persisted!</p>
<p><img src="http://custardbelly.com/blog/images/tdd_js/part_ix_27.png" alt="Grocery list application"></p>
<p>It may look a little different than your if you have been following along in the code. I added some nice styling and committed it to the repo.</p>
<p>Tagged <strong>0.2.0</strong> : <a href="https://github.com/bustardcelly/grocery-ls/tree/0.2.0"><a href="https://github.com/bustardcelly/grocery-ls/tree/0.2.0">https://github.com/bustardcelly/grocery-ls/tree/0.2.0</a></a></p>
<h2 id="conclusion">Conclusion</h2>
<p>We have completed our <strong>Grocery List</strong> application and have it fully tested (well, hopefully <img src="http://custardbelly.com/blog/wp-includes/images/smilies/icon_smile.gif" alt=":)"> ). We now have a grocery list that we can curate and is persisted in the browser. It should be noted that it is not persistent across browser<strong>s</strong>, plural – so make sure to open it in the same browser on your mobile device when creating the list and shopping. I am most likely going to whip up a little server to persist the list remotely, but am not going to document that in this series. It may end up in the <a href="https://github.com/bustardcelly/grocery-ls">github repo</a> eventually, however, so keep an eye out.</p>
<p>Thanks for sticking around in this long series (<em>ten parts!</em>) of building an application by trying to adhere to <strong>TDD</strong>. I may have gone off course here and there, but I hope it was informative in any way.</p>
<p>Cheers!</p>
<p>—-</p>
<h1 id="link-dump">Link Dump</h1>
<h2 id="reference">Reference</h2>
<p><a href="http://tddjs.com/">Test-Driven JavaScript Development by Christian Johansen</a><br><a href="http://dannorth.net/introducing-bdd/">Introducing BDD by Dan North</a><br><a href="http://cumulative-hypotheses.org/2011/08/30/tdd-as-if-you-meant-it/">TDD as if you Meant it by Keith Braithwaite</a><br><a href="http://requirejs.org/">RequireJS</a><br><a href="https://github.com/amdjs/amdjs-api/wiki/AMD">AMD</a><br><a href="http://pivotal.github.com/jasmine/">Jasmine</a><br><a href="http://sinonjs.org/">Sinon</a><br><a href="https://github.com/derickbailey/jasmine.async">Jasmine.Async</a></p>
<h2 id="post-series">Post Series</h2>
<p><a href="https://github.com/bustardcelly/grocery-ls">grocery-ls github repo</a><br><a href="http://custardbelly.com/blog/2012/11/26/the-making-of-a-test-driven-grocery-list-application-in-javascript-part-i">Part I – Introduction</a><br><a href="http://custardbelly.com/blog/2012/11/26/the-making-of-a-test-driven-grocery-list-application-in-js-part-ii">Part II – Feature: Add Item</a><br><a href="http://custardbelly.com/blog/2012/12/06/the-making-of-a-test-driven-grocery-list-application-in-js-part-iii">Part III – Feature: Mark-Off Item</a><br><a href="http://custardbelly.com/blog/2012/12/17/the-making-of-a-test-driven-grocery-list-application-in-js-part-iv">Part IV – Feature: List-Item-Controller</a><br><a href="http://custardbelly.com/blog/2012/12/31/the-making-of-a-test-driven-grocery-list-application-in-js-part-v/">Part V – Feature: List-Controller Refactoring</a><br><a href="http://custardbelly.com/blog/2013/01/08/the-making-of-a-test-driven-grocery-list-application-in-js-part-vi/">Part VI – Back to Passing</a><br><a href="http://custardbelly.com/blog/2013/01/17/the-making-of-a-test-driven-grocery-list-application-in-js-part-vii/">Part VII – Remove Item</a><br><a href="http://custardbelly.com/blog/2013/01/22/the-making-of-a-test-driven-grocery-list-application-part-viii/">Part VIII – Bug Fixing</a><br><a href="http://custardbelly.com/blog/2013/02/15/the-making-of-a-test-driven-grocery-list-application-in-js-part-ix/">Part IX – Persistence</a><br><a href="http://custardbelly.com/blog/2013/03/06/the-making-of-a-test-driven-grocery-list-application-in-js-part-x/">Part X – It Lives!</a></p>
<p>Posted in <a href="http://custardbelly.com/blog/category/amd/">AMD</a>, <a href="http://custardbelly.com/blog/category/javascript/">JavaScript</a>, <a href="http://custardbelly.com/blog/category/requirejs/">RequireJS</a>, <a href="http://custardbelly.com/blog/category/grocery-ls/">grocery-ls</a>, <a href="http://custardbelly.com/blog/category/jasmine/">jasmine</a>.</p>
]]></description><link>http://custardbelly.com/blog/blog-posts/2013/03/06/the-making-of-a-test-driven-grocery-list-application-in-js-part-x/index.html</link><guid isPermaLink="true">http://custardbelly.com/blog/blog-posts/2013/03/06/the-making-of-a-test-driven-grocery-list-application-in-js-part-x/index.html</guid><dc:creator><![CDATA[Todd Anderson]]></dc:creator><pubDate>Invalid Date</pubDate></item><item><title><![CDATA[The Making of a Test-Driven Grocery List Application in JS: Part IX]]></title><description><![CDATA[<p><em>This is the ninth installment in a series of building a Test-Driven Grocery List application using <a href="http://pivotal.github.com/jasmine/">Jasmine</a> and <a href="http://requirejs.org">RequireJS</a>. To learn more about the intent and general concept of the series please visit <a href="http://custardbelly.com/blog/2012/11/26/the-making-of-a-test-driven-grocery-list-application-in-javascript-part-i/">The Making of a Test-Driven Grocery List Application in JavaScript: Part I</a></em><br>—</p>
<h1 id="introduction">Introduction</h1>
<p>In the <a href="http://custardbelly.com/blog/2013/01/22/the-making-of-a-test-driven-grocery-list-application-part-viii/">previous article</a>, we pretty much wrapped up all the user-based functionality and ended with a working <strong>Grocery List</strong> application that we could start using. There is one little snag though… no persistance. If you made this gloriously elaborate list that detailed everything you needed at the store, then closed the browser and reopened it, the list was gone! That will not do.</p>
<p>There are many factors and paradigms to consider in choosing the level of persistence when it comes to handling session and user based applications. Without introducing a discussion about authentication, when approaching the integration persistence you have to take into account system-based vs user-based persistence, client-side vs server-side storage, and – nowadays, more commonly – the cross pollination of the two: <a href="http://en.wikipedia.org/wiki/Occasionally_connected_computing">occasional-connectivity</a>. (<em>not to mention browser support in all this</em>) We won’t be getting into all of that <img src="http://custardbelly.com/blog/wp-includes/images/smilies/icon_smile.gif" alt=":)"> We’ll be using the <code>localStorage</code> of today’s modern browser.</p>
<p>The intent of this article in the series is to implement client-side, browser-based persistence for the <strong>Grocery List</strong> application. It would be nice to store our list remotely so it can be accessed by all browsers on all devices, but I feel it would introduce too many new libraries, software and concepts to this series. I will most likely add it personally after this series is over, and I invite you to as well – keeping in mind to do it using TDD <img src="http://custardbelly.com/blog/wp-includes/images/smilies/icon_smile.gif" alt=":)"> The most I can offer at this point, is to keep the code we will write clean enough to support such future endeavours.</p>
<h1 id="what-tests-to-modify-to-get-us-there-">What Tests to Modify to Get Us There?</h1>
<p>Good question. Let’s first think about what actions will prompt an update to the list in storage. Actually, if we look at the feature specs we have created throughout this series and separated out into the <code>/feature</code> directory itself, we pretty much have all the defined actions that will trigger an update to the stored list:<br><img src="http://custardbelly.com/blog/images/tdd_js/part_ix_1.png" alt="Spec listing"></p>
<p>All of these features are a result from interacting with the <code>list-controller</code>. My first inkling is to add responsibility to the <code>list-controller</code> so that, along with the other operations it handles in list management, it communicates with a service layer to update the <strong>Grocery List</strong> in storage. However, I think that would add too much burden on the <code>list-controller</code> and, when taking into account that requirements around storage may change, the introduction of such complexity into the <code>list-controller</code> may quickly make our tests feel chaotic.</p>
<p>As such, I propose that we should start off with the expectation that the <code>list-controller</code> will notify of its underlying collection having been modified, not only upon its change in length, but of the items within the collection, as well. We can then capture those events and forward them on to whichever service implementation we have without having to pass that dependency into the <code>list-controller</code> and burdening it with such communication.</p>
<h2 id="new-expectation-for-add-item">New Expectation for Add Item</h2>
<p>To start, let’s add a quick spec to the <em>Add Item</em> feature that defines an expectation from the <code>list-controller</code> to notify when an item has been added:</p>
<p><em>/test/jasmine/spec/feature/additem.spec.js</em></p>
<pre><code>async.it(<span class="hljs-string">'should dispatch a save-item event'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(done)</span> {</span>

  <span class="hljs-keyword">var</span> newItem;



  $(listController).on(<span class="hljs-string">'save-item'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(event)</span> {</span>

    expect(event.item).not.toBeUndefined();

    $(listController).off(<span class="hljs-string">'save-item'</span>);

    done();

  });

  newItem = listController.createNewItem();

});
</code></pre><p>In creating this expectation, we have also begun to define the actual make-up of the event we intend to receive: the event type being <code>save-item</code> and the access of the <code>item</code> that was saved.</p>
<p>Run it and we are red, as expected:<br><img src="http://custardbelly.com/blog/images/tdd_js/part_ix_2.png" alt="Failing test on add item event response"></p>
<p>Taking what we have defined as our expectation when an item is added, we’ll modify the list-controller to get this passing. First we’ll add a factory method to generate <code>save-item</code> events:</p>
<p><em>/script/controller/list-controller.js</em></p>
<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createSaveEvent</span><span class="hljs-params">(item)</span> {</span>

  <span class="hljs-keyword">var</span> event = $.Event(<span class="hljs-string">'save-item'</span>);

  event.item = item;

  <span class="hljs-keyword">return</span> event;

}
</code></pre><p>Fairly straight-forward and similar to other event factory methods declared previously in this series. Since we are addressing an expectation of event notification on add of item, we know where in the list-controller we can add that dispatch – in response to the addition of an item on the collection:</p>
<p><em>/script/controller/list-controller.js</em></p>
<pre><code>$itemView<span class="hljs-preprocessor">.appendTo</span>(listController.$view)<span class="hljs-comment">;</span>

rendererList<span class="hljs-preprocessor">.addItem</span>(itemController)<span class="hljs-comment">;</span>

$(listController)<span class="hljs-preprocessor">.trigger</span>(createSaveEvent(model))<span class="hljs-comment">;</span>

itemController<span class="hljs-preprocessor">.state</span> = itemControllerFactory<span class="hljs-preprocessor">.state</span><span class="hljs-preprocessor">.EDITABLE</span><span class="hljs-comment">;</span>
</code></pre><p>Back in business.<br><img src="http://custardbelly.com/blog/images/tdd_js/part_ix_3.png" alt="Passing test on add item event response"></p>
<h2 id="new-expectation-for-remove-item">New Expectation for Remove Item</h2>
<p>Let’s quickly just do a similar modification to the <code>list-controller</code> with regards to the <em>Remove Item</em> feature. First we’ll append a spec in the <em>removeitem.spec</em> suite with an expectation of being notified on <code>remove-item</code>:</p>
<p><em>/test/jasmine/spec/feature/removeitem.spec.js</em></p>
<pre><code>async.it(<span class="hljs-string">'should dispatch a remove-item event'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(done)</span> {</span>

  <span class="hljs-keyword">var</span> removedItem;



  $(listController).on(<span class="hljs-string">'remove-item'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(event)</span> {</span>

    expect(event.item).not.toBeUndefined();

    $(listController).off(<span class="hljs-string">'remove-item'</span>);

    done();

  });

  removedItem = listController.removeItem(groceryItem);

});
</code></pre><p>Sparing you another image of the specrunner turning red, that will fail with the timeout that we saw before. We’ll fix that up by adding a trigger in the removal of an item from the collection handler in <code>list-controller</code>. First with the addition of a factory method for the <code>remove-item</code> event:</p>
<p><em>/script/controller/list-controller.js</em></p>
<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createRemoveEvent</span><span class="hljs-params">(item)</span> {</span>

  <span class="hljs-keyword">var</span> event = $.Event(<span class="hljs-string">'remove-item'</span>);

  event.item = item;

  <span class="hljs-keyword">return</span> event;

}
</code></pre><p>And then with an additional line to the <code>remove</code> response on the collection:</p>
<p><em>/script/controller/list-controller.js</em></p>
<pre><code><span class="hljs-keyword">case</span> EventKindEnum.REMOVE:

  model = <span class="hljs-keyword">event</span>.items.shift();

  itemController = listController.getRendererFromItem(model),

  <span class="hljs-variable">$itemController</span> = <span class="hljs-variable">$(</span>itemController);



  <span class="hljs-keyword">if</span>(itemController) {

    <span class="hljs-variable">$itemView</span> = itemController.parentView;

    <span class="hljs-variable">$itemView</span>.remove();

    itemController.dispose();

    <span class="hljs-variable">$itemController</span>.off(<span class="hljs-string">'remove'</span>);

    <span class="hljs-variable">$itemController</span>.off(<span class="hljs-string">'commit'</span>);

    rendererList.removeItem(itemController);

    <span class="hljs-variable">$(</span>listController).trigger(createRemoveEvent(model));

  }

<span class="hljs-keyword">break</span>;
</code></pre><p>Run the tests, and we are back to passing:<br><img src="http://custardbelly.com/blog/images/tdd_js/part_ix_4.png" alt="Passing on removal event from list-controller"></p>
<h2 id="new-expectation-for-save-item">New Expectation for Save Item</h2>
<p>Sort of repetitive, but we are on a roll… let’s go through the similar process to ensure that a notification for <code>save-item</code> is dispatched when the user has modified its name and committed it to the list – the <em>Save Item</em> feature we added in the <a href="http://custardbelly.com/blog/2013/01/22/the-making-of-a-test-driven-grocery-list-application-part-viii/">last article</a>.</p>
<p><em>/test/jasmine/spec/feature/saveitem.spec.js</em></p>
<pre><code>async.it(<span class="hljs-string">'should dispatch a save-item event'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(done)</span> {</span>



  $(listController).on(<span class="hljs-string">'save-item'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(event)</span> {</span>

    expect(event.item).toEqual(item);

    $(listController).off(<span class="hljs-string">'save-item'</span>);

    done();

  });



  item.name = itemName;

  itemRenderer.state = itemControllerFactory.state.UNEDITABLE;

});
</code></pre><p>That’ll put us in the red with the same old timeout issue. Getting back to green, we’ll trigger the <code>save-item</code> event upon committal of the item to the list, which if you remember – and is described in the test – is in response to the <code>list-item-controller</code> notifying of change to the item model:</p>
<p><em>/test/jasmine/spec/feature/list-controller.js</em></p>
<pre><code>$<span class="hljs-transposed_variable">itemController.</span>on(<span class="hljs-string">'commit'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(event)</span> {</span>

  <span class="hljs-keyword">if</span>(!isValidValue(<span class="hljs-transposed_variable">model.</span>name)) <span class="hljs-cell">{

    listController.removeItem(model);

  }</span>

  <span class="hljs-keyword">else</span> <span class="hljs-cell">{

    $(listController).trigger(createSaveEvent(model));

  }</span>

});
</code></pre><p>Back to green!<br><img src="http://custardbelly.com/blog/images/tdd_js/part_ix_5.png" alt="Passing on commital of item form list-item-controller"></p>
<p>The amount of those little dots just keeps growing. Makes you feel all warm inside. Cherish that, ’cause it will go away…</p>
<h3 id="hold-up">Hold Up</h3>
<p>Just stepping back, it may seem a little odd that we are calling <code>save-item</code> when we add and commit the item to the list; after all they are the same item, we do we need to notify on save multiple times? The reason being is that upon any modification to an item – including its existence – the store needs to be modified. We haven’t gotten into the service layer for storage yet, but it will be abstracted out that a response from save-item will be internally handled as whether to append the item (from add) or to update an item already existant (from commit). Until we get to that service layer implementation for <code>localStorage</code>, we’ll go about setting expectations of <code>save-item</code> notification on modification to an item.</p>
<p>Which actually brings up a good point… what about marking off an item? We will need to notify on change of an item being marked off, as well.</p>
<h2 id="new-expectation-for-mark-off-item">New Expectation for Mark-Off Item</h2>
<p>We tackled the <em>Mark-Off Item</em> feature a <a href="http://custardbelly.com/blog/2012/12/06/the-making-of-a-test-driven-grocery-list-application-in-js-part-iii/">while back</a> in this series. Just a quick refresher on the story:</p>
<p><em>// story</em><br>—<br><strong>Story</strong>: Item is marked off on grocery list</p>
<p><strong>In order to</strong> remember what items have already made it to the cart<br><strong>As a</strong> grocery shopper<br><strong>I want to</strong> mark an item as being attained on the grocery list.<br>—</p>
<p>We implemented the feature, and upon user press of the item while in non-edit mode, it toggles its <code>marked</code> property on the model and updates the UI to add or remove a <del>strikethrough</del> on the label.</p>
<p>We’ve got a spec suite for the <em>Mark-Off Item</em> feature already, so we’ll append an expectation for <code>save-item</code> to it just as we have done with the other feature specs in this article:</p>
<p><em>/test/jasmine/spec/feature/markitem.spec.js</em></p>
<pre><code>async.it(<span class="hljs-string">'should dispatch a save-item event'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(done)</span> {</span>



   <span class="hljs-keyword">var</span> timeout = setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

     clearTimeout(timeout);

     $(listController).off(<span class="hljs-string">'save-item'</span>);

   }, jasmine.DEFAULT_TIMEOUT_INTERNAL);



  $(listController).on(<span class="hljs-string">'save-item'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(event)</span> {</span>

    expect(event.item).toBe(item);

    $(listController).off(<span class="hljs-string">'save-item'</span>);

    done();

  });



  item.marked = <span class="hljs-literal">true</span>;

});
</code></pre><p>… and that will bring us back to failing.<br>The <code>timeout</code> placed in there is just to ensure that listener(s) to the <code>save-item</code> event are removed regardless of the async test timing out.</p>
<p>The resolution to the issue is a trickier one than those of the previous in this article, however. Currently the <code>list-item-controller</code> is the only component that actually concerned with this change in marked status. It is not concerned with notifying any other party of the change to its model. The model does, however, notify of any property changes. I see two ways in which we can get back to passing:</p>
<ol>
<li>Assign a handler for <code>property-change</code> on model when it is first created and returned from <code>listController.createNewItem()</code></li>
<li>Dispatch a <code>commit</code> event from <code>list-item-controller</code> on change to <code>marked</code> property on the underlying model</li>
</ol>
<p>While both options will most likely get us where we need to be, the former adds additional management to the <code>list-controller</code>; its already listening in on <code>commit</code> from its <code>list-item-controller</code> instance, so modifying the <code>list-item-controller</code> to notify of change to the <code>marked</code> property seems to be the path of least resistance.</p>
<p>We had previously set up the <code>commit</code> notification on response from leaving the <code>EDITABLE</code> state of the <code>list-item-controller</code>:</p>
<p><em>/script/controller/list-item-controller.js</em></p>
<pre><code>// append state-based item.

if(event<span class="hljs-preprocessor">.newState</span> === stateEnum<span class="hljs-preprocessor">.UNEDITABLE</span>) {

  controller<span class="hljs-preprocessor">.parentView</span><span class="hljs-preprocessor">.append</span>(controller.$uneditableView)<span class="hljs-comment">;</span>

  controller<span class="hljs-preprocessor">.save</span>()<span class="hljs-comment">;</span>

}
</code></pre><p>That implementation got us to passing previously in which we described the expectation of a user committing an item to the list with a valid name (un-empty string). Our issue at hand is to also invoke the <code>save()</code> method on <code>list-item-controller</code> when the <code>marked</code> property is modified. In thinking about it now, while the committal of an item is tied to the change of state, it runs a validation on the <code>name</code> property to ensure that the item can be added/kept in the collection – so, in actuality <code>commit</code> can be tied to property updates to the item model.</p>
<p>As such, let’s remove line <code>48</code> from the above snippet and insert the invocation of <code>save()</code> to the handler in <code>list-item-controller</code> for <code>property-change</code> on the model:</p>
<p><em>/script/controller/list-item-controller.js</em></p>
<pre><code>$(<span class="hljs-keyword">this</span>.model).on(<span class="hljs-string">'property-change'</span>, (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(controller)</span> {</span>

  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(event)</span> {</span>

    handlePropertyChange.call(<span class="hljs-literal">null</span>, controller, event);

    controller.save();

  };

}(<span class="hljs-keyword">this</span>)));
</code></pre><p>Run the specrunner again…<br><img src="http://custardbelly.com/blog/images/tdd_js/part_ix_5_fail.png" alt="We broke it"></p>
<p>… and we broke it <img src="http://custardbelly.com/blog/wp-includes/images/smilies/icon_sad.gif" alt=":("></p>
<p>The reason for those X’s is due to the logic we have held in <code>list-controller</code> on save of an item: it checks it’s <code>name</code> property and removes it from the list if considered an invalid value – which an empty string is.</p>
<p>I sense some modification to such logic in the future, but for now we can get the tests back to passing by providing a <code>name</code> property value to the created item in our mark-item spec:</p>
<p>/tests/jasmine/spec/feature/markitem.spec.js</p>
<pre><code>beforeEach( <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

  item = listController.createNewItem();

  item.name = <span class="hljs-string">'apples'</span>;

});
</code></pre><p><img src="http://custardbelly.com/blog/images/tdd_js/part_ix_6.png" alt="Passing on model property update"></p>
<p>We’re green!</p>
<p>Tagged <strong>0.1.13</strong>: <a href="https://github.com/bustardcelly/grocery-ls/tree/0.1.13"><a href="https://github.com/bustardcelly/grocery-ls/tree/0.1.13">https://github.com/bustardcelly/grocery-ls/tree/0.1.13</a></a></p>
<h3 id="settle-down">Settle Down</h3>
<p>We have verified our expectations of <code>save-item</code> and <code>remove-item</code> events being dispatched from <code>list-controller</code> – new and model updates issuing the former, removal issuing the later. The work we have done was to separate concerns and not burden the <code>list-controller</code> itself with service communication for persisting the <strong>Grocery List</strong> items across browser sessions, but we have yet to address the actual service layer implementation that will take all these notifications.</p>
<h2 id="storage-service">Storage Service</h2>
<p>The <code>storage-service</code> will provide a service layer for communication with storage – whether that be remote or local. It will serve as a facade to an existing storage of grocery list items persisted somewhere other than the current application session. For the purposes of this article, that persistence layer is going to be the <code>localStorage</code> of the browser.</p>
<p>While fleshing out the storage service and its API, we’ll <em>loosely</em> use the technique of <a href="http://coderetreat.org/facilitating/activities/tdd-as-if-you-meant-it">‘TDD as if you meant it’</a>. I say <em>loosely</em> in part because to fully do it and explain each step would be a lot of noise for this article; the main practice point to take away – and I hope I express – is that the component you are testing is actually being built while you make the expectations for it pass.</p>
<h3 id="tests">Tests</h3>
<p>To start, we’ll create a bare-bones module for our service layer:</p>
<p><em>/script/service/storage-service</em></p>
<pre><code>define([<span class="hljs-string">'jquery'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">($)</span> {</span>



  <span class="hljs-keyword">var</span> store = {};

  <span class="hljs-keyword">return</span> store;



});
</code></pre><p>And let’s create the beginnings of our test:</p>
<p><em>/test/jasmine/spec/storage-service.spec.js</em></p>
<pre><code>define([<span class="hljs-string">'jquery'</span>, <span class="hljs-string">'script/service/storage-service'</span>, <span class="hljs-string">'script/model/grocery-ls-item'</span>],

        <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">($, store, modelFactory)</span> {</span>



  describe(<span class="hljs-string">'Grocery List storage-service'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>



    describe(<span class="hljs-string">'getItems()'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>



      it(<span class="hljs-string">'should return of type array'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

        expect(<span class="hljs-literal">false</span>).toEqual(<span class="hljs-literal">true</span>);

      });



      it(<span class="hljs-string">'should return array of grocery-ls-item types'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

        expect(<span class="hljs-literal">false</span>).toEqual(<span class="hljs-literal">true</span>);

      });



    });



  });



});
</code></pre><p>In the test we have set up some tests for the <code>getItems()</code> method for the service. Prior to any implementation, it should be known that communication with the <code>storage-service</code> will be considered asynchronous – meaning all operations will return a <a href="http://api.jquery.com/category/deferred-object/">jQuery Deferred</a>. This will abstract out the storage proxy that will be employed by the <code>storage-service</code> and will respond in an asynchronous manner regardless of whether the store is immediately accessible – as in the case of <code>localStorage</code> – or remote.</p>
<p>Truthfully, in practice, I should only do one tests at a time, but we are testing the expectations for access of the same item listing; to save you from reading the ramblings of adding another test, I declared them both at the start.</p>
<p>Let’s stub out the API and start testing and building the <code>storage-service</code>:</p>
<p><em>/test/jasmine/spec/storage-service.spec.js</em></p>
<pre><code><span class="hljs-function">describe(<span class="hljs-string">'getItems()'</span>, <span class="hljs-function">function()</span> {



  var items,

      itemOne = modelFactory.<span class="hljs-function">create()</span>,

      itemTwo = modelFactory.<span class="hljs-function">create()</span>,

      async = new <span class="hljs-function">AsyncSpec(this)</span>;



  async.<span class="hljs-function">beforeEach( <span class="hljs-function">function(done)</span> {

    var deferred = $.<span class="hljs-function">Deferred()</span>,

        getStub = sinon.<span class="hljs-function">stub()</span>.<span class="hljs-function">returns(deferred)</span>;



    deferred.<span class="hljs-function">resolve([itemOne, itemTwo])</span>;

    store.getItems = getStub;



    store.<span class="hljs-function">getItems()</span>.<span class="hljs-function">then(<span class="hljs-function">function(list)</span> {

      items = list;

      <span class="hljs-function">done()</span>;

    })</span>;

  })</span>;



  <span class="hljs-function">afterEach( <span class="hljs-function">function()</span> {

    //

  })</span>;



  <span class="hljs-function">it(<span class="hljs-string">'should return of type array'</span>, <span class="hljs-function">function()</span> {

    <span class="hljs-function">expect(Array.<span class="hljs-function">isArray(items)</span>)</span>.<span class="hljs-function">toEqual(true)</span>;

    <span class="hljs-function">expect(items.length)</span>.<span class="hljs-function">toEqual(<span class="hljs-number">2</span>)</span>;

  })</span>;



  <span class="hljs-function">it(<span class="hljs-string">'should return array of grocery-ls-item types'</span>, <span class="hljs-function">function()</span> {

    <span class="hljs-function">expect(items[<span class="hljs-number">0</span>])</span>.<span class="hljs-function">toBe(itemOne)</span>;

    <span class="hljs-function">expect(items[<span class="hljs-number">1</span>])</span>.<span class="hljs-function">toBe(itemTwo)</span>;

  })</span>;



})</span>;
</code></pre><p>In the <code>beforeEach()</code>, we’re using anonymous stubs from <a href="http://sinonjs.org/">SinonJS</a>, which allow us to stub out methods that may not necessarily already exist on an object. I have used it previously in this series, but we’ll be using it pretty much exclusively while we stub out the API for the <code>storage-service</code>.</p>
<p>Staying true to our idea that the service will provide an asynchronous communication layer, <code>getItems()</code> returns a deferred which has resolved to a listing of two <code>grocery-ls-item</code> instances in our tests.</p>
<p>Sometimes when working with a single feature, I like to isolate it out from my tests for a bit. Here is what the specrunner reports with running just <strong>storage-service.spec</strong>:<br><img src="http://custardbelly.com/blog/images/tdd_js/part_ix_7.png" alt="Passing on succss of getItems() in service"></p>
<p>We could move that implementation to <code>storage-service</code> module now, but we are sort of in a <a href="http://en.wikipedia.org/wiki/Chicken_or_the_egg">chicken-or-the-egg</a> scenario. We’ve canned the resolved <code>grocery-ls-item</code> list in the test, but how does the list get filled up in an actual scenario for <code>storage-service</code>? It’s an excellent question, and something I often puzzle myself with. I mean, we’ll need a <code>saveItem()</code> method no doubt in order to add items to the store. But shouldn’t that method now be stubbed out in a new test? And how do I test that <code>saveItem()</code> works without <code>getItems()</code> being already tested and verified? I could go in circles…</p>
<p>Let’s just stub out an <code>saveItem()</code> method on <code>storage-service</code> and, afterward, set expectations in another spec suite:</p>
<p><em>/test/jasmine/spec/storage-service.spec.js</em></p>
<pre><code>async<span class="hljs-preprocessor">.beforeEach</span>( function(done) {

  var <span class="hljs-keyword">call</span> = <span class="hljs-number">0</span>,

      tempList = [],

      deferred = $<span class="hljs-preprocessor">.Deferred</span>(),

      getStub = sinon<span class="hljs-preprocessor">.stub</span>()<span class="hljs-preprocessor">.returns</span>(deferred),

      saveStub = sinon<span class="hljs-preprocessor">.stub</span>()<span class="hljs-preprocessor">.callsArgOn</span>(<span class="hljs-number">0</span>, store),

      appendItem = function() {

        tempList<span class="hljs-preprocessor">.push</span>((<span class="hljs-keyword">call</span>++%<span class="hljs-number">2</span> === <span class="hljs-number">0</span>) ? itemOne : itemTwo)<span class="hljs-comment">;</span>

      }<span class="hljs-comment">;</span>



  store<span class="hljs-preprocessor">.saveItem</span> = saveStub<span class="hljs-comment">;</span>

  store<span class="hljs-preprocessor">.getItems</span> = getStub<span class="hljs-comment">;</span>



  store<span class="hljs-preprocessor">.saveItem</span>(appendItem)<span class="hljs-comment">;</span>

  store<span class="hljs-preprocessor">.saveItem</span>(appendItem)<span class="hljs-comment">;</span>

  store<span class="hljs-preprocessor">.getItems</span>()<span class="hljs-preprocessor">.then</span>(function(list) {

    items = list<span class="hljs-comment">;</span>

    done()<span class="hljs-comment">;</span>

  })<span class="hljs-comment">;</span>

  deferred<span class="hljs-preprocessor">.resolve</span>(tempList)<span class="hljs-comment">;</span>

})<span class="hljs-comment">;</span>
</code></pre><p>With these modifications, we have assigned an anonymous stub – <code>saveStub</code> – as the <code>saveItem</code> method on the <code>store</code> and specified that the function-local <code>appendItem</code> method should be invoked, appending items to the list prior to each of our tests. </p>
<p>A little more work in setup and slightly unrealistic in telling of the arguments to be given to <code>saveItem()</code>, but it kept us on green without having to hard code the result; it’s a litte truer to life than the previous setup, and still passes:</p>
<p><img src="http://custardbelly.com/blog/images/tdd_js/part_ix_7.png" alt="Passing on succss of getItems() in service"></p>
<h3 id="implementation">Implementation</h3>
<p>Alright, so I think we should move this out to <code>storage-service</code> now and trash the stubbing in the test – we’ve got our expectations:</p>
<p><em>/script/service/storage-service.js</em></p>
<pre><code>define([<span class="hljs-string">'jquery'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">($)</span> {</span>



  <span class="hljs-keyword">var</span> itemCache = [],

      store = {

        saveItem: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(item)</span> {</span>

          <span class="hljs-keyword">var</span> deferred = $.Deferred();

          itemCache[itemCache.length] = item;

          <span class="hljs-keyword">return</span> deferred.resolve(item);

        },

        getItems: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

          <span class="hljs-keyword">var</span> deferred = $.Deferred();

          deferred.resolve(itemCache);

          <span class="hljs-keyword">return</span> deferred;

        }

      };



  <span class="hljs-keyword">return</span> store;



});
</code></pre><p><em>/test/jasmine/spec/storage-service.spec.js</em></p>
<pre><code><span class="hljs-function">describe(<span class="hljs-string">'getItems()'</span>, <span class="hljs-function">function()</span> {



  var items,

      itemOne = modelFactory.<span class="hljs-function">create()</span>,

      itemTwo = modelFactory.<span class="hljs-function">create()</span>,

      async = new <span class="hljs-function">AsyncSpec(this)</span>;



  async.<span class="hljs-function">beforeEach( <span class="hljs-function">function(done)</span> {

    store.<span class="hljs-function">saveItem(itemOne)</span>;

    store.<span class="hljs-function">saveItem(itemTwo)</span>;

    store.<span class="hljs-function">getItems()</span>.<span class="hljs-function">then(<span class="hljs-function">function(value)</span> {

      items = value;

      <span class="hljs-function">done()</span>;

    })</span>;

  })</span>;



  <span class="hljs-function">afterEach( <span class="hljs-function">function()</span> {

    //

  })</span>;



  <span class="hljs-function">it(<span class="hljs-string">'should return of type array'</span>, <span class="hljs-function">function()</span> {

    <span class="hljs-function">expect(Array.<span class="hljs-function">isArray(items)</span>)</span>.<span class="hljs-function">toEqual(true)</span>;

    <span class="hljs-function">expect(items.length)</span>.<span class="hljs-function">toEqual(<span class="hljs-number">2</span>)</span>;

  })</span>;



  <span class="hljs-function">it(<span class="hljs-string">'should return array of grocery-ls-item types'</span>, <span class="hljs-function">function()</span> {

    <span class="hljs-function">expect(items[<span class="hljs-number">0</span>])</span>.<span class="hljs-function">toBe(itemOne)</span>;

    <span class="hljs-function">expect(items[<span class="hljs-number">1</span>])</span>.<span class="hljs-function">toBe(itemTwo)</span>;

  })</span>;



})</span>;
</code></pre><p>Run that, and we are still green!<br><img src="http://custardbelly.com/blog/images/tdd_js/part_ix_7.png" alt="Passing on succss of getItems() in service"></p>
<h3 id="tests">Tests</h3>
<p>Now that we can verify that <code>saveItem()</code> is working enough for our <code>getItem</code> spec, let’s properly set the expectations for <code>saveItem</code>, as well, in our tests:</p>
<p><em>/test/jasmine/spec/storage-service.spec.js</em></p>
<pre><code>describe(<span class="hljs-string">'saveItem()'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>



  <span class="hljs-keyword">var</span> itemOne = modelFactory.create(),

      itemTwo = modelFactory.create(),

      async = <span class="hljs-keyword">new</span> AsyncSpec(<span class="hljs-keyword">this</span>);



  beforeEach( <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

    store.saveItem(itemOne);

  });



  afterEach( <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

    <span class="hljs-comment">//</span>

  });



  async.it(<span class="hljs-string">'should be grow the length of items'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(done)</span> {</span>

    store.getItems().then( <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(items)</span> {</span>

      expect(items.length).toEqual(<span class="hljs-number">1</span>);

      done();

    });

  });



});
</code></pre><p>Simple enough. Back to the specrunner:<br><img src="http://custardbelly.com/blog/images/tdd_js/part_ix_8.png" alt="Failing on saveItem of storage-service"></p>
<p>Oh noes! Our expectation is that the length of items is only 1. We have only specified one addition of an item in the setup… where did the length of 5 come from!? Put down the abacus – there are better things to throw. But before that, I have an explanation: we haven’t been cleaning up. We have let <code>afterEach()</code> just quietly be invoked without a job to do.</p>
<p>To do just enough in getting our tests pass, we can update the <code>afterEach()</code> declarations in each spec suite to the following:</p>
<pre><code><span class="hljs-transposed_variable">async.</span>afterEach( <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(done)</span> {</span>

  <span class="hljs-transposed_variable">store.</span>getItems().<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(items)</span> {</span>

    <span class="hljs-transposed_variable">items.</span><span class="hljs-built_in">length</span> = <span class="hljs-number">0</span>;

    done();

  });

});
</code></pre><p>That will get us back to passing:<br><img src="http://custardbelly.com/blog/images/tdd_js/part_ix_9.png" alt="Passing on saveItem spec."></p>
<p>I am not particularly fond of that solution, however. Mainly because I think it conveys a usage of the API on <code>storage-service</code> that I would not condone: directly mutating the underlying list of <code>storage-service</code> from another party. </p>
<p>I’m not gonna get crazy with the lock-down and privacy of properties and start introducing the latest-and-greatest framework that tries to tout that they really are just a library all in the attempt to stop someone from directly accessing the underlying array of items on <code>storage-service</code>. If some developers gonna go crazy and do so, hopefully we can find it in more tests later or they can look at our tests as a guideline of how to do what they want. </p>
<p>As such, I think we should add a method to <code>storage-service</code> that simply allows for emptying the list. First the expectation:</p>
<p><em>/test/jasmine/spec/storage-service.spec.js</em></p>
<pre><code><span class="hljs-function">describe(<span class="hljs-string">'empty()'</span>, <span class="hljs-function">function()</span> {



  var itemOne = modelFactory.<span class="hljs-function">create()</span>,

      itemTwo = modelFactory.<span class="hljs-function">create()</span>,

      async = new <span class="hljs-function">AsyncSpec(this)</span>;



  <span class="hljs-function">beforeEach( <span class="hljs-function">function()</span> {

    store.<span class="hljs-function">saveItem(itemOne)</span>;

    store.<span class="hljs-function">saveItem(itemTwo)</span>;

  })</span>;



  <span class="hljs-function">afterEach( <span class="hljs-function">function()</span> {

    store.<span class="hljs-function">empty()</span>;

  })</span>;



  async.<span class="hljs-function">it(<span class="hljs-string">'should be appended to the list of items'</span>, <span class="hljs-function">function(done)</span> {

    store.<span class="hljs-function">empty()</span>.<span class="hljs-function">then( <span class="hljs-function">function(items)</span> {

      <span class="hljs-function">expect(items.length)</span>.<span class="hljs-function">toEqual(<span class="hljs-number">0</span>)</span>;

      <span class="hljs-function">done()</span>;

    })</span>;

  })</span>;



})</span>;
</code></pre><p><img src="http://custardbelly.com/blog/images/tdd_js/part_ix_10.png" alt="Failing on empty()"></p>
<p><em>/script/service/storage-service.js</em></p>
<pre><code>define([<span class="hljs-string">'jquery'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">($)</span> {</span>



  <span class="hljs-keyword">var</span> itemCache = [],

      store = {

        saveItem: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(item)</span> {</span>

          <span class="hljs-keyword">var</span> deferred = $.Deferred();

          itemCache[itemCache.length] = item;

          <span class="hljs-keyword">return</span> deferred.resolve(item);

        },

        getItems: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

          <span class="hljs-keyword">var</span> deferred = $.Deferred();

          deferred.resolve(itemCache);

          <span class="hljs-keyword">return</span> deferred;

        },

        empty: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

          <span class="hljs-keyword">var</span> deferred = $.Deferred();

          itemCache.length = <span class="hljs-number">0</span>;

          deferred.resolve(itemCache);

          <span class="hljs-keyword">return</span> deferred;

        }

      };



  <span class="hljs-keyword">return</span> store;

});
</code></pre><p><img src="http://custardbelly.com/blog/images/tdd_js/part_ix_11.png" alt="Passing on empty()"></p>
<p>Alright! We are passing expectations on three parts of the API for <code>storage-service</code>. Now let’s think of what else we need… I think only a <code>removeItem()</code> method will suffice. In working as we have previously in this article – stubbing out methods to be added to the <code>storage-service</code> implementation – we can add a spec suite for <code>removeItem()</code> such as the following:</p>
<p><em>/test/jasmine/spec/storage-service.spec.js</em></p>
<pre><code><span class="hljs-function">describe(<span class="hljs-string">'removeItem()'</span>, <span class="hljs-function">function()</span> {



  var items,

      itemOne = modelFactory.<span class="hljs-function">create()</span>,

      itemTwo = modelFactory.<span class="hljs-function">create()</span>,

      async = new <span class="hljs-function">AsyncSpec(this)</span>,

      deferred = $.<span class="hljs-function">Deferred()</span>,

      removeItemFromList = <span class="hljs-function">function()</span> {

        deferred.<span class="hljs-function">resolve(items.<span class="hljs-function">splice(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)</span>)</span>;

      };



  async.<span class="hljs-function">beforeEach( <span class="hljs-function">function(done)</span> {

    var removeItemStub = sinon.<span class="hljs-function">stub()</span>.<span class="hljs-function">returns(deferred)</span>.<span class="hljs-function">callsArgOn(<span class="hljs-number">0</span>, store)</span>;



    store.<span class="hljs-function">saveItem(itemOne)</span>;

    store.<span class="hljs-function">saveItem(itemTwo)</span>;

    store.removeItem = removeItemStub;

    store.<span class="hljs-function">getItems()</span>.<span class="hljs-function">then( <span class="hljs-function">function(value)</span> {

      items = value;

      <span class="hljs-function">done()</span>;

    })</span>;

  })</span>;



  <span class="hljs-function">afterEach( <span class="hljs-function">function()</span> {

    store.<span class="hljs-function">empty()</span>;

  })</span>;



  async.<span class="hljs-function">it(<span class="hljs-string">'should shorten length of the list'</span>, <span class="hljs-function">function(done)</span> {

    store.<span class="hljs-function">removeItem(removeItemFromList)</span>.<span class="hljs-function">then( <span class="hljs-function">function(item)</span> {

      store.<span class="hljs-function">getItems()</span>.<span class="hljs-function">then( <span class="hljs-function">function(items)</span> {

        <span class="hljs-function">expect(items.length)</span>.<span class="hljs-function">toEqual(<span class="hljs-number">1</span>)</span>;

        <span class="hljs-function">done()</span>;

      })</span>;

    })</span>;

  })</span>;



})</span>;
</code></pre><p><img src="http://custardbelly.com/blog/images/tdd_js/part_ix_12.png" alt="Passing on initial removeItem()"></p>
<p>I think there are more expectations to assert for the <code>removeItem()</code> spec suite, but for now we are passing and we’ll move the implementation over to <code>storage-service</code>:</p>
<p><em>/script/service/storage-service.js</em></p>
<pre><code>define([<span class="hljs-string">'jquery'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">($)</span> {</span>



  <span class="hljs-keyword">var</span> itemCache = [],

      store = {

        saveItem: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(item)</span> {</span>

          <span class="hljs-keyword">var</span> deferred = $.Deferred();

          itemCache[itemCache.length] = item;

          <span class="hljs-keyword">return</span> deferred.resolve(item);

        },

        removeItem: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(item)</span> {</span>

          <span class="hljs-keyword">var</span> deferred = $.Deferred(),

              itemIndex = itemCache.indexOf(item),

              removedItem;



          <span class="hljs-keyword">if</span>(itemIndex &gt; -<span class="hljs-number">1</span>) {

            itemCache.splice(itemIndex, <span class="hljs-number">1</span>);

            removedItem = item;

          }

          <span class="hljs-keyword">return</span> deferred.resolve(removedItem);

        },

        getItems: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

          <span class="hljs-keyword">var</span> deferred = $.Deferred();

          deferred.resolve(itemCache);

          <span class="hljs-keyword">return</span> deferred;

        },

        empty: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

          <span class="hljs-keyword">var</span> deferred = $.Deferred();

          itemCache.length = <span class="hljs-number">0</span>;

          deferred.resolve(itemCache);

          <span class="hljs-keyword">return</span> deferred;

        }

      };



  <span class="hljs-keyword">return</span> store;



});
</code></pre><p>Now, we’ll update the spec suite for <code>removeItem()</code> and add a few more expectations to ensure the item removal process is correct:</p>
<p><em>/test/jasmine/spec/storage-service.spec.js</em></p>
<pre><code><span class="hljs-function">describe(<span class="hljs-string">'removeItem()'</span>, <span class="hljs-function">function()</span> {



  var itemOne = modelFactory.<span class="hljs-function">create()</span>,

      itemTwo = modelFactory.<span class="hljs-function">create()</span>,

      async = new <span class="hljs-function">AsyncSpec(this)</span>;



  <span class="hljs-function">beforeEach( <span class="hljs-function">function()</span> {

    itemOne.name = <span class="hljs-string">'one'</span>;

    store.<span class="hljs-function">saveItem(itemOne)</span>;

    store.<span class="hljs-function">saveItem(itemTwo)</span>;

  })</span>;



  <span class="hljs-function">afterEach( <span class="hljs-function">function()</span> {

    store.<span class="hljs-function">empty()</span>;

  })</span>;



  async.<span class="hljs-function">it(<span class="hljs-string">'should shorten length of the list'</span>, <span class="hljs-function">function(done)</span> {

    store.<span class="hljs-function">removeItem(itemOne)</span>.<span class="hljs-function">then( <span class="hljs-function">function(item)</span> {

      store.<span class="hljs-function">getItems()</span>.<span class="hljs-function">then( <span class="hljs-function">function(items)</span> {

        <span class="hljs-function">expect(items.length)</span>.<span class="hljs-function">toEqual(<span class="hljs-number">1</span>)</span>;

        <span class="hljs-function">done()</span>;

      })</span>;

    })</span>;

  })</span>;



  async.<span class="hljs-function">it(<span class="hljs-string">'should remove item specified from the list'</span>, <span class="hljs-function">function(done)</span> {

    store.<span class="hljs-function">removeItem(itemOne)</span>.<span class="hljs-function">then( <span class="hljs-function">function(item)</span> {

      store.<span class="hljs-function">getItems()</span>.<span class="hljs-function">then( <span class="hljs-function">function(items)</span> {

        <span class="hljs-function">expect(items.<span class="hljs-function">indexOf(itemOne)</span>)</span>.<span class="hljs-function">toEqual(-<span class="hljs-number">1</span>)</span>;

        <span class="hljs-function">done()</span>;

      })</span>;

    })</span>;

  })</span>;



  async.<span class="hljs-function">it(<span class="hljs-string">'should return the item removed if found'</span>, <span class="hljs-function">function(done)</span> {

    store.<span class="hljs-function">removeItem(itemOne)</span>.<span class="hljs-function">then( <span class="hljs-function">function(item)</span> {

      <span class="hljs-function">expect(item)</span>.<span class="hljs-function">toEqual(itemOne)</span>;

      <span class="hljs-function">done()</span>;

    })</span>;

  })</span>;



  async.<span class="hljs-function">it(<span class="hljs-string">'should return undefined if item not found'</span>, <span class="hljs-function">function(done)</span> {

    store.<span class="hljs-function">removeItem(modelFactory.<span class="hljs-function">create()</span>)</span>.<span class="hljs-function">then( <span class="hljs-function">function(item)</span> {

      <span class="hljs-function">expect(item)</span>.<span class="hljs-function">toBeUndefined()</span>;

      <span class="hljs-function">done()</span>;

    })</span>;

  })</span>;



})</span>;
</code></pre><p>… and we’re still in business!<br><img src="http://custardbelly.com/blog/images/tdd_js/part_ix_13.png" alt="Complete and passing removeItem specs"></p>
<h3 id="revisiting-saveitem-">Revisiting saveItem()</h3>
<p>When we setup the <code>saveItem</code> stub for our <code>getItem()</code> spec suite, we really only focused on getting the expectations to pass. To get back to green – at the time – we were only concerned with appending items to the list. I think this needs to be looked at again.</p>
<p>If we remember back to the notifications we set up for the <code>list-controller</code>, it will dispatch a <code>save-item</code> event upon the existence of a new item, as well as the modification to an existing item. So we will pass that item through the <code>storage-service</code> using <code>saveItem()</code> but we don’t want to continually append items that are previously stored to the list – if so, we’d be buying a lot of <del>spinich</del> <del>spinnash</del> spinach.</p>
<p>Normally I wouldn’t cut corners: a feature spec should be written up for what I have described here prior to modifying the tests. To save you some scrolling, however, I decided to not include walking through one and letting the expectations that we define in the following speak for the specification.</p>
<p><em>/test/jasmine/spec/storage-service.spec.js</em></p>
<pre><code><span class="hljs-function">describe(<span class="hljs-string">'saveItem()'</span>, <span class="hljs-function">function()</span> {



  var itemOne = modelFactory.<span class="hljs-function">create()</span>,

      itemTwo = modelFactory.<span class="hljs-function">create()</span>,

      async = new <span class="hljs-function">AsyncSpec(this)</span>;



  <span class="hljs-function">beforeEach( <span class="hljs-function">function()</span> {

    store.<span class="hljs-function">saveItem(itemOne)</span>;

  })</span>;



  <span class="hljs-function">afterEach( <span class="hljs-function">function()</span> {

    store.<span class="hljs-function">empty()</span>;

  })</span>;



  async.<span class="hljs-function">it(<span class="hljs-string">'should grow the length of items on new item'</span>, <span class="hljs-function">function(done)</span> {

    store.<span class="hljs-function">getItems()</span>.<span class="hljs-function">then( <span class="hljs-function">function(items)</span> {

      <span class="hljs-function">expect(items.length)</span>.<span class="hljs-function">toEqual(<span class="hljs-number">1</span>)</span>;

      <span class="hljs-function">done()</span>;

    })</span>;

  })</span>;



  async.<span class="hljs-function">it(<span class="hljs-string">'should not grow the length of items on pre-existing item'</span>, <span class="hljs-function">function(done)</span> {

    itemOne.name = <span class="hljs-string">'oranges'</span>;

    store.<span class="hljs-function">saveItem(itemOne)</span>.<span class="hljs-function">then( <span class="hljs-function">function(item)</span> {

      store.<span class="hljs-function">getItems()</span>.<span class="hljs-function">then( <span class="hljs-function">function(items)</span> {

        <span class="hljs-function">expect(items.length)</span>.<span class="hljs-function">toEqual(<span class="hljs-number">1</span>)</span>;

        <span class="hljs-function">done()</span>;

      })</span>;

    })</span>;

  })</span>;



})</span>;
</code></pre><p>We modified the description of the original expectation to state that the items list should only grow on new existence and added a new expectation that previously stored items do not get appended to the stored list:</p>
<p><img src="http://custardbelly.com/blog/images/tdd_js/part_ix_14.png" alt="Failing update to saveItem() specs."></p>
<p>As expected <img src="http://custardbelly.com/blog/wp-includes/images/smilies/icon_smile.gif" alt=":)"> Let’s update <code>saveItem()</code> on the <code>storage-service</code> to account for this:</p>
<p><em>/script/service/storage-service.js</em></p>
<pre><code><span class="hljs-attribute">saveItem</span>: <span class="hljs-string">function(item) {</span>

<span class="applescript">  var deferred = $.Deferred(),

      index = itemCache.indexOf(<span class="hljs-property">item</span>);

  <span class="hljs-keyword">if</span>(index === -<span class="hljs-number">1</span>) {

    itemCache[itemCache.<span class="hljs-property">length</span>] = <span class="hljs-property">item</span>;

  }
<span class="hljs-command">
  return</span> deferred.resolve(<span class="hljs-property">item</span>);

}</span>
</code></pre><p><img src="http://custardbelly.com/blog/images/tdd_js/part_ix_15.png" alt="Passing on new expectation for saveItem()"></p>
<p>Not leaving any to chance, let’s add a couple more expectations as to how items are placed and how they remain in their places:</p>
<p><em>/test/jasmine/spec/storage-service.spec.js</em></p>
<pre><code><span class="hljs-function">describe(<span class="hljs-string">'saveItem() multiples'</span>, <span class="hljs-function">function()</span> {



  var itemOne = modelFactory.<span class="hljs-function">create()</span>,

      itemTwo = modelFactory.<span class="hljs-function">create()</span>,

      async = new <span class="hljs-function">AsyncSpec(this)</span>;



  <span class="hljs-function">beforeEach( <span class="hljs-function">function()</span> {

    store.<span class="hljs-function">saveItem(itemOne)</span>;

    store.<span class="hljs-function">saveItem(itemTwo)</span>;

  })</span>;



  <span class="hljs-function">afterEach( <span class="hljs-function">function()</span> {

    store.<span class="hljs-function">empty()</span>;

  })</span>;



  async.<span class="hljs-function">it(<span class="hljs-string">'should append new items to the end of the list'</span>, <span class="hljs-function">function(done)</span> {

    store.<span class="hljs-function">getItems()</span>.<span class="hljs-function">then( <span class="hljs-function">function(items)</span> {

      <span class="hljs-function">expect(items[items.length-<span class="hljs-number">1</span>])</span>.<span class="hljs-function">toBe(itemTwo)</span>;

      <span class="hljs-function">done()</span>;

    })</span>;

  })</span>;



  async.<span class="hljs-function">it(<span class="hljs-string">'should update existing item at position'</span>, <span class="hljs-function">function(done)</span> {

    itemOne.name = <span class="hljs-string">'oranges'</span>;

    store.<span class="hljs-function">saveItem(itemOne)</span>.<span class="hljs-function">then( <span class="hljs-function">function(item)</span> {

      store.<span class="hljs-function">getItems()</span>.<span class="hljs-function">then( <span class="hljs-function">function(items)</span> {

        <span class="hljs-function">expect(items.<span class="hljs-function">indexOf(itemOne)</span>)</span>.<span class="hljs-function">toEqual(<span class="hljs-number">0</span>)</span>;

        <span class="hljs-function">done()</span>;

      })</span>;

    })</span>;

  })</span>;



})</span>;
</code></pre><p>I had begun to add these expectations for multiple items in the list to the <code>saveItem()</code> spec suite, but I saw a similar setup for them both that differed from the origin setup for the <code>saveItem()</code> suite. As such, I moved these expectations to their own spec suite and particular setup.</p>
<p>Without any new modification to <code>storage-service</code> implementation, run that and we are still green!<br><img src="http://custardbelly.com/blog/images/tdd_js/part_ix_16.png" alt="Passing with new expectations for saveItem()"></p>
<p>Tagged <strong>0.1.14</strong>: <a href="https://github.com/bustardcelly/grocery-ls/tree/0.1.14"><a href="https://github.com/bustardcelly/grocery-ls/tree/0.1.14">https://github.com/bustardcelly/grocery-ls/tree/0.1.14</a></a></p>
<h2 id="this-is-all-great-but-we-still-haven-t-done-anything">This Is All Great But We Still Haven’t Done Anything</h2>
<p>In other words, what this subsection header is trying to say, the <code>storage-service</code> – even after we hook up communication to it from <code>list-controller</code> events – will do <em>nothing</em> but keep a session-cache of items: <strong>there still is no persistence across sessions</strong>.</p>
<p>Seeing as this is the case, let’s start integrating communication with <code>localStorage</code> into our <code>storage-service</code>. I am not going to modify the tests in order to verify the utilization of <code>localStorage</code> in relation to the operations available on <code>storage-service</code> – I am simply going to modify the <code>storage-service</code> and posible change expectations. The reason being that I do not really care about whether the storage-service relies on <code>localStorage</code> or a remote resource to read and write items to storage; I am only concerned with communication to <code>storage-service</code> being supported. </p>
<p>In truth, if this were a real world application and had to support occasional connectivity, i’d have two service modules: local-storage-service and remove-storage-service. They would both support the same API and there would be a service layer facade that would manage the ‘live’ instance and sync of both. That is a little too much for this series, so we’ll stick with a proxy to <code>localStorage</code> without modifying our tests to assume that the <code>storage-service</code> requires communication with it.</p>
<h3 id="storage-service-modification">storage-service modification</h3>
<p>To begin with, a <code>String</code> value is used as a key to read and write to an object held on <a href="https://developer.mozilla.org/en-US/docs/DOM/Storage">localStorage</a>. The API of <code>localStorage</code> is fairly simple and we’ll only be concerned with <code>getItem()</code> and <code>setItem()</code> to read and write to the store, respectively. We’ll use a key that we hope is unique to our application and won’t overwrite any object stored previously by another and use that key to access the stored grocery list items:</p>
<p><em>/script/service/storage-service.js</em></p>
<pre><code>define([<span class="hljs-string">'jquery'</span>, <span class="hljs-string">'script/model/grocery-ls-item'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">($, modelFactory)</span> {</span>



  <span class="hljs-keyword">var</span> itemCache,

      groceryListKey = <span class="hljs-string">'com.custardbelly.grocerylist'</span>,

      parseToCollection = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(json)</span> {</span>

        <span class="hljs-keyword">var</span> i,

            length,

            list = (json &amp;&amp; <span class="hljs-keyword">typeof</span> json === <span class="hljs-string">'string'</span>) ? <span class="hljs-built_in">JSON</span>.parse(json) : [];

        length = list.length;

        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; length; i++) {

          list[i] = $.extend(modelFactory.create(), list[i]);

        }

        <span class="hljs-keyword">return</span> list;

      },

      store = {

        saveItem: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(item)</span> {</span>

          <span class="hljs-keyword">var</span> deferred = $.Deferred();

          <span class="hljs-keyword">return</span> deferred.resolve(item);

        },

        removeItem: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(item)</span> {</span>

          <span class="hljs-keyword">var</span> deferred = $.Deferred(),

              itemIndex = itemCache.indexOf(item),

              removedItem;



          <span class="hljs-keyword">if</span>(itemIndex &gt; -<span class="hljs-number">1</span>) {

            itemCache.splice(itemIndex, <span class="hljs-number">1</span>);

            removedItem = item;

          }

          <span class="hljs-keyword">return</span> deferred.resolve(removedItem);

        },

        getItems: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

          <span class="hljs-keyword">var</span> deferred = $.Deferred();

          <span class="hljs-keyword">if</span>(itemCache === <span class="hljs-literal">undefined</span>) {

             <span class="hljs-keyword">try</span> {

              itemCache = parseToCollection(window.localStorage.getItem(groceryListKey));

              deferred.resolve(itemCache);

            }

            <span class="hljs-keyword">catch</span>(e) {

              deferred.reject(<span class="hljs-string">'Could not access items: '</span> + e.message);

            }

          }

          <span class="hljs-keyword">else</span> {

            deferred.resolve(itemCache);

          }

          <span class="hljs-keyword">return</span> deferred;

        },

        empty: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

          <span class="hljs-keyword">var</span> deferred = $.Deferred();

          itemCache.length = <span class="hljs-number">0</span>;

          deferred.resolve(itemCache);

          <span class="hljs-keyword">return</span> deferred;

        }

      };



  <span class="hljs-keyword">return</span> store;



});
</code></pre><p>That will light up our tests in pretty red… but that was expected. Actually, if it didn’t make our tests fail horribly, I would have been worried.<br><img src="http://custardbelly.com/blog/images/tdd_js/part_ix_23.png" alt="Failing on sotrage modification."></p>
<p>There are a couple things going on in this modification to <code>storage-service</code> that we should go over, however – the first being <code>parseToCollection()</code>:</p>
<p><em>/script/service/storage-service.js</em></p>
<pre><code>parseToCollection = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(json)</span> {</span>

  var <span class="hljs-built_in">i</span>,

      <span class="hljs-built_in">length</span>,

      list = (json &amp;&amp; typeof json === <span class="hljs-string">'string'</span>) ? <span class="hljs-transposed_variable">JSON.</span>parse(json) : <span class="hljs-matrix">[]</span>;



  <span class="hljs-built_in">length</span> = <span class="hljs-transposed_variable">list.</span><span class="hljs-built_in">length</span>;

  <span class="hljs-keyword">for</span>(<span class="hljs-built_in">i</span> = <span class="hljs-number">0</span>; <span class="hljs-built_in">i</span> &lt; <span class="hljs-built_in">length</span>; <span class="hljs-built_in">i</span>++) <span class="hljs-cell">{

    list[i] = $.extend(modelFactory.create(), list[i]);

  }</span>

  <span class="hljs-keyword">return</span> list;

}
</code></pre><p>This method is invoked from <code>getItems()</code> and is provided the value of the object held in <code>localStorage</code> with the key <code>com.custardbelly.grocerylist</code>. We’ll be saving our data down in <a href="http://www.json.org/">JSON</a> format, and as such, <code>parseCollection()</code> is responsible for parsing that data back out; as well, if it is the first time accessing the data it will be coming in as undefined so a new list is created. What is particularly important in this parsing is how the objects on the list held in <code>localStorage</code> are converted to instances of our <code>grocery-ls-item</code> model: we create a new instance using the <code>modelFactory</code> and extend it with the object values from the item held on the list. The reason for this is because <code>grocery-ls-items</code> are decorated with getters and setters to allow for <code>property-change</code> events to be notified. In serializing down to JSON, this object structure is not perserved – it is just a <strong>POJSO</strong>.</p>
<p>The <code>parseToCollection()</code> method is invoked from <code>getItems()</code>:</p>
<p><em>/script/service/storage-service.js</em></p>
<pre><code>getItems: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

  <span class="hljs-keyword">var</span> deferred = $.Deferred();

  <span class="hljs-keyword">if</span>(itemCache === <span class="hljs-literal">undefined</span>) {

    <span class="hljs-keyword">try</span> {

      itemCache = parseToCollection(window.localStorage.getItem(groceryListKey));

      deferred.resolve(itemCache);

    }

    <span class="hljs-keyword">catch</span>(e) {

      deferred.reject(<span class="hljs-string">'Could not access items: '</span> + e.message);

    }

  }

  <span class="hljs-keyword">else</span> {

    deferred.resolve(itemCache);

  }

  <span class="hljs-keyword">return</span> deferred;

}
</code></pre><p>When <code>getItems()</code> is first invoked in a session, it will go about trying to access and parse the data held on <code>localStorage</code>; any subsequent invocations will immediately return the currently held reference to the store. In essence, during a session of creating and curating a <strong>Grocery List</strong>, we are working with live and current data so there is no need to keep accessing the list of grocery items from local storage every time – we’ll just return the live record.</p>
<p>Speaking of which, a lot of the failing tests I suspect are due to not actually not saving the list down to <code>localStorage</code>. Let’s just modify <code>storage-service</code> a little to do so and see where that gets us:</p>
<p><em>/script/service/storage-service.js</em></p>
<pre><code>define([<span class="hljs-string">'jquery'</span>, <span class="hljs-string">'script/model/grocery-ls-item'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">($, modelFactory)</span> {</span>



  <span class="hljs-keyword">var</span> itemCache,

      groceryListKey = <span class="hljs-string">'com.custardbelly.grocerylist'</span>,

      parseToCollection = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(json)</span> {</span>

        <span class="hljs-keyword">var</span> i,

            length,

            list = (json &amp;&amp; <span class="hljs-keyword">typeof</span> json === <span class="hljs-string">'string'</span>) ? <span class="hljs-built_in">JSON</span>.parse(json) : [];



        length = list.length;

        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; length; i++) {

          list[i] = $.extend(modelFactory.create(), list[i]);

        }

        <span class="hljs-keyword">return</span> list;

      },

      serialize = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(key, data)</span> {</span>

        window.localStorage.setItem(key, <span class="hljs-built_in">JSON</span>.stringify(data));

      },

      store = {

        saveItem: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(item)</span> {</span>

          <span class="hljs-keyword">var</span> deferred = $.Deferred();

          $.when(<span class="hljs-keyword">this</span>.getItems()).then(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(cache)</span> {</span>

            <span class="hljs-keyword">var</span> index = cache.indexOf(item);

            <span class="hljs-keyword">try</span> {

              <span class="hljs-keyword">if</span>(index === -<span class="hljs-number">1</span>) {

                cache[cache.length] = item;

              }

              serialize(groceryListKey, cache);

              deferred.resolve(item);

            }

            <span class="hljs-keyword">catch</span>(e) {

              deferred.reject(<span class="hljs-string">'Could not save item: '</span> + e.message);

            }

          });

          <span class="hljs-keyword">return</span> deferred;

        },

        removeItem: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(item)</span> {</span>

          <span class="hljs-comment">// implementation removed to reduce noise</span>

        },

        getItems: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

          <span class="hljs-comment">// implementation removed to reduce noise</span>

        },

        empty: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

          <span class="hljs-comment">// implementation removed to reduce noise</span>

        }

      };



  <span class="hljs-keyword">return</span> store;



});
</code></pre><p><code>saveItem()</code> was modified to access the held list using <code>getItems()</code>, operate on that list as it had done previously and then try to serialize the list back to storage. Fairly simple. It’s important to note that we don’t access the <code>itemCache</code> directly in saveItem(), the reason being that we can’t ensure that <code>saveItem()</code> will only be called after a request to <code>getItems()</code>. As such, we need to be sure we’re always working with the same data and do so by requesting that cached list from <code>getItems()</code> within <code>saveItem()</code>.</p>
<p>That gets us closer to green, but we still have some work to do…<br><img src="http://custardbelly.com/blog/images/tdd_js/part_ix_24.png" alt="Closer to green for storage-service modifications."></p>
<p>Let’s modify <code>removeItem()</code> and <code>empty()</code> to work with the cached list returned from <code>getItems()</code> just as the modification to <code>saveItems()</code> has:</p>
<p><em>/script/service/storage-service.js</em></p>
<pre><code>removeItem: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(item)</span> {</span>

  <span class="hljs-keyword">var</span> deferred = $.Deferred();

  $.when(<span class="hljs-keyword">this</span>.getItems()).then(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(cache)</span> {</span>

    <span class="hljs-keyword">var</span> itemIndex = cache.indexOf(item),

        removedItem;

    <span class="hljs-keyword">try</span> {

      <span class="hljs-keyword">if</span>(itemIndex &gt; -<span class="hljs-number">1</span>) {

        cache.splice(itemIndex, <span class="hljs-number">1</span>);

        removedItem = item;

        serialize(groceryListKey, cache);

      }

      deferred.resolve(removedItem);

    }

    <span class="hljs-keyword">catch</span>(e) {

      cache.splice(itemIndex, <span class="hljs-number">0</span>, removedItem);

      deferred.reject(<span class="hljs-string">'Could not remove item: '</span> + e.message);

    }

  });

  <span class="hljs-keyword">return</span> deferred;

}
</code></pre><p><em>/script/service/storage-service.js</em></p>
<pre><code>empty: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

  <span class="hljs-keyword">var</span> deferred = $.Deferred();

  $.when(<span class="hljs-keyword">this</span>.getItems()).then(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(cache)</span> {</span>

    <span class="hljs-keyword">try</span> {

      cache.length = <span class="hljs-number">0</span>;

      serialize(groceryListKey, cache);

      deferred.resolve(cache);

    }

    <span class="hljs-keyword">catch</span>(e) {

      deferred.reject(<span class="hljs-string">'Could not empty cache: '</span> + e.message);

    }

  });

  <span class="hljs-keyword">return</span> deferred;

}
</code></pre><p>That oughta do. Basically doing the same as we had done with <code>saveItem()</code>: accessing the cached list through <code>getItems()</code>, then modifying that list and serializing back done to <code>localStorage</code>.</p>
<p>Run those tests again, and we are back to green!<br><img src="http://custardbelly.com/blog/images/tdd_js/part_ix_25.png" alt="Passing storage-service tests after modification!"></p>
<p>… at least for our <code>storage-service</code>. Let’s turn on all our tests again and see if our previous expectations are met:<br><img src="http://custardbelly.com/blog/images/tdd_js/part_ix_26.png" alt="Passing tests!"></p>
<p>Whoopie!</p>
<p>Tagged <strong>0.1.15</strong>: <a href="https://github.com/bustardcelly/grocery-ls/tree/0.1.15"><a href="https://github.com/bustardcelly/grocery-ls/tree/0.1.15">https://github.com/bustardcelly/grocery-ls/tree/0.1.15</a></a></p>
<p>We’re not done yet: we have still to hook up <code>list-controller</code> notification to <code>storage-service</code> operations. However, I want to end this article here on a good note <img src="http://custardbelly.com/blog/wp-includes/images/smilies/icon_smile.gif" alt=":)"></p>
<h2 id="conclusion">Conclusion</h2>
<p>We have yet to reach our goal of incorporating session persistence within our <strong>Grocery List</strong> application – but that is not to say we have gotten nowhere. We implemented our <code>storage-service</code> layer for <code>localStorage</code> communication and modified the <code>list-controller</code> to notify of change events to its collection related to <code>grocery-ls-item</code> existence. Not to shabby. </p>
<p>I know we want to get a finished product out the door, but we’ll get there… just a few more things to tie up in the next article…</p>
<p>Cheers! </p>
<p>—-</p>
<h1 id="link-dump">Link Dump</h1>
<h2 id="reference">Reference</h2>
<p><a href="http://tddjs.com/">Test-Driven JavaScript Development by Christian Johansen</a><br><a href="http://dannorth.net/introducing-bdd/">Introducing BDD by Dan North</a><br><a href="http://cumulative-hypotheses.org/2011/08/30/tdd-as-if-you-meant-it/">TDD as if you Meant it by Keith Braithwaite</a><br><a href="http://requirejs.org/">RequireJS</a><br><a href="https://github.com/amdjs/amdjs-api/wiki/AMD">AMD</a><br><a href="http://pivotal.github.com/jasmine/">Jasmine</a><br><a href="http://sinonjs.org/">Sinon</a><br><a href="https://github.com/derickbailey/jasmine.async">Jasmine.Async</a></p>
<h2 id="post-series">Post Series</h2>
<p><a href="https://github.com/bustardcelly/grocery-ls">grocery-ls github repo</a><br><a href="http://custardbelly.com/blog/2012/11/26/the-making-of-a-test-driven-grocery-list-application-in-javascript-part-i">Part I – Introduction</a><br><a href="http://custardbelly.com/blog/2012/11/26/the-making-of-a-test-driven-grocery-list-application-in-js-part-ii">Part II – Feature: Add Item</a><br><a href="http://custardbelly.com/blog/2012/12/06/the-making-of-a-test-driven-grocery-list-application-in-js-part-iii">Part III – Feature: Mark-Off Item</a><br><a href="http://custardbelly.com/blog/2012/12/17/the-making-of-a-test-driven-grocery-list-application-in-js-part-iv">Part IV – Feature: List-Item-Controller</a><br><a href="http://custardbelly.com/blog/2012/12/31/the-making-of-a-test-driven-grocery-list-application-in-js-part-v/">Part V – Feature: List-Controller Refactoring</a><br><a href="http://custardbelly.com/blog/2013/01/08/the-making-of-a-test-driven-grocery-list-application-in-js-part-vi/">Part VI – Back to Passing</a><br><a href="http://custardbelly.com/blog/2013/01/17/the-making-of-a-test-driven-grocery-list-application-in-js-part-vii/">Part VII – Remove Item</a><br><a href="http://custardbelly.com/blog/2013/01/22/the-making-of-a-test-driven-grocery-list-application-part-viii/">Part VIII – Bug Fixing</a><br><a href="http://custardbelly.com/blog/2013/02/15/the-making-of-a-test-driven-grocery-list-application-in-js-part-ix/">Part IX – Persistence</a><br><a href="http://custardbelly.com/blog/2013/03/06/the-making-of-a-test-driven-grocery-list-application-in-js-part-x/">Part X – It Lives!</a></p>
<p>Posted in <a href="http://custardbelly.com/blog/category/amd/">AMD</a>, <a href="http://custardbelly.com/blog/category/javascript/">JavaScript</a>, <a href="http://custardbelly.com/blog/category/requirejs/">RequireJS</a>, <a href="http://custardbelly.com/blog/category/grocery-ls/">grocery-ls</a>, <a href="http://custardbelly.com/blog/category/jasmine/">jasmine</a>, <a href="http://custardbelly.com/blog/category/unit-testing/">unit-testing</a>.</p>
]]></description><link>http://custardbelly.com/blog/blog-posts/2013/02/15/the-making-of-a-test-driven-grocery-list-application-in-js-part-ix/index.html</link><guid isPermaLink="true">http://custardbelly.com/blog/blog-posts/2013/02/15/the-making-of-a-test-driven-grocery-list-application-in-js-part-ix/index.html</guid><dc:creator><![CDATA[Todd Anderson]]></dc:creator><pubDate>Invalid Date</pubDate></item><item><title><![CDATA[madmin: for ease of creating and documenting RESTful service URIs]]></title><description><![CDATA[<p>My company, <a href="http://infrared5.com">Infrared5</a>, recently released an Open Source project called <a href="https://github.com/infrared5/madmin">madmin</a>, which I had the great pleasure of being a main part of. </p>
<p><strong>madmin</strong> is a node-based application that allows for generating immediately accessible RESTful URIs. Though it is possible to communicate with command line tools like cURL, <strong>madmin</strong> also provides a client-side console to easily create the URIs and structure of JSON response(s). It was originally intended to solve a front-end development problem in maintaining two sets of code – a <em>fake</em> service layer and <em>production-level</em> service layer – during development, but has grown to be a proven way to facilitate communication between the server-side and client-side teams in discussing the requirements of the services for a project. It also proved to be pretty handy documentation, to boot, which could be easily discussed with clients.</p>
<p>Anyway, you can read a more detailed description of the project and how it came to fruition over at the <a href="http://blog.infrared5.com">Infrared5 blog</a>: <a href="http://blog.infrared5.com/2013/01/introducing-madmin-an-admin-console-for-generating-mock-services-with-restful-uris/"><a href="http://blog.infrared5.com/2013/01/introducing-madmin-an-admin-console-for-generating-mock-services-with-restful-uris/">http://blog.infrared5.com/2013/01/introducing-madmin-an-admin-console-for-generating-mock-services-with-restful-uris/</a></a></p>
<p>If you check it out, I hope you find it useful in any way and please log issues for requests or fork it to add features! I intend to get more basic instructions up on the wiki at its <a href="https://github.com/infrared5/madmin">github location</a> and perhaps write a few blog posts as well.</p>
<p>Posted in <a href="http://custardbelly.com/blog/category/infrared5/">Infrared5</a>, <a href="http://custardbelly.com/blog/category/javascript/">JavaScript</a>, <a href="http://custardbelly.com/blog/category/madmin/">madmin</a>, <a href="http://custardbelly.com/blog/category/node/">node</a>.</p>
]]></description><link>http://custardbelly.com/blog/blog-posts/2013/02/04/madmin-for-ease-of-creating-and-documenting-restful-service-uris/index.html</link><guid isPermaLink="true">http://custardbelly.com/blog/blog-posts/2013/02/04/madmin-for-ease-of-creating-and-documenting-restful-service-uris/index.html</guid><dc:creator><![CDATA[Todd Anderson]]></dc:creator><pubDate>Invalid Date</pubDate></item><item><title><![CDATA[The Making of a Test-Driven Grocery List Application: Part VIII]]></title><description><![CDATA[<p><em>This is the eighth installment in a series of building a Test-Driven Grocery List application using <a href="http://pivotal.github.com/jasmine/">Jasmine</a> and <a href="http://requirejs.org">RequireJS</a>. To learn more about the intent and general concept of the series please visit <a href="http://custardbelly.com/blog/2012/11/26/the-making-of-a-test-driven-grocery-list-application-in-javascript-part-i/">The Making of a Test-Driven Grocery List Application in JavaScript: Part I</a></em><br>—</p>
<h1 id="introduction">Introduction</h1>
<p>In the past several articles we have sort of have been living in the spec runner. We fiddled about making it turn red and green, and – until <a href="http://custardbelly.com/blog/2013/01/17/the-making-of-a-test-driven-grocery-list-application-in-js-part-vii/">the last article</a> – we never really ran the <strong>Grocery List</strong> application we were building to give it a proper <em>User Testing</em>. If you did play around with the actual application we have been busy writing tests for, you may have found a bug. An unexpected result from supplying no grocery item name before saving it to the list:</p>
<p><img src="http://custardbelly.com/blog/images/tdd_js/part_viii_1.png" alt="Image for bug ticket with empty item."></p>
<p>As you can see from the screenshot, there is an empty item in the third entry of the list. While I do think the act of walking into a store and picking up nothing is an accomplishment at times, this <em>Empty Item</em> bug is not an intended feature. In this article, I want to squash that bug… but – in keep with the theme of this series – we are going to do it through tests! Calm down. It is hard to read when you jump up and down like that.</p>
<h1 id="bug-ticket">Bug Ticket</h1>
<p>Before we begin fixing the bug, let’s get it down in writing what we think the problem is and how we think the intended behavior should be. To start, we don’t want empty items added to the <strong>Grocery List</strong>. We are currently able to add them – and rather easily – so let’s list out the steps that allows us to do so:</p>
<p><em>Empty Item Added to List</em><br>—<br><strong>Steps to Reproduce</strong></p>
<ol>
<li>Launch the Grocery List application</li>
<li>Click ‘add item’ button</li>
<li>In focused input field, type the name of a grocery item, ie. ‘apples’ (sans quotes)</li>
<li>Click the Tab button to save to list</li>
<li>Click ‘add item’ button</li>
<li>Leave the focused input field blank</li>
<li>Click the Tab button</li>
</ol>
<p><strong>Result</strong><br>Empty item is added to the list</p>
<p><strong>Expected Result</strong><br>An item without any name value provided is not added to the list</p>
<p><strong>Additional Notes</strong><br>It is not a requirement to first have a valid item added to the list in order to reproduce the issue. Steps 1-4 are intended to show expected behavior with a non-empty item.<br>—</p>
<p>If you are out there reading this and file bug tickets, please, for the love of software, log a ticket with a structure similar to this. Most modern bug tracking systems have fields like this, but you’d be surprised (or maybe not) how tickets come in sometimes. My least favorite is explained bug in the title. I can only imagine that they are the same people who write the whole email in the Subject field.</p>
<p>Alright, so now we know what we are dealing with. We have clear steps to reproduce the issue we think is a bug and have explained the difference between the actual result and the intended/expected result. Let’s tackle it.</p>
<h1 id="tests">Tests</h1>
<p>As the developer of the application, we probably know exactly where this is happening. Our initial response is to go write to the source and resolve this issue. But we’re not going to do that. Don’t give me that look. I know, I know. The less we have to be in bug-fixing-mode, the happier developer we be, but I think if we have a test that supports the validity of this claim then, when we do make changes to the application code and it still passes, we know we have not committed a regression. I think it is a confidence builder in relying on my code to work properly and takes away some stress when refactoring comes into play.</p>
<p>Before we begin, let’s think about where we will add the tests. We could append another spec suite to the <em>Add Item</em> specs – after all, this bug occurs upon the completion of the <em>Add Item</em> feature. But in thinking about how to reproduce the issue, it seems like it may be another feature, or at least could be discovered in a feature we haven’t addressed – <em>Edit Item</em>. Essentially, when we get to the 3rd step – <em>In focused input field, type the name of a grocery item, ie. ‘apples’ (sans quotes)</em> – we have already added the item to the list. It has entered an edit mode, from which we need to ensure the validity of the value provided before saving it to the list. </p>
<p>Now, a true <strong>TDD</strong>‘er probably would stop me right now and tell me I am thinking too much to get this resolved. And, in part, they would be correct in doing so. But it is not my intent to start dreaming up new features during bug fixing. I just want to properly think about where the tests make the most sense. I don’t think they belong as an addendum to the <em>Add Item</em> specs and should live in there own spec suite in a separate file:</p>
<p><em>/test/jasmine/spec/feature/saveitem.spec.js</em></p>
<pre><code>define(['jquery', '<span class="hljs-keyword">script</span>/controller/<span class="hljs-type">list</span>-controller', '<span class="hljs-keyword">script</span>/controller/<span class="hljs-type">list</span>-<span class="hljs-property">item</span>-controller'],

        function($, listController, itemControllerFactory) {



  describe('Save <span class="hljs-property">item</span> <span class="hljs-keyword">to</span> grocery <span class="hljs-type">list</span>', function() {



    <span class="hljs-keyword">it</span>('should <span class="hljs-keyword">not</span> save an empty <span class="hljs-property">item</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">the</span> <span class="hljs-type">list</span>') {

      expect(<span class="hljs-constant">true</span>).toEqual(<span class="hljs-constant">false</span>);

    }



  }

}
</code></pre><p>Given the steps provided in the bug ticket, we could easily translate that into the setup for the spec suite:</p>
<p><em>/test/jasmine/spec/feature/saveitem.spec.js</em></p>
<pre><code>define([<span class="hljs-string">'jquery'</span>, <span class="hljs-string">'script/controller/list-controller'</span>, <span class="hljs-string">'script/controller/list-item-controller'</span>],

        <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">($, listController, itemControllerFactory)</span> {</span>



  describe(<span class="hljs-string">'Save item to grocery list'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>



    <span class="hljs-keyword">var</span> item,

        itemName = <span class="hljs-string">'apples'</span>,

        invalidName = <span class="hljs-string">''</span>,

        itemRenderer,

        async = <span class="hljs-keyword">new</span> AsyncSpec(<span class="hljs-keyword">this</span>);



    beforeEach( <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

      item = listController.createNewItem();

      itemRenderer = listController.getRendererFromItem(item);

    });



    it(<span class="hljs-string">'should not save an empty item to the list'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

      expect(<span class="hljs-literal">true</span>).toEqual(<span class="hljs-literal">false</span>);

    });



    afterEach( <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

      item = <span class="hljs-literal">undefined</span>;

      itemRenderer = <span class="hljs-literal">undefined</span>;

    });

  });



});
</code></pre><p>In the <code>beforeEach()</code> setup, we have progressed the application – or at least a list item – to essentially the 3rd step in the <em>Steps to Reproduce</em>: we have added a new item to the list, and internally upon addition of an item in the <code>list-controller</code>, it has entered edit-mode for that item. In the variable declarations, we have also defined what we know of as being valid and invalid item entry names: <em>‘apples’</em> and <em>”</em>, respectively. </p>
<p>We should be ready to go in our specs now to define the rest of the steps and expected results:</p>
<p><em>/test/jasmine/spec/feature/saveitem.spec.js</em></p>
<pre><code><span class="hljs-function">it(<span class="hljs-string">'should not save an empty item to the list'</span>, <span class="hljs-function">function()</span> {

  var listLength = listController.<span class="hljs-function">getItemList()</span>.<span class="hljs-function">itemLength()</span>;



  item.name = invalidName;

  // save item... ?

  <span class="hljs-function">expect(listController.<span class="hljs-function">getItemList()</span>.<span class="hljs-function">itemLength()</span>)</span>.<span class="hljs-function">toEqual(listLength)</span>;

})</span>;
</code></pre><p>Oh, boy. How do we actually save an item? There is no API on the <code>list-controller</code> that saves an item. There used to be, but we refactored that out when we handed over item management to the <code>list-item-controller</code>. Furthermore, an item is added and kept on the list since its request for creation – the actual reason for the bug, I suppose. I am fine with such functionality internally to the <code>list-controller</code> as it stands now and don’t intend to change the item creation. I think an additional event should be dispatched from a <code>list-item-controller</code> signifying a request to commit the item to the list after being edited. Let’s finish up this spec under such assumptions, then work our way through the failing test:</p>
<p><em>/test/jasmine/spec/feature/saveitem.spec.js</em></p>
<pre><code>async.it(<span class="hljs-string">'should not save an empty item to the list'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(done)</span> {</span>

  <span class="hljs-keyword">var</span> listLength = listController.getItemList().itemLength();



  $(itemRenderer).on(<span class="hljs-string">'commit'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(event)</span> {</span>

    expect(listController.getItemList().itemLength()).toEqual(listLength-<span class="hljs-number">1</span>);

    done();

  });



  item.name = invalidName;

  itemRenderer.save();

});
</code></pre><p>We marked the spec as asynchronous to support events from the <code>list-item-controller</code> and placed the expectation within the <em>‘commit’</em> event handler.</p>
<p>Run that, and we’ll be waiting for about 5 seconds until we are told that save() is not a method on the <code>list-item-controller</code> instance:</p>
<p><img src="http://custardbelly.com/blog/images/tdd_js/part_viii_2.png" alt="Failing save item test with timeout"></p>
<p>I have temporarily commented out the other tests in order to remove any noise and focus solely on resolving this bug. This is for local testing and would not commit the spec runner in such a state when committing back to the repo and running latest on a CI server.</p>
<p>To resolve that, let’s open up <code>list-item-controller</code> and add that method:</p>
<p><em>/script/controller/list-item-controller.js</em></p>
<pre><code>listItemController = {

  $editableView: undefined,

  $uneditableView: undefined,

  init: <span class="hljs-keyword">function</span>() {

    <span class="hljs-keyword">...</span>

    <span class="hljs-keyword">return</span> this;

  },

  save: <span class="hljs-keyword">function</span>() {

  },

  dispose: <span class="hljs-keyword">function</span>() {

    <span class="hljs-keyword">...</span>

  }

};
</code></pre><p>Run that again, and now we are down to just the timeout failure:</p>
<p><img src="http://custardbelly.com/blog/images/tdd_js/part_viii_3.png" alt="Timeout failure on list-item-controller save"></p>
<p>To resolve that, we’ll first create a new event factory method and invoke it from <code>save()</code> to dispatch the <em>commit</em> event, of which we have assigned a handler for in the test:</p>
<p><em>/script/controller/list-item-controller.js</em></p>
<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createSaveEvent</span><span class="hljs-params">(controller)</span> {</span>

  <span class="hljs-keyword">var</span> event = $.Event(<span class="hljs-string">'commit'</span>);

  event.controller = controller;

  <span class="hljs-keyword">return</span> event;

}
</code></pre><p>and…</p>
<pre><code>save: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

  $(<span class="hljs-keyword">this</span>).trigger(createSaveEvent(<span class="hljs-keyword">this</span>));

},
</code></pre><p>No more timeout!</p>
<p><img src="http://custardbelly.com/blog/images/tdd_js/part_viii_4.png" alt="Failing expectation on list-item-controller save."></p>
<p>But still failing. Reason is that the item had not been removed from the collection. In previous tests we have verified its addition to the collection from the <code>createNewItem()</code> method on <code>list-controller</code>. Now that we are saving the <code>list-item-controller</code> with a modified model that has an invalid name, we are expecting such an action to remove the item from the collection – the crux of our <em>Empty Item</em> bug.</p>
<p>Let’s modify the <code>list-controller</code> in order to handle the commit event from a <code>list-item-controller</code>:</p>
<p><em>/script/controller/list-controller.js</em></p>
<pre><code><span class="hljs-variable">$collection</span>.on(<span class="hljs-string">'collection-change'</span>, function(<span class="hljs-keyword">event</span>) {

  var model, itemController, <span class="hljs-variable">$itemView</span>;

  <span class="hljs-keyword">switch</span>( <span class="hljs-keyword">event</span>.kind ) {

    <span class="hljs-keyword">case</span> EventKindEnum.ADD:

      <span class="hljs-variable">$itemView</span> = <span class="hljs-variable">$(</span><span class="hljs-string">'&lt;li&gt;'</span>);

      model = <span class="hljs-keyword">event</span>.items.shift();

      itemController = itemControllerFactory.create(<span class="hljs-variable">$itemView</span>, model);



      <span class="hljs-variable">$itemView</span>.appendTo(listController.<span class="hljs-variable">$view</span>);

      rendererList.addItem(itemController);

      itemController.state = itemControllerFactory.state.EDITABLE;

      <span class="hljs-variable">$(</span>itemController).on(<span class="hljs-string">'remove'</span>, function(<span class="hljs-keyword">event</span>) {

        listController.removeItem(model);

      });

      <span class="hljs-variable">$(</span>itemController).on(<span class="hljs-string">'commit'</span>, function(<span class="hljs-keyword">event</span>) {

        <span class="hljs-keyword">if</span>(!isValidValue(model.name)) {

          listController.removeItem(model);

        }

      });

      <span class="hljs-keyword">break</span>;

    <span class="hljs-keyword">case</span> EventKindEnum.REMOVE:

      model = <span class="hljs-keyword">event</span>.items.shift();

      itemController = listController.getRendererFromItem(model);



      <span class="hljs-keyword">if</span>(itemController) {

        <span class="hljs-variable">$itemView</span> = itemController.parentView;

        <span class="hljs-variable">$itemView</span>.remove();

        itemController.dispose();

        <span class="hljs-variable">$(</span>itemController).off(<span class="hljs-string">'remove'</span>);

        <span class="hljs-variable">$(</span>itemController).off(<span class="hljs-string">'commit'</span>);

        rendererList.removeItem(itemController);

      }

      <span class="hljs-keyword">break</span>;

    <span class="hljs-keyword">case</span> EventKindEnum.RESET:

      <span class="hljs-keyword">break</span>;

  }

});
</code></pre><p>We’ve added another event listener to the <code>list-item-controller</code> when it is added to the collection to handle the <em>commit</em> event. Within the handler we check for its validity – which we have predetermined as not being an empty string – and if it does not pass, then we remove it.<br>Note: In shipped code I would hold a single reference to a wrapped non-jQuery object and not wrap it multiple times as is shown here when adding and removing event handlers. I left it in this example to not add extra noise to the task at hand.</p>
<p>Run that, and we are back to green!<br><img src="http://custardbelly.com/blog/images/tdd_js/part_viii_5.png" alt="Passing test on commit event form list-item-controller"></p>
<h2 id="user-test">User Test</h2>
<p>Let’s run the application and see if the issue is resolved:<br><img src="http://custardbelly.com/blog/images/tdd_js/part_viii_6.png" alt="Non-resolution of bug in live test"><br>I think that picture says it all…</p>
<p>The bug is still there because <code>save()</code> is not being called on the <code>list-item-controller</code>. In our test, we explicitly called it after a change to the model, but in the application itself it is not being invoked upon change to the model. </p>
<p>But before we start adding calls to <code>save()</code> in our code, let’s think about the steps to reproduce the bug… or at least the fourth step – <em>Click the Tab button to save to list</em>. The tab keystroke, internally to the <code>list-item-controller</code>, causes a blur to the input field. If we look at the code from <code>list-item-controller</code>, that <em>blur</em> event performs a change to state:</p>
<p><em>/script/controller/list-item-controller.js</em></p>
<pre><code>$(<span class="hljs-string">'input'</span>, <span class="hljs-keyword">this</span>.$editableView).on(<span class="hljs-string">'blur'</span>, (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(controller)</span> {</span>

  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(event)</span> {</span>

    controller.model.name = $(<span class="hljs-keyword">this</span>).val();

    controller.state = stateEnum.UNEDITABLE;

  };

}(<span class="hljs-keyword">this</span>)));
</code></pre><p>This snippet is taken from the event handler assignment in the <code>init()</code> function. When in edit mode of the <code>list-item-controller</code>, once focus is lost from the input field – which happens upon tab – the model is updated and state changed to non-edit mode. My first inkling is to put it here. It is true that, in doing so, it will pass and get rid of the bug… but the real commit of changes to the <code>list-item-controller</code> and its underlying model I feel lie in its change from edit mode to non-edit mode. I would argue that <code>save()</code> should be called from that occurrence. But before we add that to the code, let’s write up an expectation of that behavior.</p>
<h2 id="more-tests">More Tests</h2>
<p><em>‘WHAT?!? The bug was in our sights. We know how to get rid of it, and you want to write more tests?!?’</em><br>That is the voice in my head most of the time when I decide to go back to tests. It has lessened, and the swearing really has decreased. And when I finally do get around to passing tests, it goes away and is replaced with: <em>‘Nice job! You deserve a raise.. or at least an egg sandwich!’</em></p>
<p>Anyway, let’s get to <em>Egg Sandwich Status</em> and add another test to ensure that upon change to non-edit mode, if the model properties are not valid, that the item is not saved:</p>
<p><em>/test/jasmine/spec/feature/saveitem.spec.js</em></p>
<pre><code>async.it(<span class="hljs-string">'should not save an empty item upon change to non-edit mode'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(done)</span> {</span>

   <span class="hljs-keyword">var</span> listLength = listController.getItemList().itemLength();



  $(itemRenderer).on(<span class="hljs-string">'commit'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(event)</span> {</span>

    expect(listController.getItemList().itemLength()).toEqual(listLength - <span class="hljs-number">1</span>);

    done();

  });



  item.name = invalidName;

  itemRenderer.state = itemControllerFactory.state.UNEDITABLE;

});
</code></pre><p>We have already verified the expectation that a <code>list-item-controller</code> is entered into an <code>EDITABLE</code> state from our <em>additem.spec.js</em> tests, so we don’t need to test for that here – just know that setting the <code>list-item-controller</code> instance to an <code>UNEDITABLE</code> state will trigger it to go into non-edit mode.</p>
<p>Run that, and we get the timeout failure from that test:<br><img src="http://custardbelly.com/blog/images/tdd_js/part_viii_7.png" alt="Timeout failure on non-edit mode commit"></p>
<p>Good! Before you slap me… save that hand for modifying the <code>list-item-controller</code> to invoke the save() method from its state-change handler:</p>
<p><em>/script/controller/list-item-controller.js</em></p>
<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleStateChange</span><span class="hljs-params">(controller, event)</span> {</span>

  <span class="hljs-comment">// remove state-based item.</span>

  <span class="hljs-keyword">if</span>( typeof event.oldState !== <span class="hljs-string">'undefined'</span>) {

    <span class="hljs-keyword">if</span>(event.oldState === stateEnum.UNEDITABLE) {

      controller.<span class="hljs-variable">$uneditableView</span>.detach();

    }

    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(event.oldState === stateEnum.EDITABLE) {

      controller.<span class="hljs-variable">$editableView</span>.detach();

    }

  }

  <span class="hljs-comment">// append state-based item.</span>

  <span class="hljs-keyword">if</span>(event.newState === stateEnum.UNEDITABLE) {

    controller.parentView.append(controller.<span class="hljs-variable">$uneditableView</span>);

    controller.save();

  }

  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(event.newState === stateEnum.EDITABLE) {

    <span class="hljs-keyword">var</span> inputTimeout = setTimeout( <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>  {</span>

      clearTimeout(inputTimeout);

      $(<span class="hljs-string">'input'</span>, controller.<span class="hljs-variable">$editableView</span>).focus();

    }, <span class="hljs-number">100</span>);

    controller.parentView.append(controller.<span class="hljs-variable">$editableView</span>);

  }

}
</code></pre><p>One little addition. Now run the tests:<br><img src="http://custardbelly.com/blog/images/tdd_js/part_viii_8.png" alt="Passing tests on change to non-edit mode and save."></p>
<p><em>Hooray!</em> Now use that hand you were gonna slap me with and high-five yourself. Now look at yourself… you look silly. Run the application you crazy solo-high-fiver:<br><img src="http://custardbelly.com/blog/images/tdd_js/part_viii_9.png" alt="Application does not save empty item"></p>
<p>That picture doesn’t say much, but – if all has gone well – it conveys that we are no longer able to save an item to the list when nothing has been provided in the input field and we can close the bug.</p>
<h3 id="can-t-stop-won-t-stop">Can’t Stop. Won’t Stop</h3>
<p>I would normally stop there, but I do like to sew things up nicely and verify all expectations. Such as:</p>
<ol>
<li><p>Item controller view is not retained in list view if not valid:<br><em>/test/jasmine/spec/feature/saveitem.spec.js</em></p>
<p> async.it(&#39;should not add an empty item to list view upon change to non-edit mode&#39;, function(done) {</p>
<pre><code><span class="hljs-keyword">var</span> listViewLength = <span class="hljs-variable">$listView</span>.children().length;
</code></pre></li>
</ol>
<pre><code>  $(itemRenderer).<span class="hljs-keyword">on</span>(<span class="hljs-string">'commit'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(<span class="hljs-keyword">event</span>)</span> <span class="hljs-comment">{

    expect($listView.children().length).toEqual(listViewLength - 1);

    done();

  }</span>);</span>



  item.name = invalidName;

  itemRenderer.state = itemControllerFactory.state.UNEDITABLE;

});
</code></pre><ol>
<li><p>When going from edit to non-edit mode, valid items are retained:<br><em>/test/jasmine/spec/feature/saveitem.spec.js</em></p>
<p> async.it(&#39;should save a valid item upon change to non-edit mode&#39;, function(done) {</p>
<pre><code>var listLength = listController<span class="hljs-preprocessor">.getItemList</span>()<span class="hljs-preprocessor">.itemLength</span>()<span class="hljs-comment">;</span>
</code></pre></li>
</ol>
<pre><code>  $(itemRenderer).on(<span class="hljs-string">'commit'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(event)</span> {</span>

    expect(listController.getItemList().itemLength()).toEqual(listLength);

    done();

  });



  item.name = itemName;

  itemRenderer.state = itemControllerFactory.state.UNEDITABLE;

});



async.it(<span class="hljs-string">'should add a valid item to list view upon change to non-edit mode'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(done)</span> {</span>

   <span class="hljs-keyword">var</span> listViewLength = $listView.children.length;



  $(itemRenderer).on(<span class="hljs-string">'commit'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(event)</span> {</span>

    expect($listView.children().length).toEqual(listViewLength);

    done();

  });



  item.name = itemName;

  itemRenderer.state = itemControllerFactory.state.UNEDITABLE;

});
</code></pre><p>Those additional specs will pass with flying colors and without having to modify any more application code:<br><img src="http://custardbelly.com/blog/images/tdd_js/part_viii_10.png" alt="Finishing up all expectations for Save Item feature"></p>
<p>Tagged <strong>0.1.12</strong>: <a href="https://github.com/bustardcelly/grocery-ls/tree/0.1.12"><a href="https://github.com/bustardcelly/grocery-ls/tree/0.1.12">https://github.com/bustardcelly/grocery-ls/tree/0.1.12</a></a></p>
<h1 id="conclusion">Conclusion</h1>
<p>In this article we tested our way to closing a bug.</p>
<p>Just as we had done in the <a href="http://custardbelly.com/blog/2013/01/17/the-making-of-a-test-driven-grocery-list-application-in-js-part-vii/">previous article</a>, we adhered more closely to the principles of <strong>TDD</strong> and trudge along making things turn red before green – even when we found the reason and knew the resolution for the <em>Empty Item</em> bug. In doing so, we sort of verified and documented in test a <em>Save Item</em> feature. Now we know where to add or modify tests if the usability in committing an item to the list is changed in our requirements.</p>
<h2 id="todd-can-t-leave-well-enough-alone">Todd can’t leave well enough alone</h2>
<p>The application is pretty much ready to use as is to boot! There is just one more thing that is nagging me – persistence. No pun intended. We can create a list of all the items we need at the grocery store just fine, but if we close the browser window… oh-noes. It’s lost. I gotta fix that… next.</p>
<p>Cheers for sticking around!</p>
<p>—-</p>
<h1 id="link-dump">Link Dump</h1>
<h2 id="reference">Reference</h2>
<p><a href="http://tddjs.com/">Test-Driven JavaScript Development by Christian Johansen</a><br><a href="http://dannorth.net/introducing-bdd/">Introducing BDD by Dan North</a><br><a href="http://cumulative-hypotheses.org/2011/08/30/tdd-as-if-you-meant-it/">TDD as if you Meant it by Keith Braithwaite</a><br><a href="http://requirejs.org/">RequireJS</a><br><a href="https://github.com/amdjs/amdjs-api/wiki/AMD">AMD</a><br><a href="http://pivotal.github.com/jasmine/">Jasmine</a><br><a href="http://sinonjs.org/">Sinon</a><br><a href="https://github.com/derickbailey/jasmine.async">Jasmine.Async</a></p>
<h2 id="post-series">Post Series</h2>
<p><a href="https://github.com/bustardcelly/grocery-ls">grocery-ls github repo</a><br><a href="http://custardbelly.com/blog/2012/11/26/the-making-of-a-test-driven-grocery-list-application-in-javascript-part-i">Part I – Introduction</a><br><a href="http://custardbelly.com/blog/2012/11/26/the-making-of-a-test-driven-grocery-list-application-in-js-part-ii">Part II – Feature: Add Item</a><br><a href="http://custardbelly.com/blog/2012/12/06/the-making-of-a-test-driven-grocery-list-application-in-js-part-iii">Part III – Feature: Mark-Off Item</a><br><a href="http://custardbelly.com/blog/2012/12/17/the-making-of-a-test-driven-grocery-list-application-in-js-part-iv">Part IV – Feature: List-Item-Controller</a><br><a href="http://custardbelly.com/blog/2012/12/31/the-making-of-a-test-driven-grocery-list-application-in-js-part-v/">Part V – Feature: List-Controller Refactoring</a><br><a href="http://custardbelly.com/blog/2013/01/08/the-making-of-a-test-driven-grocery-list-application-in-js-part-vi/">Part VI – Back to Passing</a><br><a href="http://custardbelly.com/blog/2013/01/17/the-making-of-a-test-driven-grocery-list-application-in-js-part-vii/">Part VII – Remove Item</a><br><a href="http://custardbelly.com/blog/2013/01/22/the-making-of-a-test-driven-grocery-list-application-part-viii/">Part VIII – Bug Fixing</a><br><a href="http://custardbelly.com/blog/2013/02/15/the-making-of-a-test-driven-grocery-list-application-in-js-part-ix/">Part IX – Persistence</a><br><a href="http://custardbelly.com/blog/2013/03/06/the-making-of-a-test-driven-grocery-list-application-in-js-part-x/">Part X – It Lives!</a></p>
<p>Posted in <a href="http://custardbelly.com/blog/category/amd/">AMD</a>, <a href="http://custardbelly.com/blog/category/javascript/">JavaScript</a>, <a href="http://custardbelly.com/blog/category/requirejs/">RequireJS</a>, <a href="http://custardbelly.com/blog/category/grocery-ls/">grocery-ls</a>, <a href="http://custardbelly.com/blog/category/jasmine/">jasmine</a>, <a href="http://custardbelly.com/blog/category/unit-testing/">unit-testing</a>.</p>
]]></description><link>http://custardbelly.com/blog/blog-posts/2013/01/22/the-making-of-a-test-driven-grocery-list-application-part-viii/index.html</link><guid isPermaLink="true">http://custardbelly.com/blog/blog-posts/2013/01/22/the-making-of-a-test-driven-grocery-list-application-part-viii/index.html</guid><dc:creator><![CDATA[Todd Anderson]]></dc:creator><pubDate>Invalid Date</pubDate></item><item><title><![CDATA[The Making of a Test-Driven Grocery List Application in JS: Part VII]]></title><description><![CDATA[<p><em>This is the seventh installment in a series of building a Test-Driven Grocery List application using <a href="http://pivotal.github.com/jasmine/">Jasmine</a> and <a href="http://requirejs.org">RequireJS</a>. To learn more about the intent and general concept of the series please visit <a href="http://custardbelly.com/blog/2012/11/26/the-making-of-a-test-driven-grocery-list-application-in-javascript-part-i/">The Making of a Test-Driven Grocery List Application in JavaScript: Part I</a></em><br>—</p>
<h2 id="introduction">Introduction</h2>
<p>In the <a href="http://custardbelly.com/blog/2013/01/08/the-making-of-a-test-driven-grocery-list-application-in-js-part-vi/">previous article</a> we resolved tests for the <em>Mark Off Item</em> feature that were left in a failing state after refactoring the list-controller. The test are all green now and the application usable, but we are not done with implementing the required features. In this article I plan to address another – the <em>Remove Item</em> feature.</p>
<p>Before we begin, let’s drum up a quick story and scenario(s) for the <em>Remove Item</em> feature. I know the feature seems a little simple – just remove an item from the list – and going through and adding stories and scenarios may appear like adding complexity to the situation, but since I have begun to incorporate such a workflow, I feel like it actually gives me more time to think about not only the necessity of the feature but the design; in result, <em>hopefully*</em> cutting down on the complexity of the code.</p>
<p><em>// story</em><br><strong>Feature:</strong> remove item from grocery list</p>
<p><strong>In order to</strong> not buy an item previous on a grocery list<br><strong>As a</strong> grocery shopper<br><strong>I want to</strong> remove the existence of the item on the grocery list<br>—</p>
<p>That may be worded rather harshly, but I shop angry. It’s how I keep the cantelope in check. <em>‘I see you looking at me, you lousy melon.’</em> All kidding aside, I tend to be a little more terse in describing stories so as not to mince words (no pun intended) and leave as little vagueness as possible. Sometimes, I’ll admit, there is no avoiding having the story lead to a lot of assumptions – but that is where scenarios come in.</p>
<p><em>// spec</em><br><strong>Scenario 1:</strong> Item removed from grocery list<br><strong>Given</strong> an item has been added to the list<br><strong>When</strong> a user requests to remove the item<br><strong>Then</strong> the list decreases in size by one</p>
<p>Hmm. Pretty straight forward. Well, it all seems rather easy going to implement this feature. Looks like it might be a short blog post, for once; we’ll see how much rambling I can pack in. At least we have something to show somebody who doesn’t want/need to read code when they ask, <em>‘But, what does it do?’</em>.</p>
<h2 id="tests">Tests</h2>
<p>As always, before we get into adding code to the components of the application to implement the new feature, let’s get some failing tests to pass. We’ll start of with defining a new spec suite for the <em>Remove Item</em> feature, with the setup (<code>beforeEach()</code>) being the <strong>Given</strong> describe above:</p>
<p><em>/test/jasmine/spec/feature/removeitem.spec.js</em></p>
<pre><code>define([<span class="hljs-string">'jquery'</span>, <span class="hljs-string">'script/controller/list-controller'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">($, listController)</span> {</span>



  describe(<span class="hljs-string">'Remove item'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>



    <span class="hljs-keyword">var</span> $listView = $(<span class="hljs-string">'&lt;ul/&gt;'</span>),

        groceryItem;



    beforeEach( <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

      listController.setView($listView);

      groceryItem = listController.createNewItem();

    });



    it(<span class="hljs-string">'should remove existing item from the collection'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

      expect(<span class="hljs-literal">false</span>).toEqual(<span class="hljs-literal">true</span>);

    });



    afterEach( <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

      groceryItem = <span class="hljs-literal">undefined</span>;

    });



  });



});
</code></pre><p>Don’t mind the expectation declared in the spec. <a href="http://pivotal.github.com/jasmine/">Jasmine</a> does not check empty specs and automatically fail them. In fact, if we ran it without any expectations defined, it would be all green. So, I usually drop a failing expectation in quickly when creating new specs in cases where someone/thing comes and interrupts me, I know where to pick back up when i come back. It’s habit. Maybe a little paranoia. Don’t know if it’s right or wrong <img src="http://custardbelly.com/blog/wp-includes/images/smilies/icon_smile.gif" alt=":)">  </p>
<p>If you have been following along in the articles of this series, I typically do my implementation in the tests then move them to their respective modules. It’s a nice workflow for me, and in most cases I feel it gets me more focused on design. In this case, I am just going to declare my expectations, see them fail and move over to implementing the code right in the module, running the spec runner as we go until we see green.  </p>
<p>Anyway, first on the agenda is to verify that the Remove API from <code>list-controller</code> is expected to remove the item from the underlying collection of grocery list items:</p>
<p><em>/test/jasmine/spec/feature/removeitem.spec.js</em></p>
<pre><code><span class="hljs-function">it(<span class="hljs-string">'should remove existing item from the collection'</span>, <span class="hljs-function">function()</span> {

  var collection = listController.<span class="hljs-function">getItemList()</span>,

      removedItem;



  removedItem = listController.<span class="hljs-function">removeItem(groceryItem)</span>;



  <span class="hljs-function">expect(removedItem)</span>.<span class="hljs-function">toBe(groceryItem)</span>;

  <span class="hljs-function">expect(collection.<span class="hljs-function">getItemIndex(groceryItem)</span>)</span>.<span class="hljs-function">toBe(-<span class="hljs-number">1</span>)</span>;

})</span>;
</code></pre><p>Add the new spec to the spec runner:<br><em>/test/jasmine/specrunner.html</em></p>
<pre><code><span class="hljs-keyword">require</span>( [<span class="hljs-string">'spec/feature/additem.spec.js'</span>, <span class="hljs-string">'spec/feature/markitem.spec.js'</span>, <span class="hljs-string">'spec/feature/removeitem.spec.js'</span>,

          <span class="hljs-string">'spec/list-controller.spec.js'</span>, <span class="hljs-string">'spec/list-item-controller.spec.js'</span>, <span class="hljs-string">'spec/grocery-ls-item.spec.js'</span>,

          <span class="hljs-string">'spec/collection.spec.js'</span>], <span class="hljs-keyword">function</span>() {



  var jasmineEnv = jasmine.getEnv(),

      <span class="hljs-keyword">...</span>

  jasmineEnv.execute();



});
</code></pre><p>Run that, and we have a big honking failure:<br><img src="http://custardbelly.com/blog/images/tdd_js/part_vii_1.png" alt="Failing remove spec on collection."><br>Good!</p>
<p>In looking at the expectations of the <code>removeItem()</code> method on <code>list-controller</code>, we are expecting that the item is removed from the collection and returned on invocation. Let’s implement <code>removeItem</code> on <code>list-controller</code> with this understanding:</p>
<p><em>/script/controller/list-controller.js</em></p>
<pre><code>listController = {

  $view: <span class="hljs-literal">undefined</span>,

  getItemList: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

    <span class="hljs-keyword">return</span> collection;

  },

  getRendererFromItem: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(item)</span> {</span>

    <span class="hljs-keyword">var</span> i = rendererList.itemLength();

    <span class="hljs-keyword">while</span>( --i &gt; -<span class="hljs-number">1</span> ) {

      <span class="hljs-keyword">if</span>(rendererList.getItemAt(i).model === item) {

        <span class="hljs-keyword">return</span> rendererList.getItemAt(i);

      }

      <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;

    }

  },

  createNewItem: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

    <span class="hljs-keyword">var</span> model = modelFactory.create();

    collection.addItem(model);

    <span class="hljs-keyword">return</span> model;

  },

  removeItem: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(item)</span> {</span>

    <span class="hljs-keyword">return</span> collection.removeItem(item);

  },

  setView: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(view)</span> {</span>

    <span class="hljs-keyword">this</span>.$view = (view <span class="hljs-keyword">instanceof</span> $) ? view : $(view);

  }

};
</code></pre><p>Run it, and we pass!<br><img src="http://custardbelly.com/blog/images/tdd_js/part_vii_2.png" alt="Passing tests on remove from collection."><br>Well, that was sort of easy and anti-climatic. No drama. A little boring, if I may say so.</p>
<p>But… there’s more! The <code>list-controller</code> isn’t just some dumb facade to the underlying <strong>Grocery List</strong> collection – it also manages the associated renderers to the <code>grocery-ls-item</code> models. Let’s get back to our tests and add a new spec:</p>
<p><em>/test/jasmine/spec/feature/removeitem.spec.js</em></p>
<pre><code><span class="hljs-function">it(<span class="hljs-string">'should remove item renderer from view'</span>, <span class="hljs-function">function()</span> {

  listController.<span class="hljs-function">removeItem(groceryItem)</span>;



  <span class="hljs-function">expect($listView.<span class="hljs-function">children()</span>.length)</span>.<span class="hljs-function">toEqual(<span class="hljs-number">0</span>)</span>;

})</span>;
</code></pre><p>Just as we had done for the <em>Add Item</em> feature specification, we are inspecting the view reference held by list-controller that is updated based on change to the model. In this case, we are expecting that the list item renderer is removed upon <code>removeItem()</code> as well.</p>
<p>Run that, and failure!<br><img src="http://custardbelly.com/blog/images/tdd_js/part_vii_3.png" alt="Failure of test on removl of item views."><br>It might be important to note the actual print out from the failing expectation. It says that the length of children on the list view is 2 – that is because we now have 2 specs that are defining the expectations of <code>removeItem()</code> that are failing to remove the item view from the list.</p>
<p>Let’s switch over the list-controller and get this sorted and back to green. But before we do, let’s think about the relationship of the <code>list-controller</code> and its underlying collection. The <code>list-controller</code> responds to collection event for <code>EventKindEnum.ADD</code> in order to modify the view. So, we will respond to <code>EventKindEnum.REMOVE</code> accordingly to modify the view on removal of an item as well, instead of adding more logic to the <code>removeItem()</code> method on <code>list-controller</code>:</p>
<p><em>/script/controller/list-controller.js</em></p>
<pre><code><span class="hljs-variable">$collection</span>.on(<span class="hljs-string">'collection-change'</span>, function(<span class="hljs-keyword">event</span>) {

  var model, itemController, <span class="hljs-variable">$itemView</span>;

  <span class="hljs-keyword">switch</span>( <span class="hljs-keyword">event</span>.kind ) {

    <span class="hljs-keyword">case</span> EventKindEnum.ADD:

      <span class="hljs-variable">$itemView</span> = <span class="hljs-variable">$(</span><span class="hljs-string">'&lt;li&gt;'</span>);

      model = <span class="hljs-keyword">event</span>.items.shift();

      itemController = itemControllerFactory.create(<span class="hljs-variable">$itemView</span>, model);



      <span class="hljs-variable">$itemView</span>.appendTo(listController.<span class="hljs-variable">$view</span>);

      rendererList.addItem(itemController);

      itemController.state = itemControllerFactory.state.EDITABLE;

      <span class="hljs-keyword">break</span>;

    <span class="hljs-keyword">case</span> EventKindEnum.REMOVE:

      model = <span class="hljs-keyword">event</span>.items.shift();

      itemController = listController.getRendererFromItem(model);



      <span class="hljs-keyword">if</span>(itemController) {

        <span class="hljs-variable">$itemView</span> = itemController.parentView;

        <span class="hljs-variable">$itemView</span>.remove();

        rendererList.removeItem(itemController);

      }

      <span class="hljs-keyword">break</span>;

    <span class="hljs-keyword">case</span> EventKindEnum.RESET:

      <span class="hljs-keyword">break</span>;

  }

});
</code></pre><p>In the <code>EventKindEnum.REMOVE</code> case, we are grabbing the model provided on the event, using it to access the associated <code>list-item-controller</code> instance, and – if defined – removing the list item renderer view from the DOM and the controller from the renderer collection.</p>
<p>Run that, and we are back to green!<br><img src="http://custardbelly.com/blog/images/tdd_js/part_vii_4.png" alt="Passing tests on removal of item from view."></p>
<p>Tagged <strong>0.1.10</strong>: <a href="https://github.com/bustardcelly/grocery-ls/tree/0.1.10"><a href="https://github.com/bustardcelly/grocery-ls/tree/0.1.10">https://github.com/bustardcelly/grocery-ls/tree/0.1.10</a></a></p>
<h2 id="back-to-reality">Back to Reality</h2>
<p>We’ve got test for the removal of a grocery list item working. We are currently feature complete. Let’s ship it! But hold up, does the <strong>Grocery List</strong> application – the thing we are actually building for someone like myself to Use in real life – actually use the new Remove API. We defined a business feature that was a requirement to have, and met that expectation, but we really didn’t address how an item is removed, or under what circumstances…</p>
<p>Without getting to crazy on discussing how to handle swipe gestures and implementing press-and-hold menu actions, let’s just start with saying that the <code>list-item-controller</code> will dispatch a new event – <code>remove</code>. How we decide on the usability of an item being deleted could easily be another whole discussion on User Experience. For now, we want to verify that when a <code>list-item-controller</code> dispatches a <code>remove</code> event, that it is handled properly.</p>
<h3 id="tests">Tests</h3>
<p>We’ll start with the specs for the <code>list-controller</code>. We are not going to be adding any new specs to the <em>Remove Item</em> feature to accomplish the implementation of <code>list-item-controller</code> notifying of a <code>remove</code> event; it seems a little odd to me as well, but we have already established that the <em>Remove</em> API performs as expected. We need to verify that the <code>list-controller</code> uses that API in response to a <code>list-item-controller</code> – less of a feature and more of an integration point.</p>
<p><em>/test/jasmine/spec/list-controller.spec.js</em></p>
<pre><code><span class="hljs-function">describe(<span class="hljs-string">'list-item-controller remove event response'</span>, <span class="hljs-function">function()</span> {



  <span class="hljs-function">it(<span class="hljs-string">'should invoke list-controller:removeItem()'</span>, <span class="hljs-function">function()</span> {

    var newItem = listController.<span class="hljs-function">createNewItem()</span>,

        itemRenderer = listController.<span class="hljs-function">getRendererFromItem(newItem)</span>;



    <span class="hljs-function">spyOn(listController, <span class="hljs-string">'removeItem'</span>)</span>;

    $(itemRenderer)</span>.<span class="hljs-function">trigger(<span class="hljs-string">'remove'</span>)</span>;

    <span class="hljs-function">expect(listController.removeItem)</span>.<span class="hljs-function">toHaveBeenCalledWith(newItem)</span>;

  })</span>;



});
</code></pre><p>In this spec, we set up a <a href="https://github.com/pivotal/jasmine/wiki/Spies">spy</a> to verify that the <code>removeItem()</code> method is invoked upon dispatch of <code>remove</code> from a <code>list-item-controller</code> instance.</p>
<p>Run that and we are back to red, with a message letting us know that <code>removeItem()</code> was never called.<br><img src="http://custardbelly.com/blog/images/tdd_js/part_vii_5.png" alt="Failing implementation of remove event."><br>Good. Let’s open up <code>list-controller</code> and implement a <code>remove</code> event response:</p>
<p>/script/controller/list-controller.js</p>
<pre><code><span class="hljs-variable">$collection</span>.on(<span class="hljs-string">'collection-change'</span>, function(<span class="hljs-keyword">event</span>) {

  var model, itemController, <span class="hljs-variable">$itemView</span>;

  <span class="hljs-keyword">switch</span>( <span class="hljs-keyword">event</span>.kind ) {

    <span class="hljs-keyword">case</span> EventKindEnum.ADD:

      <span class="hljs-variable">$itemView</span> = <span class="hljs-variable">$(</span><span class="hljs-string">'&lt;li&gt;'</span>);

      model = <span class="hljs-keyword">event</span>.items.shift();

      itemController = itemControllerFactory.create(<span class="hljs-variable">$itemView</span>, model);



      <span class="hljs-variable">$itemView</span>.appendTo(listController.<span class="hljs-variable">$view</span>);

      rendererList.addItem(itemController);

      itemController.state = itemControllerFactory.state.EDITABLE;

      <span class="hljs-variable">$(</span>itemController).on(<span class="hljs-string">'remove'</span>, function(<span class="hljs-keyword">event</span>) {

        listController.removeItem(model);

      });

      <span class="hljs-keyword">break</span>;

    <span class="hljs-keyword">case</span> EventKindEnum.REMOVE:

      model = <span class="hljs-keyword">event</span>.items.shift();

      itemController = listController.getRendererFromItem(model);



      <span class="hljs-keyword">if</span>(itemController) {

        <span class="hljs-variable">$itemView</span> = itemController.parentView;

        <span class="hljs-variable">$itemView</span>.remove();

        itemController.dispose();

        <span class="hljs-variable">$(</span>itemController).off(<span class="hljs-string">'remove'</span>);

        rendererList.removeItem(itemController);

      }

      <span class="hljs-keyword">break</span>;

    <span class="hljs-keyword">case</span> EventKindEnum.RESET:

      <span class="hljs-keyword">break</span>;

  }

});
</code></pre><p>We added the remove handler delegation in the <code>ADD</code> case when the collection changes, along with the other implementation of item renderer establishment. And, for good measure and memory management, we are sure to remove the event handler in the <code>REMOVE</code> case from the collection change, as well.</p>
<p>Run the test now and we are back to green!<br><img src="http://custardbelly.com/blog/images/tdd_js/part_vii_6.png" alt="Passing remove event response."></p>
<h3 id="list-item-controller-modification">list-item-controller Modification</h3>
<p>That’s great, but we are still glazing over the usability aspect: <em>How does a User delete an item?</em></p>
<p>Again, we could go into a lengthy discussion of UX and code implementations, but to save yourself from scrolling just to read me ramble off topic, we’ll keep it simple: <em>add a delete button</em>! I don’t know why I got excited there. I’ll show the implementation in piecemeal just to see how it all comes together. First we’ll start with the markup we declared for the <code>list-item-controller</code> views:</p>
<p><em>/script/controller/list-item-controller.js</em></p>
<pre><code>uneditableItemFragment  = <span class="hljs-comment">'<span class="hljs-xmlDocTag">&lt;p class="grocery-item"&gt;</span>' +</span>

                                             <span class="hljs-comment">'<span class="hljs-xmlDocTag">&lt;span class="grocery-item-label" /&gt;</span>' +</span>

                                             <span class="hljs-comment">'<span class="hljs-xmlDocTag">&lt;button class="delete-item-button"&gt;</span>delete<span class="hljs-xmlDocTag">&lt;/button&gt;</span>' +</span>

                                           <span class="hljs-comment">'<span class="hljs-xmlDocTag">&lt;/p&gt;</span>',</span>

editableItemFragment    = <span class="hljs-comment">'<span class="hljs-xmlDocTag">&lt;p class="editable-grocery-item"&gt;</span>' +</span>

                                            <span class="hljs-comment">'<span class="hljs-xmlDocTag">&lt;input name="editableItem" ' +

                                              'class="editable-item" placeholder="Enter item name..."&gt;</span>' +</span>

                                            <span class="hljs-comment">'<span class="hljs-xmlDocTag">&lt;/input&gt;</span>' +</span>

                                         <span class="hljs-comment">'<span class="hljs-xmlDocTag">&lt;/p&gt;</span>'</span>
</code></pre><p>The <code>uneditableItemFragment</code> markup has changed slightly to support a label and a button. It was previously just a <code>p</code> element all by its lonesome, but with several references for modification and event <code>click</code> event handling. We’ll need to update those, as well as add another event handler for the <code>button</code> element:</p>
<p><em>/script/controller/list-item-controller.js</em></p>
<pre><code>init: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

  <span class="hljs-keyword">this</span>.$editableView = $(editableItemFragment);

  <span class="hljs-keyword">this</span>.$uneditableView = $(uneditableItemFragment);



  <span class="hljs-comment">// view handlers.</span>

  $(<span class="hljs-string">'span.grocery-item-label'</span>, <span class="hljs-keyword">this</span>.$uneditableView).on(<span class="hljs-string">'click'</span>, (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(controller)</span> {</span>

    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(event)</span> {</span>

      <span class="hljs-keyword">var</span> toggled = $(<span class="hljs-keyword">this</span>).css(<span class="hljs-string">'text-decoration'</span>) === <span class="hljs-string">'line-through'</span>;

      controller.model.marked = !toggled;

    };

  }(<span class="hljs-keyword">this</span>)));

  $(<span class="hljs-string">'button.delete-item-button'</span>, <span class="hljs-keyword">this</span>.$uneditableView).on(<span class="hljs-string">'click'</span>, (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(controller)</span> {</span>

    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(event)</span> {</span>

      $(controller).trigger(createRemoveEvent(controller));

    };

  }(<span class="hljs-keyword">this</span>)));

  ...

}
</code></pre><p>As seen previously, we are using <a href="http://benalman.com/news/2010/11/immediately-invoked-function-expression/">IIFE</a>s here as a factory method in order to pass in a reference to the <code>list-item-controller</code> instance instead of declaring the old:</p>
<pre><code><span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
</code></pre><p>and then passing <code>self</code> around which always makes me cringe. In any event (no pun intended), we have transferred the <em>click</em> handling previously assigned to the <code>p</code> element over the <code>span</code> element in order to support the usability of marking off an item. As well, we added handling of delete <code>button</code> <em>click</em> to trigger a new event:</p>
<p><em>/script/controller/list-item-controller.js</em></p>
<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createRemoveEvent</span><span class="hljs-params">(controller)</span> {</span>

  <span class="hljs-keyword">var</span> event = $.Event(<span class="hljs-string">'remove'</span>);

  event.controller = controller;

  <span class="hljs-keyword">return</span> event;

}
</code></pre><p>Pretty straight forward in how we have create factory methods for our <a href="http://jquery.org">jQuery</a> events previously in this series. Next we need to modify the references that respond to model changes, such as the <code>marked</code> property value:</p>
<p><em>/script/controller/list-item-controller.js</em></p>
<pre><code>function handlePropertyChange(controller, <span class="hljs-keyword">event</span>) {

  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">event</span>.property === <span class="hljs-string">"name"</span>) {

    <span class="hljs-comment">// update view based on model change.</span>

    <span class="hljs-variable">$(</span><span class="hljs-string">'input'</span>, controller.<span class="hljs-variable">$editableView</span>).val(controller.model.name);

    <span class="hljs-variable">$(</span><span class="hljs-string">'span.grocery-item-label'</span>, controller.<span class="hljs-variable">$uneditableView</span>).<span class="hljs-keyword">text</span>(<span class="hljs-keyword">event</span>.newValue);

  }

  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">event</span>.property === <span class="hljs-string">"marked"</span>) {

    <span class="hljs-comment">// update view based on model change.</span>

    <span class="hljs-variable">$(</span><span class="hljs-string">'span.grocery-item-label'</span>, controller.<span class="hljs-variable">$uneditableView</span>)

        .css(<span class="hljs-string">'text-decoration'</span>, ( <span class="hljs-keyword">event</span>.newValue ) ? <span class="hljs-string">'line-through'</span> : <span class="hljs-string">'none'</span>);

  }

}
</code></pre><p>Alright. That should just about do it. Now you may be saying to yourself, <em>‘Why haven’t we modified any tests in order to support this change in UI and event handling?’</em> To which I will respond, <em>‘Stop bringing that up!’</em> In all seriousness, we perhaps should be writing tests to support these changes, however those will get pretty fine grained on the UI design aspect of the application. As you can see, it is constantly changing at this time and we are more concerned with the logical points of how the <strong>Grocery List</strong> application should behave. </p>
<p>Like with most of my code, future me may look back and shake his head at past me for such a statement – but for right now, present me will live with it <img src="http://custardbelly.com/blog/wp-includes/images/smilies/icon_smile.gif" alt=":)"></p>
<h3 id="using-the-grocery-list-application">Using the Grocery List Application</h3>
<p>Let’s actually <em>run</em> the application and use it. We spend all this time making our tests turn red and green, we barely get to use what we are building.<br><img src="http://custardbelly.com/blog/images/tdd_js/part_vii_7.png" alt="Grocery list application"></p>
<p>Oh my… that is ugly to look at. But it works! And it’s backed by tests!</p>
<p>Because I can’t leave well enough alone, I added some quick styling just to make it a little more pleasant on the eyes. I am not designer, so it might not be any more pleasant to you <img src="http://custardbelly.com/blog/wp-includes/images/smilies/icon_smile.gif" alt=":)"> I won’t go into the styling of the application as that could be a whole ‘nother article and discussion of box model, but feel free to mess around with the styling on your own…<br><img src="http://custardbelly.com/blog/images/tdd_js/part_vii_8.png" alt="Prettier Grocery List application"></p>
<p>Tagged <strong>0.1.11</strong>: <a href="https://github.com/bustardcelly/grocery-ls/tree/0.1.11"><a href="https://github.com/bustardcelly/grocery-ls/tree/0.1.11">https://github.com/bustardcelly/grocery-ls/tree/0.1.11</a></a></p>
<h2 id="conclusion">Conclusion</h2>
<p>In this article of the series, we took more of a traditional approach to <a href="http://en.wikipedia.org/wiki/Test-driven_development">TDD</a> and went along making things turn red before they turn green, one spec at a time, and all the while implementing the <em>Remove Item</em> feature. </p>
<p>The <strong>Grocery List</strong> application is also coming along pretty nicely and, as always, is easy and ready to use. But I can’t leave well enough alone and there are a few more items on my list (no pun intended) that I wish to address before ending this series, most importantly persistence. Our grocery list only last within the session of the page – once closed, our list is gone. We’ll get to that, but there might be some other things to address beforehand.</p>
<p>Cheers for sticking around!</p>
<p>—</p>
<h1 id="link-dump">Link Dump</h1>
<h2 id="reference">Reference</h2>
<p><a href="http://tddjs.com/">Test-Driven JavaScript Development by Christian Johansen</a><br><a href="http://dannorth.net/introducing-bdd/">Introducing BDD by Dan North</a><br><a href="http://requirejs.org/">RequireJS</a><br><a href="https://github.com/amdjs/amdjs-api/wiki/AMD">AMD</a><br><a href="http://pivotal.github.com/jasmine/">Jasmine</a><br><a href="http://sinonjs.org/">Sinon</a><br><a href="https://github.com/derickbailey/jasmine.async">Jasmine.Async</a></p>
<h2 id="post-series">Post Series</h2>
<p><a href="https://github.com/bustardcelly/grocery-ls">grocery-ls github repo</a><br><a href="http://custardbelly.com/blog/2012/11/26/the-making-of-a-test-driven-grocery-list-application-in-javascript-part-i">Part I – Introduction</a><br><a href="http://custardbelly.com/blog/2012/11/26/the-making-of-a-test-driven-grocery-list-application-in-js-part-ii">Part II – Feature: Add Item</a><br><a href="http://custardbelly.com/blog/2012/12/06/the-making-of-a-test-driven-grocery-list-application-in-js-part-iii">Part III – Feature: Mark-Off Item</a><br><a href="http://custardbelly.com/blog/2012/12/17/the-making-of-a-test-driven-grocery-list-application-in-js-part-iv">Part IV – Feature: List-Item-Controller</a><br><a href="http://custardbelly.com/blog/2012/12/31/the-making-of-a-test-driven-grocery-list-application-in-js-part-v/">Part V – Feature: List-Controller Refactoring</a><br><a href="http://custardbelly.com/blog/2013/01/08/the-making-of-a-test-driven-grocery-list-application-in-js-part-vi/">Part VI – Back to Passing</a><br><a href="http://custardbelly.com/blog/2013/01/17/the-making-of-a-test-driven-grocery-list-application-in-js-part-vii/">Part VII – Remove Item</a><br><a href="http://custardbelly.com/blog/2013/01/22/the-making-of-a-test-driven-grocery-list-application-part-viii/">Part VIII – Bug Fixing</a><br><a href="http://custardbelly.com/blog/2013/02/15/the-making-of-a-test-driven-grocery-list-application-in-js-part-ix/">Part IX – Persistence</a><br><a href="http://custardbelly.com/blog/2013/03/06/the-making-of-a-test-driven-grocery-list-application-in-js-part-x/">Part X – It Lives!</a></p>
<p>Posted in <a href="http://custardbelly.com/blog/category/amd/">AMD</a>, <a href="http://custardbelly.com/blog/category/javascript/">JavaScript</a>, <a href="http://custardbelly.com/blog/category/requirejs/">RequireJS</a>, <a href="http://custardbelly.com/blog/category/grocery-ls/">grocery-ls</a>, <a href="http://custardbelly.com/blog/category/jasmine/">jasmine</a>, <a href="http://custardbelly.com/blog/category/unit-testing/">unit-testing</a>.</p>
]]></description><link>http://custardbelly.com/blog/blog-posts/2013/01/17/the-making-of-a-test-driven-grocery-list-application-in-js-part-vii/index.html</link><guid isPermaLink="true">http://custardbelly.com/blog/blog-posts/2013/01/17/the-making-of-a-test-driven-grocery-list-application-in-js-part-vii/index.html</guid><dc:creator><![CDATA[Todd Anderson]]></dc:creator><pubDate>Invalid Date</pubDate></item><item><title><![CDATA[The Making of a Test-Driven Grocery List Application in JS: Part VI]]></title><description><![CDATA[<p><em>This is the sixth installment in a series of building a Test-Driven Grocery List application using <a href="http://pivotal.github.com/jasmine/">Jasmine</a> and <a href="http://requirejs.org">RequireJS</a>. To learn more about the intent and general concept of the series please visit <a href="http://custardbelly.com/blog/2012/11/26/the-making-of-a-test-driven-grocery-list-application-in-javascript-part-i/">The Making of a Test-Driven Grocery List Application in JavaScript: Part I</a></em><br>—</p>
<h2 id="introduction">Introduction</h2>
<p>We left the <a href="http://custardbelly.com/blog/2012/12/31/the-making-of-a-test-driven-grocery-list-application-in-js-part-v/">previous post</a> with failing tests! </p>
<p>I don’t necessarily condone leaving a master branch in such a state, so don’t give my name to your managers <img src="http://custardbelly.com/blog/wp-includes/images/smilies/icon_smile.gif" alt=":)"> I, however, have no problem with leaving a feature or developer branch at the end of the day with failing tests – within reason. As long as the errors are from unimplemented behavior and the branch is not being monitored by some CI server feeding reports to your client(s), I see no problem. Sometimes I will write out the tests I plan to resolve the following day at 5:30 just so I can get a refresher the next morning as to the task at hand.</p>
<p>In the article I plan to get your tests all green again by modifying the <em>Mark Off Item</em> tests and possibly add a few new features.</p>
<h2 id="mark-off-item-feature">Mark Off Item Feature</h2>
<p>Way back in the <a href="http://custardbelly.com/blog/2012/12/06/the-making-of-a-test-driven-grocery-list-application-in-js-part-iii/">third article in this series</a>, we wrote up a story and some feature specs around the usability of marking off an item already existant in the list of item of the <strong>Grocery List</strong> application. In getting this feature implemented, we added a basic mark-item API to the <code>list-controller</code>, which allowed us to pass in a <code>grocery-ls-item</code> model to the <code>list-controller</code> which would then modify its state. </p>
<p>In the previous couple posts, we have refactored <code>list-controller</code> to not be responsible for item state and to respond to changes on a collection model – this is what led us to failing tests. We still want to keep the <em>Mark Off Item</em> feature, but instead of having specs that tested the mark-item API of the <code>list-controller</code>, we’re going to change the specs to verify that the <code>grocery-ls-item</code> model that is being modified updates its state and is retained in the collection held by the <code>list-controller</code>.</p>
<h3 id="tests">Tests</h3>
<p>When I start creating the tests, I take some time in thinking about the <strong>Given</strong>s. Typically, the <strong>Given</strong>s are what make up the <code>beforeEach()</code> setup of a spec suite, but they can also lead to address some design concerns about components involved in getting the tests to pass. Such is the case in modifying our <em>Mark Off Item</em> feature specs.</p>
<p>We are not necessarily going to test the UI changes related to the action of marking off an item from the <strong>Grocery List</strong>. We could, but it is more important to me to test that the <code>grocery-ls-item</code> model that holds that state value of being marked is properly retaining that value and accessible from not only the collection, but from the associated <code>list-item-controller</code> instance, as well – after all, it is the <code>list-item-controller</code> that is responsible for responding to changes to an item being marked-off; i want to ensure that, in the very least, it has the opportunity, not actually what it does with the opportunity. </p>
<p>That statement may sound foolish, i’ll admit. If it was an expectation that the action of marking off an item was to trigger a reaction that defined another feature specification, then certainly I would write up tests accordingly. But as it stands, it changes a style on the <code>list-item-controller</code> view. I am not so concerned with that implementation at the moment – if it becomes a real business issue and it was a requirement to have the text shown with a strike-through, then yes.</p>
<p>Let’s start with the setup and teardown for the <em>Mark Off Item</em> feature specs:</p>
<p><em>/test/jasmine/spec/feature/markitem.spec.js</em></p>
<pre><code>define([<span class="hljs-string">'jquery'</span>, <span class="hljs-string">'script/controller/list-controller'</span>, <span class="hljs-string">'script/controller/list-item-controller'</span>],

        <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">($, listController, itemControllerFactory)</span> {</span>



  describe(<span class="hljs-string">'Existing item is marked-off'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>



    <span class="hljs-keyword">var</span> item,

        itemController,

        getRendererStub;



    beforeEach( <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

      item = listController.createNewItem();



      itemController = itemControllerFactory.create($(<span class="hljs-string">'&lt;li/&gt;'</span>), item);

      getRendererStub = sinon.stub();

      getRendererStub.returns(itemController);

      listController.getRendererFromItem = getRendererStub;

    });



    afterEach( <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

      item = <span class="hljs-literal">undefined</span>;

      itemController = <span class="hljs-literal">undefined</span>;

      getRendererStub = <span class="hljs-literal">undefined</span>;

    });



  });



});
</code></pre><p>In the <code>beforeEach()</code>, we’ve stubbed out a new method on <code>list-controller</code> that allows us to access the associated <code>list-item-controller</code> with a model: <code>getRendererFromItem()</code>.</p>
<p>If you remember <a href="http://custardbelly.com/blog/2012/12/31/the-making-of-a-test-driven-grocery-list-application-in-js-part-v/">from the last article</a>, we also did some stubbing of methods before moving to implementation on <code>list-controller</code>. We are doing the same here and using the <a href="http://sinonjs.org">SinonJS</a> <code>stub</code> API to stub a method that currently does not exist on <code>list-controller</code>. To do so, and not have exceptions thrown in your tests regarding the existence of the method on the object being stubbed, you create an anonymous stub and assign it to the target object:</p>
<p><em>/test/jasmine/spec/feature/markitem.spec.js</em></p>
<pre><code>getRendererStub = sinon<span class="hljs-preprocessor">.stub</span>()<span class="hljs-comment">;</span>

getRendererStub<span class="hljs-preprocessor">.returns</span>(itemController)<span class="hljs-comment">;</span>

listController<span class="hljs-preprocessor">.getRendererFromItem</span> = getRendererStub<span class="hljs-comment">;</span>
</code></pre><p>The stub is sort of a fub, seeing as it is not really accessing the <code>list-item-controller</code> created by the <code>list-controller</code> in response to change on the collection – but it does provide some basis of design in that <code>getRendererFromItem()</code> is expected to return a <code>list-item-controller</code> which in turn responds to the provided model. Anyway, once we remove the stub and implement the API on the <code>list-controller</code> itself, we’ll certainly have to write more tests for that integration as we are not necessarily concerned in this specification of <code>getRendererFromItem()</code> returning the correct <code>list-item-controller</code> instance… so you have that to look forward to <img src="http://custardbelly.com/blog/wp-includes/images/smilies/icon_smile.gif" alt=":)"> Right now, we only care about the preservation of state and model existence within the application.</p>
<p>First we’ll test that setting an item as marked is preserved in the model and held on the item controller:<br><em>/test/jasmine/spec/feature/markitem.spec.js</em></p>
<pre><code><span class="hljs-function">it(<span class="hljs-string">'should denote item as being in possession'</span>, <span class="hljs-function">function()</span> {

  var itemRenderer = listController.<span class="hljs-function">getRendererFromItem(item)</span>;

      savedItemSpy = sinon.<span class="hljs-function">spy()</span>;



  <span class="hljs-function">savedItemSpy(itemRenderer.model)</span>;

  item.marked = true;



  <span class="hljs-function">expect(item.marked)</span>.<span class="hljs-function">toEqual(true)</span>;

  sinon.assert.<span class="hljs-function">calledWith(savedItemSpy, sinon.match.<span class="hljs-function">hasOwn(<span class="hljs-string">'marked'</span>, true)</span>)</span>;

})</span>;
</code></pre><p>Then, I want to ensure that marking off an item does not mean that it is removed from the overall collection:<br><em>/test/jasmine/spec/feature/markitem.spec.js</em></p>
<pre><code><span class="hljs-keyword">it</span>('should retain <span class="hljs-keyword">the</span> <span class="hljs-property">item</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">the</span> grocery <span class="hljs-type">list</span> collection', function() {

  var itemIndex = listController.getItemList().getItemIndex(<span class="hljs-property">item</span>);



  <span class="hljs-property">item</span>.marked = <span class="hljs-constant">true</span>;

  expect(listController.getItemList().getItemIndex(<span class="hljs-property">item</span>)).toEqual(itemIndex);

});
</code></pre><p>And finally, just to be sure that we can safely toggle the marked off state and it be retained:<br><em>/test/jasmine/spec/feature/markitem.spec.js</em></p>
<pre><code><span class="hljs-function">it(<span class="hljs-string">'should retain item in renderer listing regardless of marked-off status'</span>, <span class="hljs-function">function()</span> {

  var itemRenderer = listController.<span class="hljs-function">getRendererFromItem(item)</span>,

      itemIndex = listController.<span class="hljs-function">getItemList()</span>.<span class="hljs-function">getItemIndex(item)</span>;



  item.marked = true;

  item.marked = false;



  <span class="hljs-function">expect(itemRenderer.model.marked)</span>.<span class="hljs-function">toEqual(false)</span>;

  <span class="hljs-function">expect(listController.<span class="hljs-function">getItemList()</span>.<span class="hljs-function">getItemIndex(item)</span>)</span>.<span class="hljs-function">toEqual(itemIndex)</span>;

})</span>;
</code></pre><p>Perhaps the last one is out of a little paranoia, but it also describes the behavior of the <em>Mark Off Item</em> feature as being togglable from a User standpoint – meaning, marking off an item is not considered deleting it from the list. Also, a little paranoia sprinkled on some tests can save you from fret when working with the implementation code. </p>
<p>Speaking of implementation…</p>
<h3 id="list-controller-implementation">list-controller Implementation</h3>
<p>Moving the <code>getRendererFromItem()</code> method over to the <code>list-controller</code> will involve holding and maintaining a list of <code>list-item-renderers</code>. We’ll use the <em>Collection</em> object we created previously for the models and place the job of curation between both collections on the <code>list-controller</code>:</p>
<p><em>/script/controller/list-controller</em></p>
<pre><code><span class="hljs-keyword">var</span> collection = collectionFactory.create(),

    rendererList = collectionFactory.create(),

    listController = {

      $view: <span class="hljs-literal">undefined</span>,

      getItemList: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

        <span class="hljs-keyword">return</span> collection;

      },

      getRendererFromItem: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(item)</span> {</span>

        <span class="hljs-keyword">var</span> i = rendererList.itemLength();

        <span class="hljs-keyword">while</span>( --i &gt; -<span class="hljs-number">1</span> ) {

          <span class="hljs-keyword">if</span>(rendererList.getItemAt(i).model === item) {

            <span class="hljs-keyword">return</span> rendererList.getItemAt(i);

          }

          <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;

        }

      },

      createNewItem: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

        <span class="hljs-keyword">var</span> model = modelFactory.create();

        collection.addItem(model);

        <span class="hljs-keyword">return</span> model;

      },

      setView: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(view)</span> {</span>

        <span class="hljs-keyword">this</span>.$view = (view <span class="hljs-keyword">instanceof</span> $) ? view : $(view);

      }

    };
</code></pre><p>If an associated <code>list-item-controller</code> cannot be found from the provided <code>grocery-ls-item</code> model, then undefined is returned. We will ensure this and other expectations in a new integration test for the <code>list-controller</code> in a bit, but for now we have a little more work to do in order for the list-controller to behave as described in the <em>Mark Off Item</em> feature specs.</p>
<p>Next step is to have the tests fail by removing the stub for the <code>getRendererFromItem()</code> method now on the <code>list-controller</code>:<br><em>/test/jasmine/spec/feature/markitem.spec.js</em></p>
<pre><code><span class="hljs-function">define([<span class="hljs-string">'jquery'</span>, <span class="hljs-string">'script/controller/list-controller'</span>],

        <span class="hljs-function">function($, listController)</span> {



  <span class="hljs-function">describe(<span class="hljs-string">'Existing item is marked-off'</span>, <span class="hljs-function">function()</span> {



    var item;



    <span class="hljs-function">beforeEach( <span class="hljs-function">function()</span> {

      item = listController.<span class="hljs-function">createNewItem()</span>;

    })</span>;



    <span class="hljs-function">it(<span class="hljs-string">'should denote item as being in possession'</span>, <span class="hljs-function">function()</span> {

      var itemRenderer = listController.<span class="hljs-function">getRendererFromItem(item)</span>;

          savedItemSpy = sinon.<span class="hljs-function">spy()</span>;



      <span class="hljs-function">savedItemSpy(itemRenderer.model)</span>;

      item.marked = true;



      <span class="hljs-function">expect(item.marked)</span>.<span class="hljs-function">toEqual(true)</span>;

      sinon.assert.<span class="hljs-function">calledWith(savedItemSpy, sinon.match.<span class="hljs-function">hasOwn(<span class="hljs-string">'marked'</span>, true)</span>)</span>;

    })</span>;



    <span class="hljs-function">it(<span class="hljs-string">'should retain the item in the grocery list collection'</span>, <span class="hljs-function">function()</span> {

      var itemIndex = listController.<span class="hljs-function">getItemList()</span>.<span class="hljs-function">getItemIndex(item)</span>;



      item.marked = true;

      <span class="hljs-function">expect(listController.<span class="hljs-function">getItemList()</span>.<span class="hljs-function">getItemIndex(item)</span>)</span>.<span class="hljs-function">toEqual(itemIndex)</span>;

    })</span>;



    <span class="hljs-function">it(<span class="hljs-string">'should retain item in renderer listing regardless of marked-off status'</span>, <span class="hljs-function">function()</span> {

      var itemRenderer = listController.<span class="hljs-function">getRendererFromItem(item)</span>,

          itemIndex = listController.<span class="hljs-function">getItemList()</span>.<span class="hljs-function">getItemIndex(item)</span>;



      item.marked = true;

      item.marked = false;

      <span class="hljs-function">expect(itemRenderer.model.marked)</span>.<span class="hljs-function">toEqual(false)</span>;

      <span class="hljs-function">expect(listController.<span class="hljs-function">getItemList()</span>.<span class="hljs-function">getItemIndex(item)</span>)</span>.<span class="hljs-function">toEqual(itemIndex)</span>;

    })</span>;



    <span class="hljs-function">afterEach( <span class="hljs-function">function()</span> {

      item = undefined;

    })</span>;



  })</span>;



})</span>;
</code></pre><p>Run the tests, and we’ll get failures related to the <code>getRendererFromItem()</code> method returning undefined with each call:<br><img src="http://custardbelly.com/blog/images/tdd_js/part_vi_1.png" alt="Failing tests on getRendererFromItem invocation"></p>
<p>Good. That sort of assures us that <code>getRendererFromItem()</code> works as expected. This little mid-implementation failure won’t save us from writing proper tests for <code>list-controller</code>, but it’s a warm feeling for now <img src="http://custardbelly.com/blog/wp-includes/images/smilies/icon_smile.gif" alt=":)"></p>
<p>The reason that <code>getRendererForItem()</code> is returning undefined on each call is that we have not modified <code>list-controller</code> to add the <code>list-item-controller</code> renderer to the underlying <code>rendererList</code> collection. Let’s add the maintenance to the <em>collection-change</em> response on the model collection:</p>
<p><em>/script/controller/list-controller</em></p>
<pre><code><span class="hljs-variable">$collection</span>.on(<span class="hljs-string">'collection-change'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(event)</span> {</span>

  <span class="hljs-keyword">var</span> model, itemController, <span class="hljs-variable">$itemView</span>;

  <span class="hljs-keyword">switch</span>( event.kind ) {

    <span class="hljs-keyword">case</span> EventKindEnum.ADD:

      <span class="hljs-variable">$itemView</span> = $(<span class="hljs-string">'&lt;li&gt;'</span>);

      model = event.items.shift();

      itemController = itemControllerFactory.create(<span class="hljs-variable">$itemView</span>, model);



      <span class="hljs-variable">$itemView</span>.appendTo(listController.<span class="hljs-variable">$view</span>);

      rendererList.addItem(itemController);

      itemController.state = itemControllerFactory.state.EDITABLE;

      <span class="hljs-keyword">break</span>;

    <span class="hljs-keyword">case</span> EventKindEnum.REMOVE:

      <span class="hljs-keyword">break</span>;

    <span class="hljs-keyword">case</span> EventKindEnum.RESET:

      <span class="hljs-keyword">break</span>;

  }

});
</code></pre><p>We’ve moved the variable declarations out of the <em>switch..case</em> for the <code>ADD</code> event type; they are hoisted by the interpreter, anyway, but I like a little more clarity. More importantly, we are adding the newly created <code>list-item-controller</code> to he <code>renderList</code>.</p>
<p>Run the tests and we’ll be back to green!<br><img src="http://custardbelly.com/blog/images/tdd_js/part_vi_2.png" alt="Passing tests on getRendererFromItem implementation"></p>
<p>Hold on! Before you run out the door and down the street singing my praises… you need pants. I don’t know why you are reading this article without pants, but you probably will get a fine. Plus, we really need to add some tests for the <code>list-controller</code>.</p>
<h2 id="list-controller-tests">list-controller Tests</h2>
<p>The <em>Mark Off Item</em> specs we just got to pass are great in describing that feature and the usability, but they don’t necessarily test all the expectations we have of the <code>list-controller</code> and its API. Perhaps we should have wrote up the tests for <code>list-controller</code> and, specifically, the <code>getRendererFromItem()</code> method prior to modifying the <em>Mark Off Item</em> specs and getting them to pass. I would agree with that, but I am also not a stickler… as long as we get some integration tests in for <code>list-controller</code>, I won’t hold it against myself <img src="http://custardbelly.com/blog/wp-includes/images/smilies/icon_smile.gif" alt=":)"></p>
<p>There are more tests regarding the <code>list-controller</code> API in the repository tagged later in this article, but for now I wanted to create a new spec suite for <code>list-controller</code> and test the expectations we had previously described for the <code>getRendererFromItem()</code> method:</p>
<p><em>/test/jasmine/spec/list-controller.spec.js</em></p>
<pre><code><span class="hljs-function">define([<span class="hljs-string">'jquery'</span>, <span class="hljs-string">'script/controller/list-controller'</span>, <span class="hljs-string">'script/model/grocery-ls-item'</span>],

        <span class="hljs-function">function($, listController, modelFactory)</span> {



  <span class="hljs-function">describe(<span class="hljs-string">'Grocery List list-controller'</span>, <span class="hljs-function">function()</span> {



    <span class="hljs-function">describe(<span class="hljs-string">'getRendererItem()'</span>, <span class="hljs-function">function()</span> {



      <span class="hljs-function">it(<span class="hljs-string">'should return renderer associated with model'</span>, <span class="hljs-function">function()</span> {

        var itemModel, renderer;



        itemModel = listController.<span class="hljs-function">createNewItem()</span>;

        renderer = listController.<span class="hljs-function">getRendererFromItem(itemModel)</span>;

        <span class="hljs-function">expect(renderer)</span>.not.<span class="hljs-function">toBeUndefined()</span>;

        <span class="hljs-function">expect(renderer.model)</span>.<span class="hljs-function">toBe(itemModel)</span>;

      })</span>;



      <span class="hljs-function">it(<span class="hljs-string">'should return undefined with no associated model'</span>, <span class="hljs-function">function()</span> {

        var itemModel, renderer;



        itemModel = modelFactory.<span class="hljs-function">create()</span>;

        renderer = listController.<span class="hljs-function">getRendererFromItem(itemModel)</span>;

        <span class="hljs-function">expect(renderer)</span>.<span class="hljs-function">toBeUndefined()</span>;

      })</span>;



    })</span>;



  })</span>;



})</span>;
</code></pre><p>We have defined two tests for the <code>getRendererFromItem()</code> method on <code>list-controller</code> to ensure that it <strong>1)</strong> does return the associated renderer when available and <strong>2)</strong> does return undefined when an associated renderer is not available.</p>
<p>Let’s add that to the specrunner:<br><em>/test/jasmine/specrunner.html</em></p>
<pre><code><span class="hljs-keyword">require</span>( [<span class="hljs-string">'spec/feature/additem.spec.js'</span>, <span class="hljs-string">'spec/feature/markitem.spec.js'</span>,

          <span class="hljs-string">'spec/list-controller.spec.js'</span>, <span class="hljs-string">'spec/list-item-controller.spec.js'</span>, <span class="hljs-string">'spec/grocery-ls-item.spec.js'</span>,

          <span class="hljs-string">'spec/collection.spec.js'</span>], <span class="hljs-keyword">function</span>() {



  var jasmineEnv = jasmine.getEnv(),

      <span class="hljs-keyword">...</span>

  jasmineEnv.execute();



});
</code></pre><h4 id="aside">aside</h4>
<p>You may be wondering why it seems like I am doubling up on tests; after all, we have verified that the <code>getRendererFromItem()</code> method does as expected from within the <em>Mark Off Item</em> specs. This is true. However, I think of this spec suite, <em>list-controller.spec.js</em>, as more unit tests in that we are verifying how the component behaves. Within the <em>Mark Off Item</em> specs, I feel it is closer to how the component behaves in the system and reveals more of an expectation of the features of the <strong>Grocery List</strong> application. If I was to do further work in modifying the <code>list-controller</code>, I would start with this spec, and if it impacted the <em>Mark Off Item</em> feature, get that passing afterward. Not stuck in my way of thinking on this, but it my current workflow. Let me know if you have any better strategies.</p>
<p>Actually, that brings up a good point. We should revisit the <em>Add Item</em> specs and add a test to ensure that the newly created item returned from <code>createNewItem()</code> will return an associated list-item-controller instance from <code>getRendererFromItem()</code>…</p>
<h2 id="add-item-feature-update">Add Item Feature Update</h2>
<p>We’ll add a spec to the current suite that verifies that the new created <code>grocery-ls-item</code> is properly paired with the <code>list-item-controller</code> and that they associated view is the one made available on the <strong>Grocery List</strong> UI:</p>
<p><em>/test/jasmine/spec/feature/additem.spec.js</em></p>
<pre><code><span class="hljs-function">it(<span class="hljs-string">'should enable associated item renderer as editable'</span>, <span class="hljs-function">function()</span> {

  var newItem = listController.<span class="hljs-function">createNewItem()</span>,

      itemRenderer = listController.<span class="hljs-function">getRendererFromItem(newItem)</span>;



    <span class="hljs-function">expect(itemRenderer)</span>.not.<span class="hljs-function">toBeUndefined()</span>;

    <span class="hljs-function">expect(itemRenderer.model)</span>.<span class="hljs-function">toBe(newItem)</span>;

    <span class="hljs-function">expect(itemRenderer.state)</span>.<span class="hljs-function">toEqual(itemControllerFactory.state.EDITABLE)</span>;

    <span class="hljs-function">expect($listView.<span class="hljs-function">children()</span>[<span class="hljs-number">0</span>])</span>.<span class="hljs-function">toBe(itemRenderer.parentView.<span class="hljs-function">get(<span class="hljs-number">0</span>)</span>)</span>;

})</span>;
</code></pre><p>The last expectation in there utilizes some of the access API from <a href="http://custardbelly.com/blog/jquery.org">jQuery</a>. If you are unfamiliar with it, it is basically testing that the first item in the parent list view is that of the <code>parentView</code> managed by the associated <code>list-item-controller</code>. If you take a look at the <a href="https://github.com/bustardcelly/grocery-ls/blob/0.1.8/test/jasmine/spec/feature/newitem.spec.js">previous spec</a>, we had already verified that the child list of the list view had been changed to include a new item; now we are ensuring that the new item is the correct one, accessible from <code>getRendererFromItem()</code>.</p>
<p>I think that pretty much shores up the proper testing in describing the <em>Add Item</em> and <em>Mark Off Item</em> features. Run the tests and all are green!<br><img src="http://custardbelly.com/blog/images/tdd_js/part_vi_3.png" alt="Passing tests for Add Item and Mark Off Item Features"></p>
<p>Tagged <strong>0.1.9</strong> : <a href="https://github.com/bustardcelly/grocery-ls/tree/0.1.9"><a href="https://github.com/bustardcelly/grocery-ls/tree/0.1.9">https://github.com/bustardcelly/grocery-ls/tree/0.1.9</a></a></p>
<h2 id="conclusion">Conclusion</h2>
<p>We got the <em>Mark Off Item</em> specs running green again after we had left the application in a failing state from the <a href="http://custardbelly.com/blog/2012/12/31/the-making-of-a-test-driven-grocery-list-application-in-js-part-v/">last article</a>. Hooray! But, we are still only addressing half of the usability features I envision for the <strong>Grocery List</strong> application. Sometimes it is easy to forget that we are still building an application. If you ran it, you would see that it still works as expected, which I think is rather cool; I mean, we have been busying ourselves ensuring that our code will support our understanding of the system, and at the end of the day, it actually does. We have been running the test runner much more than the actual application. That is not to say that we shouldn’t be doing more User testing…</p>
<p>Anyway, in the next article I think we should address a new feature – Removal. Cheers for sticking around!</p>
<p>—</p>
<h1 id="link-dump">Link Dump</h1>
<h2 id="reference">Reference</h2>
<p><a href="http://tddjs.com/">Test-Driven JavaScript Development by Christian Johansen</a><br><a href="http://dannorth.net/introducing-bdd/">Introducing BDD by Dan North</a><br><a href="http://requirejs.org/">RequireJS</a><br><a href="https://github.com/amdjs/amdjs-api/wiki/AMD">AMD</a><br><a href="http://pivotal.github.com/jasmine/">Jasmine</a><br><a href="http://sinonjs.org/">Sinon</a><br><a href="https://github.com/derickbailey/jasmine.async">Jasmine.Async</a></p>
<h2 id="post-series">Post Series</h2>
<p><a href="https://github.com/bustardcelly/grocery-ls">grocery-ls github repo</a><br><a href="http://custardbelly.com/blog/2012/11/26/the-making-of-a-test-driven-grocery-list-application-in-javascript-part-i">Part I – Introduction</a><br><a href="http://custardbelly.com/blog/2012/11/26/the-making-of-a-test-driven-grocery-list-application-in-js-part-ii">Part II – Feature: Add Item</a><br><a href="http://custardbelly.com/blog/2012/12/06/the-making-of-a-test-driven-grocery-list-application-in-js-part-iii">Part III – Feature: Mark-Off Item</a><br><a href="http://custardbelly.com/blog/2012/12/17/the-making-of-a-test-driven-grocery-list-application-in-js-part-iv">Part IV – Feature: List-Item-Controller</a><br><a href="http://custardbelly.com/blog/2012/12/31/the-making-of-a-test-driven-grocery-list-application-in-js-part-v/">Part V – Feature: List-Controller Refactoring</a><br><a href="http://custardbelly.com/blog/2013/01/08/the-making-of-a-test-driven-grocery-list-application-in-js-part-vi/">Part VI – Back to Passing</a><br><a href="http://custardbelly.com/blog/2013/01/17/the-making-of-a-test-driven-grocery-list-application-in-js-part-vii/">Part VII – Remove Item</a><br><a href="http://custardbelly.com/blog/2013/01/22/the-making-of-a-test-driven-grocery-list-application-part-viii/">Part VIII – Bug Fixing</a><br><a href="http://custardbelly.com/blog/2013/02/15/the-making-of-a-test-driven-grocery-list-application-in-js-part-ix/">Part IX – Persistence</a><br><a href="http://custardbelly.com/blog/2013/03/06/the-making-of-a-test-driven-grocery-list-application-in-js-part-x/">Part X – It Lives!</a></p>
<p>Posted in <a href="http://custardbelly.com/blog/category/amd/">AMD</a>, <a href="http://custardbelly.com/blog/category/javascript/">JavaScript</a>, <a href="http://custardbelly.com/blog/category/requirejs/">RequireJS</a>, <a href="http://custardbelly.com/blog/category/grocery-ls/">grocery-ls</a>, <a href="http://custardbelly.com/blog/category/jasmine/">jasmine</a>, <a href="http://custardbelly.com/blog/category/unit-testing/">unit-testing</a>.</p>
]]></description><link>http://custardbelly.com/blog/blog-posts/2013/01/08/the-making-of-a-test-driven-grocery-list-application-in-js-part-vi/index.html</link><guid isPermaLink="true">http://custardbelly.com/blog/blog-posts/2013/01/08/the-making-of-a-test-driven-grocery-list-application-in-js-part-vi/index.html</guid><dc:creator><![CDATA[Todd Anderson]]></dc:creator><pubDate>Invalid Date</pubDate></item><item><title><![CDATA[The Making of a Test-Driven Grocery List Application in JS: Part V]]></title><description><![CDATA[<p><em>This is the fifth installment in a series of building a Test-Driven Grocery List application using <a href="http://pivotal.github.com/jasmine/">Jasmine</a> and <a href="http://requirejs.org">RequireJS</a>. To learn more about the intent and general concept of the series please visit <a href="http://custardbelly.com/blog/2012/11/26/the-making-of-a-test-driven-grocery-list-application-in-javascript-part-i/">The Making of a Test-Driven Grocery List Application in JavaScript: Part I</a></em><br>—</p>
<h2 id="introduction">Introduction</h2>
<p>The <a href="http://custardbelly.com/blog/2012/12/17/the-making-of-a-test-driven-grocery-list-application-in-js-part-iv">previous article</a> was prefaced to be a refactoring effort to remove responsibilities of item management from the <em>list-controller</em> to instances of a <em>list-item-controller</em>. We designed the list-item-controller through specs, moved the factory to its own AMD and modified not only the <em>grocery-ls-item</em> model, but how the <em>list-item-controller</em> responded to changes of it.</p>
<p>All important and – in my view – much needed changes. However, we fell short on our goal. Sure, the tests still passed, but we modified nothing within the <em>list-controller</em> to reflect this transfer of responsibility. Part of the reason for this is my attempt at not overloading each article in this series with information. The other part is that I wanted a little time to stew over how I actually saw the revision of <em>list-controller</em>.</p>
<p>We still want to keep our feature specs of <em>Add Item</em> and <em>Mark Item</em> (and we have a few more features still to address), but I begin to question if it is really necessary to expose that functionality on the API of the <em>list-controller</em>. I am starting to see that those features are really part of a collection of <em>grocery-ls-item</em> models, and the controllers are just responders to changes on the collection and models themselves – the basis of MVC design.</p>
<p>Just as we implemented <em>list-item-controller</em> in the previous article with a design to respond to changes on a provided <em>grocery-ls-item</em> model and update its state accordingly, I propose so should we refactor the <em>list-controller</em> to respond to changes on a collection of <em>grocery-ls-item</em> models.</p>
<h2 id="collection">Collection</h2>
<p>A generic collection is basically an object that provides a higher-level API to interact with an array of items. The API can provide a more readable way of adding and removing items on an underlying <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array">Array</a> instance instead of using methods like <em>push</em> or <em>splice</em> – which are base level and don’t use a nomenclature that is best suited for the action taken – but more importantly, the API provides a facade to operations on an array of items from which it can internally have stricter rules over such actions. </p>
<p>There are various libraries and frameworks out there that support collections, and even different type of collections – ie, sets, linked lists, etc. As has been mentioned in previous posts, I am trying not to introduce new libraries into this series as it may add unnecessary noise to the task at hand. This also allows for us to keep the <em>Collection</em> implementation lean and customizable for the <strong>Grocery List</strong> application; we’re also going to support event notification from the collection, which is not inherent in the JavaScript <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array">Array</a> object.</p>
<h3 id="tests">Tests</h3>
<p>We will create the design of a <em>Collection</em> object piecemeal as we write the specs for it. To start, we know that it is to be a wrapper around an Array source:</p>
<p><em>/test/jasmine/spec/collection.spec.js</em></p>
<pre><code>define( [<span class="hljs-string">'jquery'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">($)</span> {</span>



  <span class="hljs-keyword">var</span> collectionImpl = {

        itemLength: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

          <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.list.length;

        }

      },

      collectionFactory = {

        create: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(source)</span> {</span>

          <span class="hljs-keyword">var</span> instance = <span class="hljs-built_in">Object</span>.create(collectionImpl, {

              <span class="hljs-string">"list"</span>: {

                  value: <span class="hljs-built_in">Array</span>.isArray(source) ? source : [],

                  writable: <span class="hljs-literal">true</span>,

                  enumerable: <span class="hljs-literal">true</span>

          });

          <span class="hljs-keyword">return</span> instance;

        }

      };



  describe(<span class="hljs-string">'Collection'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>



    describe(<span class="hljs-string">'collection factory instance creation'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>



      it(<span class="hljs-string">'should create unique instances of collection from create()'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

        <span class="hljs-keyword">var</span> collectionOne = collectionFactory.create(),

            collectionTwo = collectionFactory.create();

        expect(collectionOne).not.toBe(collectionTwo);

      });



      it(<span class="hljs-string">'should create an empty collection without source array provided'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

        <span class="hljs-keyword">var</span> collection = collectionFactory.create();

        expect(collection).not.toBeUndefined();

        expect(collection.itemLength()).toBe(<span class="hljs-number">0</span>);

      });



      it(<span class="hljs-string">'should create a collection from source array provided'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

        <span class="hljs-keyword">var</span> items = [<span class="hljs-string">'apples'</span>, <span class="hljs-string">'oranges'</span>],

            collection = collectionFactory.create(items);

        expect(collection.itemLength()).toBe(<span class="hljs-number">2</span>);

      });



    });



  });



});
</code></pre><p>We have defined two specs that involve testing the wrapped Array source for a collection. Upon creation, the array should be empty if no source array supplied or filled with items if source provided. Pretty straight forward.<br>Again, we are only concerned with the latest-and-greatest browsers, so you may notice the use of <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/isArray">Array.isArray</a> when the <em>list</em> property is defined within the check the <em>source</em> argument on the <em>collectionFactory.create()</em> call.</p>
<h4 id="aside">aside</h4>
<p>We could get into a lengthy discussion about the design of <em>collectionImpl</em>, and in particular that the <em>list</em> property is publicly accessible – i mean, after all, are we not defeating the point of providing an API to manipulate the list if some developer could just come along and access it directly? A valid point, and one I struggle with often. We could – and I would recommend, at times – using the functional inheritance pattern to ‘privately’ hold the underlying list within the collection. For example:</p>
<pre><code><span class="hljs-keyword">var</span> collectionImpl = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(source)</span> {</span>

  <span class="hljs-keyword">var</span> <span class="hljs-keyword">list</span> = source;

  <span class="hljs-keyword">return</span> {

    itemLength: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

      <span class="hljs-keyword">return</span> <span class="hljs-keyword">list</span>.length;

    }

  };

});

<span class="hljs-keyword">var</span> instance = collectionImpl([]);
</code></pre><p>That would ‘<em>conveniently</em>‘ make the underlying array ‘private’, but there are an arguable list of pros and cons to this approach – the biggest con is the creation of a new object with new functions and new properties each call, rather then a shared inheritance. In essence, each new instance of collection created using this pattern could then modify, add and/or remove methods so that the API is not the same across all ‘instances’ of the collection – that’s a big con for me.</p>
<p>For our implementation, let’s just take it with a grain of salt that we don’t expect anyone to maliciously access the source array of the collection and use the API we are defining in our tests <img src="http://custardbelly.com/blog/wp-includes/images/smilies/icon_smile.gif" alt=":)"></p>
<h4 id="end-aside">end aside</h4>
<p>Even though in the last spec, we aren’t concerned with the underlying list being strictly equal to the provided source, we should probably check that the list has the correct items and is in the correct order:</p>
<p><em>/test/jasmine/spec/collection.spec.js</em></p>
<pre><code><span class="hljs-keyword">var</span> collectionImpl = {

  itemLength: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.list.length;

  },

  getItemAt: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( index )</span> {</span>

    <span class="hljs-keyword">if</span>( index &lt; <span class="hljs-number">0</span> || (index &gt; <span class="hljs-keyword">this</span>.itemLength() - <span class="hljs-number">1</span>) ) {

      <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;

    }

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.list[index];

  }

}
</code></pre><p>The <em>getItemAt()</em> method first verifies that the supplied index within the range of the wrapped array and returns undefined if not or the item held in the array at the supplied index. We can ensure that method works properly by adding a couple tests to the spec we already have for verifying the source provided on creation:</p>
<p><em>/test/jasmine/spec/collection.spec.js</em></p>
<pre><code><span class="hljs-function">it(<span class="hljs-string">'should create a collection from source array'</span>, <span class="hljs-function">function()</span> {

  var itemOne = <span class="hljs-string">'apples'</span>,

      itemTwo = <span class="hljs-string">'oranges'</span>,

      collection = collectionFactory.<span class="hljs-function">create([itemOne, itemTwo])</span>;

  <span class="hljs-function">expect(collection.<span class="hljs-function">itemLength()</span>)</span>.<span class="hljs-function">toBe(<span class="hljs-number">2</span>)</span>;

  <span class="hljs-function">expect(collection.<span class="hljs-function">getItemAt(<span class="hljs-number">0</span>)</span>)</span>.<span class="hljs-function">toEqual(itemOne)</span>;

  <span class="hljs-function">expect(collection.<span class="hljs-function">getItemAt(<span class="hljs-number">1</span>)</span>)</span>.<span class="hljs-function">toEqual(itemTwo)</span>;

})</span>;
</code></pre><p>Let’s go ahead and add some useful methods that will aid in adding and removing items to and from the collection:</p>
<p><em>/test/jasmine/spec/collection.spec.js</em></p>
<pre><code><span class="hljs-keyword">var</span> collectionImpl = {

  itemLength: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.list.length;

  },

  addItem: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(item)</span> {</span>

    <span class="hljs-keyword">this</span>.list.push(item);

    <span class="hljs-keyword">return</span> item;

  },

  removeItem: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(item)</span> {</span>

    <span class="hljs-keyword">var</span> index = <span class="hljs-keyword">this</span>.list.indexOf(item);

    <span class="hljs-keyword">if</span>( index &gt; -<span class="hljs-number">1</span> ) {

      <span class="hljs-keyword">this</span>.list.splice(index, <span class="hljs-number">1</span>);

      <span class="hljs-keyword">return</span> item;

    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;

  },

  removeAll: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

    <span class="hljs-keyword">this</span>.list.length = [];

  },

  getItemAt: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( index )</span> {</span>

    <span class="hljs-keyword">if</span>( index &lt; <span class="hljs-number">0</span> || (index &gt; <span class="hljs-keyword">this</span>.itemLength() - <span class="hljs-number">1</span>) ) {

      <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;

    }

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.list[index];

  }

}
</code></pre><p>We could add some specs for <em>addItem()</em> to ensure that the list does grow with each item appended to the end:</p>
<p><em>/test/jasmine/spec/collection.spec.js</em></p>
<pre><code><span class="hljs-function">describe(<span class="hljs-string">'collection item addition'</span>, <span class="hljs-function">function()</span> {



  var collection;



  <span class="hljs-function">beforeEach( <span class="hljs-function">function()</span> {

    collection = collectionFactory.<span class="hljs-function">create()</span>;

  })</span>;



  <span class="hljs-function">it(<span class="hljs-string">'should append item to list from addItem()'</span>, <span class="hljs-function">function()</span> {

    var item = <span class="hljs-string">'grapes'</span>;

    collection.<span class="hljs-function">addItem(item)</span>;

    <span class="hljs-function">expect(collection.<span class="hljs-function">itemLength()</span>)</span>.<span class="hljs-function">toBe(<span class="hljs-number">1</span>)</span>;

    <span class="hljs-function">expect(collection.<span class="hljs-function">getItemAt(<span class="hljs-number">0</span>)</span>)</span>.<span class="hljs-function">toEqual(item)</span>;

  })</span>;



  <span class="hljs-function">it(<span class="hljs-string">'should maintain order during multiple additions'</span>, <span class="hljs-function">function()</span> {

    var itemOne = <span class="hljs-string">'grapes'</span>,

        itemTwo = <span class="hljs-string">'grapefruit'</span>;

    collection.<span class="hljs-function">addItem(itemOne)</span>;

    collection.<span class="hljs-function">addItem(itemTwo)</span>;

    <span class="hljs-function">expect(collection.<span class="hljs-function">itemLength()</span>)</span>.<span class="hljs-function">toBe(<span class="hljs-number">2</span>)</span>;

    <span class="hljs-function">expect(collection.<span class="hljs-function">getItemAt(<span class="hljs-number">1</span>)</span>)</span>.<span class="hljs-function">toEqual(itemTwo)</span>;

  })</span>;



  <span class="hljs-function">afterEach( <span class="hljs-function">function()</span> {

    collection = undefined;

  })</span>;



})</span>;
</code></pre><p>… and throw in a spec suite for testing the removal API on the <em>Collection</em>:</p>
<p><em>/test/jasmine/spec/collection.spec.js</em></p>
<pre><code><span class="hljs-function">describe(<span class="hljs-string">'collection item removal'</span>, <span class="hljs-function">function()</span> {



  var collection,

      itemOne = <span class="hljs-string">'pineapple'</span>,

      itemTwo = <span class="hljs-string">'pear'</span>;



  <span class="hljs-function">beforeEach( <span class="hljs-function">function()</span> {

    collection = collectionFactory.<span class="hljs-function">create()</span>;

    collection.<span class="hljs-function">addItem(itemOne)</span>;

  })</span>;



  <span class="hljs-function">it(<span class="hljs-string">'should remove only specified item and report length of 0 from removeItem()'</span>, <span class="hljs-function">function()</span> {

    collection.<span class="hljs-function">removeItem(itemOne)</span>;

    <span class="hljs-function">expect(collection.<span class="hljs-function">itemLength()</span>)</span>.<span class="hljs-function">toBe(<span class="hljs-number">0</span>)</span>;

  })</span>;



  <span class="hljs-function">it(<span class="hljs-string">'should remove specified item from proper index'</span>, <span class="hljs-function">function()</span> {

    collection.<span class="hljs-function">addItem(itemTwo)</span>;

    collection.<span class="hljs-function">removeItem(itemOne)</span>;

    <span class="hljs-function">expect(collection.<span class="hljs-function">itemLength()</span>)</span>.<span class="hljs-function">toBe(<span class="hljs-number">1</span>)</span>;

    <span class="hljs-function">expect(collection.<span class="hljs-function">getItemAt(<span class="hljs-number">0</span>)</span>)</span>.<span class="hljs-function">toEqual(itemTwo)</span>;

  })</span>;



  <span class="hljs-function">it(<span class="hljs-string">'should retain items in collection if item provided to removeItem() is not found'</span>, <span class="hljs-function">function()</span> {

    collection.<span class="hljs-function">addItem(itemTwo)</span>;

    collection.<span class="hljs-function">removeItem(<span class="hljs-string">'watermelon'</span>)</span>;

    <span class="hljs-function">expect(collection.<span class="hljs-function">itemLength()</span>)</span>.<span class="hljs-function">toBe(<span class="hljs-number">2</span>)</span>;

  })</span>;



  <span class="hljs-function">it(<span class="hljs-string">'should empty the list on removeAll()'</span>, <span class="hljs-function">function()</span> {

    collection.<span class="hljs-function">addItem(itemTwo)</span>;

    collection.<span class="hljs-function">removeAll()</span>;

    <span class="hljs-function">expect(collection.<span class="hljs-function">itemLength()</span>)</span>.<span class="hljs-function">toBe(<span class="hljs-number">0</span>)</span>;

  })</span>;



  <span class="hljs-function">afterEach( <span class="hljs-function">function()</span> {

    collection = undefined;

  })</span>;



})</span>;
</code></pre><p>With that, we have roughly designed and verified the API for our custom <em>Collection</em> object. Let’s add it to our list of specs to run:</p>
<p><em>/test/jasmine/specrunner.html</em></p>
<pre><code><span class="hljs-keyword">require</span>( [<span class="hljs-string">'spec/newitem.spec.js'</span>, <span class="hljs-string">'spec/markitem.spec.js'</span>,

          <span class="hljs-string">'spec/item-controller.spec.js'</span>, <span class="hljs-string">'spec/grocery-ls-item.spec.js'</span>,

          <span class="hljs-string">'spec/collection.spec.js'</span>], <span class="hljs-keyword">function</span>() {



  var jasmineEnv = jasmine.getEnv(),

     <span class="hljs-keyword">...</span>

  jasmineEnv.execute();



});
</code></pre><p>Run it and all is green!<br><img src="http://custardbelly.com/blog/images/tdd_js/part_v_1.png" alt="Passing collection suite"></p>
<p>Whoa. Settle down… we’re not done yet <img src="http://custardbelly.com/blog/wp-includes/images/smilies/icon_smile.gif" alt=":)"></p>
<h4 id="collection-events">Collection Events</h4>
<p>If we think back to why we even started down this path of creating a Collection object, we’ll remember that its role in the <strong>Grocery List</strong> application is to serve as the model for the <em>list-controller</em>. It is the intention to eventually modify the <em>list-controller</em> to not only offload the responsibility of managing the relationship and interaction between individual <em>grocery-ls-item</em> models to their views, but also to respond to changes on the collection of <em>grocery-ls-item_s accordingly. As such, we will incorporate event notification into our _Collection</em> object, from which the <em>list-controller</em> can assign response delegates to changes on the collection.</p>
<p>Using <a href="http://api.jquery.com/category/Events/?rdfrom=http%3A%2F%2Fdocs.jquery.com%2Fmw%2Findex.php%3Ftitle%3DAPI%2F1.3%2FEvents%26redirect%3Dno">jQuery Event</a> as we have previously in the development of this application throughout this series, we’ll create a factory method that returns an event object based provided arguments. If you are familiar with collections from the <a href="http://www.adobe.com/devnet/flex/flex-sdk-download.html">Flex SDK</a>, you might notice something similar <img src="http://custardbelly.com/blog/wp-includes/images/smilies/icon_smile.gif" alt=":)"> :</p>
<p><em>/test/jasmine/spec/collection.spec.js</em></p>
<pre><code>function createEvent(kind, items) {

  <span class="hljs-keyword">var</span> <span class="hljs-keyword">event</span> = <span class="hljs-keyword">new</span> $.Event(<span class="hljs-string">'collection-change'</span>);

  <span class="hljs-keyword">event</span>.kind = kind;

  <span class="hljs-keyword">event</span>.items = items;

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">event</span>;

}
</code></pre><p>Basically, any event dispatched from the collection object will be of the same type, and its operation can be differentiated from the <em>kind</em> property. The items affected upon the associated operation (<em>kind</em>) are provided in an array as some operations may involve multiple items.</p>
<p>With the API we have defined for the collection, there are three operations that can modify the the list of items:</p>
<ul>
<li>add</li>
<li>remove</li>
<li>reset</li>
</ul>
<p>The methods associated with add and remove are pretty self-explanatory and we will consider <em>removeAll()</em> as a reset on the collection. With this in mind, let’s append a couple tests to our spec suites for these event notifications:</p>
<p><em>/test/jasmine/spec/collection.spec.js</em></p>
<pre><code>describe(<span class="hljs-string">'collection item addition'</span>, <span class="hljs-keyword">function</span>() {

<span class="hljs-keyword">...</span>

    async.it(<span class="hljs-string">'should notify on addition of item'</span>, <span class="hljs-keyword">function</span>(done) {

      var item = <span class="hljs-string">'grapes'</span>;

      $(collection).on(<span class="hljs-string">'collection-change'</span>, <span class="hljs-keyword">function</span>(event) {

        expect(event.kind).toBe(<span class="hljs-string">'add'</span>);

        expect(event.items.length).toBe(<span class="hljs-number">1</span>);

        expect(event.items[<span class="hljs-number">0</span>]).toEqual(item);

        $(collection).off(<span class="hljs-string">'collection-change'</span>);

        done();

      });

      collection.addItem(item);

    });

<span class="hljs-keyword">...</span>

});

<span class="hljs-keyword">...</span>

describe(<span class="hljs-string">'collection item removal'</span>, <span class="hljs-keyword">function</span>() {

<span class="hljs-keyword">...</span>

  async.it(<span class="hljs-string">'should notify on removal of item'</span>, <span class="hljs-keyword">function</span>(done) {

    collection.addItem(itemTwo);

    $(collection).on(<span class="hljs-string">'collection-change'</span>, <span class="hljs-keyword">function</span>(event) {

      expect(event.kind).toBe(<span class="hljs-string">'remove'</span>);

      expect(event.items.length).toBe(<span class="hljs-number">1</span>);

      expect(event.items[<span class="hljs-number">0</span>]).toEqual(itemOne);

      $(collection).off(<span class="hljs-string">'collection-change'</span>);

      done();

    });

    collection.removeItem(itemOne);

  });



  async.it(<span class="hljs-string">'should notify on reset of collection'</span>, <span class="hljs-keyword">function</span>(done) {

    $(collection).on(<span class="hljs-string">'collection-change'</span>, <span class="hljs-keyword">function</span>(event) {

      expect(event.kind).toBe(<span class="hljs-string">'reset'</span>);

      expect(event.items.length).toBe(<span class="hljs-number">0</span>);

      $(collection).off(<span class="hljs-string">'collection-change'</span>);

      done();

    });

    collection.removeAll();

  });



  afterEach( <span class="hljs-keyword">function</span>() {

    collection = undefined;

  });

<span class="hljs-keyword">...</span>

});
</code></pre><p>If you were to run the tests now, you would see a couple execute then hang intermittently as it waits for the async tests to timeout… because we haven’t implemented the dispatching of events from the collection yet <img src="http://custardbelly.com/blog/wp-includes/images/smilies/icon_smile.gif" alt=":)"></p>
<p><em>/test/jasmine/spec/collection.spec.js</em></p>
<pre><code><span class="hljs-keyword">var</span> collectionImpl = {

  itemLength: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.list.length;

  },

  addItem: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(item)</span> {</span>

    <span class="hljs-keyword">this</span>.list.push(item);

    $(<span class="hljs-keyword">this</span>).trigger(createEvent(<span class="hljs-string">'add'</span>, [item]));

    <span class="hljs-keyword">return</span> item;

  },

  removeItem: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(item)</span> {</span>

    <span class="hljs-keyword">var</span> index = <span class="hljs-keyword">this</span>.list.indexOf(item);

    <span class="hljs-keyword">if</span>( index &gt; -<span class="hljs-number">1</span> ) {

      <span class="hljs-keyword">this</span>.list.splice(index, <span class="hljs-number">1</span>);

      $(<span class="hljs-keyword">this</span>).trigger(createEvent(<span class="hljs-string">'remove'</span>, [item]));

      <span class="hljs-keyword">return</span> item;

    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;

  },

  removeAll: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

    <span class="hljs-keyword">this</span>.list.length = [];

    $(<span class="hljs-keyword">this</span>).trigger(createEvent(<span class="hljs-string">'reset'</span>, <span class="hljs-keyword">this</span>.list));

  },

  getItemAt: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( index )</span> {</span>

    <span class="hljs-keyword">if</span>( index &lt; <span class="hljs-number">0</span> || (index &gt; <span class="hljs-keyword">this</span>.itemLength() - <span class="hljs-number">1</span>) ) {

      <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;

    }

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.list[index];

  }

}
</code></pre><p>Now, if you were to run the tests, all should be happy.</p>
<h3 id="collection-module-implementation">Collection Module Implementation</h3>
<p>Just as we have done with the <em>list-item-controller</em> from the <a href="http://custardbelly.com/blog/2012/12/17/the-making-of-a-test-driven-grocery-list-application-in-js-part-iv/">previous article</a>, we are going to take the work we had done in implementing the collection object within our tests and move it to an AMD module. This way, if we <em>ever</em> get around to refactoring the <em>list-controller</em>, we’ll be able to utilize the collection module:</p>
<p><em>/script/collection/collection.js</em></p>
<pre><code>define([<span class="hljs-string">'jquery'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">($)</span> {</span>



  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createEvent</span><span class="hljs-params">(kind, items)</span> {</span>

    <span class="hljs-keyword">var</span> event = $.Event(<span class="hljs-string">'collection-change'</span>);

    event.kind = kind;

    event.items = items;

    <span class="hljs-keyword">return</span> event;

  }



  <span class="hljs-keyword">var</span> _collectionEventKind = {

        ADD: <span class="hljs-string">'add'</span>,

        REMOVE: <span class="hljs-string">'remove'</span>,

        RESET: <span class="hljs-string">'reset'</span>

      },

      collection = {

        itemLength: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

          <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.list.length;

        },

        addItem: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(item)</span> {</span>

          <span class="hljs-keyword">this</span>.list.push(item);

          $(<span class="hljs-keyword">this</span>).trigger(createEvent(_collectionEventKind.ADD, [item]));

          <span class="hljs-keyword">return</span> item;

        },

        removeItem: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(item)</span> {</span>

          <span class="hljs-keyword">var</span> index = <span class="hljs-keyword">this</span>.getItemIndex(item);

          <span class="hljs-keyword">if</span>( index &gt; -<span class="hljs-number">1</span> ) {

            <span class="hljs-keyword">this</span>.list.splice(index, <span class="hljs-number">1</span>);

            $(<span class="hljs-keyword">this</span>).trigger(createEvent(_collectionEventKind.REMOVE, [item]));

            <span class="hljs-keyword">return</span> item;

          }

          <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;

        },

        removeAll: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

          <span class="hljs-keyword">this</span>.list.length = <span class="hljs-number">0</span>;

          $(<span class="hljs-keyword">this</span>).trigger(createEvent(_collectionEventKind.RESET, <span class="hljs-keyword">this</span>.list));

        },

        getItemAt: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(index)</span> {</span>

          <span class="hljs-keyword">if</span>( index &lt; <span class="hljs-number">0</span> || (index &gt; <span class="hljs-keyword">this</span>.itemLength() - <span class="hljs-number">1</span>) ) {

            <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;

          }

          <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.list[index];

        },

        getItemIndex: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(item)</span> {</span>

          <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.list.indexOf(item);

        },

        contains: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(item)</span> {</span>

          <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getItemIndex(item) != -<span class="hljs-number">1</span>;

        }

      };



  <span class="hljs-keyword">return</span> {

    collectionEventKind: _collectionEventKind,

    create: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(source)</span> {</span>

      <span class="hljs-keyword">var</span> instance = <span class="hljs-built_in">Object</span>.create(collection);

      <span class="hljs-built_in">Object</span>.defineProperty(instance, <span class="hljs-string">"list"</span>, {

          value: <span class="hljs-built_in">Array</span>.isArray(source) ? source : [],

          writable: <span class="hljs-literal">true</span>,

          enumerable: <span class="hljs-literal">true</span>

      });

      <span class="hljs-keyword">return</span> instance;

    }

  };



});
</code></pre><p>We have basically ripped the collection and factory out from our test implementation and dropped it into its own file, returning the event kind enumeration object and the <em>create()</em> factory method to generate new collections for this AMD module.</p>
<p>To verify that our <em>Collection</em> module works correctly, let’s replace the implementation in the test with this module reference and run our tests again:</p>
<p><em>/test/jasmine/spec/collection.spec.js</em></p>
<pre><code>define( [<span class="hljs-string">'jquery'</span>, <span class="hljs-string">'script/collection/collection'</span>], <span class="hljs-keyword">function</span>($, collectionFactory) {



  describe(<span class="hljs-string">'Collection'</span>, <span class="hljs-keyword">function</span>() {

     <span class="hljs-keyword">...</span>

  });



});
</code></pre><p><img src="http://custardbelly.com/blog/images/tdd_js/part_v_2.png" alt="Passing collection tests on AMD module"></p>
<p>Tagged: <strong>0.1.6</strong> <a href="https://github.com/bustardcelly/grocery-ls/tree/0.1.6"><a href="https://github.com/bustardcelly/grocery-ls/tree/0.1.6">https://github.com/bustardcelly/grocery-ls/tree/0.1.6</a></a></p>
<h2 id="list-controller-refactoring">list-controller Refactoring</h2>
<p>Passing tests are great! But currently, they are lying to us. Well… not <em>really</em>, but we have gone about all these new additions to our application and have yet still to refactor <em>list-controller</em> to utilize them. However, before we just start chopping out and inserting code from <em>list-controller</em>, I want to go over the API and specs currently defined and see if they still hold water – meaning we might be able to cut some tests out. We might not. We might even add more. Let’s see…</p>
<h3 id="newitem-spec">newitem.spec</h3>
<p>As we designed the <a href="https://github.com/bustardcelly/grocery-ls/blob/0.1.3/script/controller/list-controller.js"><em>list-controller</em></a> from a <a href="http://custardbelly.com/blog/2012/12/06/the-making-of-a-test-driven-grocery-list-application-in-js-part-iii">previous article</a>, it oversaw the state of list items, list item views, and sort of supported a quasi-state of <em>‘editability’</em>. While this provided an API to create a new item, it was forced into exposing an <em>editableItem</em> that was then mutable based on other parts of its API – ie, <em>editFocusedItem()</em> and <em>saveFocusedItem()</em>. All well and good to support the feature requirements at the time, but we have now moved the item and item view management – as well as the editable state – to the latest <em>list-item-controller</em> as can be seen in the repo <a href="https://github.com/bustardcelly/grocery-ls/blob/0.1.5/script/controller/list-item-controller.js">tagged at 0.1.5</a>. As such, I feel not only the <em>list-controller</em>, itself, should change to reflect these modifications, but also its API.</p>
<p>We are going to stick with our feature request to be able to add a new item to the <strong>Grocery List</strong> application through the <em>list-controller</em>, but will revisit how that is done in accordance to the new functionality of both the <em>list-item-controller</em> and <em>list-controller</em>; mainly we want to keep in mind that both should be driven by their respective model: <em>grocery-ls-item</em> and <em>collection</em>.</p>
<p>Let’s first revisit the specs we defined for new item feature from <a href="http://custardbelly.com/blog/2012/11/26/the-making-of-a-test-driven-grocery-list-application-in-js-part-ii/">the second post</a> in this series:</p>
<p><em>// spec</em><br>—<br><strong>Scenario 1:</strong> Item added to list<br><strong>Given</strong> a user requests to add an item to the list<br><strong>And</strong> has provided a name for the item<br><strong>When</strong> she requests to save the item<br><strong>Then</strong> the list has grown by one item<br><strong>And</strong> the list contains the item appended at the end<br>—</p>
<p><em>// spec</em><br>—<br><strong>Scenario 2:</strong> Item not added to list<br><strong>Given</strong> the list has a single item<br><strong>And</strong> a user requests to add an item to the list<br><strong>And</strong> has not provided a name for the item<br><strong>When</strong> she requests to save the item<br><strong>Then</strong> the list has the same items as stored previously<br><strong>And</strong> the list does not add an empty-named item<br>—</p>
<p>In looking at them now, I feel that the actual <em>Add Item</em> feature is hidden in the <strong>Given</strong>s. A slight oversight now that we have progressed – perhaps one at the time as well, but we were delivering to features using TDD, so I have no qualms with features and implementations revisited and revised as the functionality of the application is fleshed out. In any event, I feel like these feature specs are more for a <em>Save Item</em> story, especially seeing as a User can edit an existing item. We’ll tackle the <em>Save Item</em> specifications for a later post, for now I want to revise the specifications for the <em>Add Item</em> feature.</p>
<h4 id="tests">Tests</h4>
<p>The original story does not change, but we want to ensure that a <em>grocery-ls-item</em> model is returned on the API to create a new item from <em>list-controller </em>. With such a drastic refactor to the functionality of <em>list-controller</em>, I tend to do my thinking and designing within the tests and move to implementation – just as I have done previously with other components. Let’s take a look at the change to <em>newitem.spec.js</em> as a whole and then discuss the specs singularly:</p>
<p><em>/test/jasmine/spec/feature.newitem.spec.js</em></p>
<pre><code><span class="hljs-function">define([<span class="hljs-string">'jquery'</span>, <span class="hljs-string">'script/controller/list-controller'</span>, <span class="hljs-string">'script/controller/list-item-controller'</span>,

        <span class="hljs-string">'script/collection/collection'</span>, <span class="hljs-string">'script/model/grocery-ls-item'</span>],

        <span class="hljs-function">function($, listController, itemControllerFactory, collectionFactory, modelFactory)</span> {



  <span class="hljs-function">describe(<span class="hljs-string">'New item creation from listController.createNewItem()'</span>, <span class="hljs-function">function()</span> {



    var newModel,

        newItemController,

        listControllerStub,

        $listView = $(<span class="hljs-string">'&lt;ul/&gt;'</span>)</span>,

        itemCollection = collectionFactory.<span class="hljs-function">create()</span>;



    <span class="hljs-function">beforeEach( <span class="hljs-function">function()</span> {

      var $itemView = $(<span class="hljs-string">'&lt;li&gt;'</span>)</span>;



      newModel = modelFactory.<span class="hljs-function">create()</span>;

      newItemController = itemControllerFactory.<span class="hljs-function">create($itemView, newModel)</span>;



      listControllerStub = sinon.<span class="hljs-function">stub(listController, <span class="hljs-string">'createNewItem'</span>, <span class="hljs-function">function()</span> {

        listController.<span class="hljs-function">getItemList()</span>.<span class="hljs-function">addItem(newModel)</span>;

        $itemView.<span class="hljs-function">appendTo($listView)</span>;

        return newModel;

      })</span>;

      listController.getItemList = sinon.<span class="hljs-function">stub()</span>.<span class="hljs-function">returns(itemCollection)</span>;

      listController.<span class="hljs-function">setView($listView)</span>;

    })</span>;



    <span class="hljs-function">it(<span class="hljs-string">'should return newly created model'</span>, <span class="hljs-function">function()</span> {

      var newItem = listController.<span class="hljs-function">createNewItem()</span>;

      // loosely (duck-ly)</span> verifying grocery-ls-item type.

      <span class="hljs-function">expect(newItem)</span><span class="hljs-class">.toEqual</span>(jasmine<span class="hljs-class">.any</span>(<span class="hljs-tag">Object</span>));

      <span class="hljs-function">expect(newItem.<span class="hljs-function">hasOwnProperty(<span class="hljs-string">'name'</span>)</span>)</span><span class="hljs-class">.toBe</span>(true);

      <span class="hljs-function">expect(newItem.<span class="hljs-function">hasOwnProperty(<span class="hljs-string">'id'</span>)</span>)</span><span class="hljs-class">.toBe</span>(true);

      <span class="hljs-function">expect(newItem.id)</span><span class="hljs-class">.not</span><span class="hljs-class">.toBeUndefined</span>();

    });



    <span class="hljs-function">it(<span class="hljs-string">'should add newly created item to collection'</span>, <span class="hljs-function">function()</span> {

      var newItem = listController.<span class="hljs-function">createNewItem()</span>,

          itemList = listController.<span class="hljs-function">getItemList()</span>;

      <span class="hljs-function">expect(itemList.<span class="hljs-function">itemLength()</span>)</span>.not.<span class="hljs-function">toBe(<span class="hljs-number">0</span>)</span>;

      <span class="hljs-function">expect(itemList.<span class="hljs-function">getItemAt(itemList.<span class="hljs-function">itemLength()</span>-<span class="hljs-number">1</span>)</span>)</span>.<span class="hljs-function">toEqual(newItem)</span>;

    })</span>;



    <span class="hljs-function">it(<span class="hljs-string">'should add new item controller to view'</span>, <span class="hljs-function">function()</span> {

      listController.<span class="hljs-function">createNewItem()</span>;

      <span class="hljs-function">expect($listView.<span class="hljs-function">children()</span>.length)</span>.<span class="hljs-function">toBe(<span class="hljs-number">1</span>)</span>;

    })</span>;



    <span class="hljs-function">afterEach( <span class="hljs-function">function()</span> {

      $listView.<span class="hljs-function">empty()</span>;

      newModel = undefined;

      newItemController = undefined;

      itemCollection.<span class="hljs-function">removeAll()</span>;

      listController.createNewItem.<span class="hljs-function">restore()</span>;

    })</span>;



  });



});
</code></pre><p>First off, you may notice that we are pulling in, as dependencies, every component we have basically created up to this point. Then, within the <em>beforeEach()</em> of the spec suite, using <a href="http://sinonjs.org/">SinonJS</a> we stub out the redesign and addition(s) to the API of <em>list-controller</em>; we are redefining the functionality of <em>createNewItem()</em> (which currently exists on <em>list-controller</em>) to return a <em>grocery-ls-item</em> instance and stubbing the <em>getItemList(</em>) method which will return the underlying collection model.</p>
<p>You may notice that i am using sinon.stub in two different ways:</p>
<pre><code>listControllerStub = sinon.stub(listController, <span class="hljs-string">'createNewItem'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

listController.getItemList = sinon.stub().returns(itemCollection);
</code></pre><p>The former allows for you to redefine the function invoked upon the public method – in this case ‘<em>createNewItem</em>‘. In order to properly define a stub in such a manner without being shown errors in executing the tests, the method must already be available on the object you are stubbing. The latter allows you to stub a method that is not currently on the object. As you may notice, the instantiation of the two different stubs are different in their assignment on the object being stubbed. The operations within these stubs shouldn’t be taken as set in stone – they may change once we get to implementation in <em>list-controller</em> – but they setup our expectations that will be verified in the specifications. The first of which ensures the return of a <em>grocery-ls-item</em> through property assertions:</p>
<p><em>/test/jasmine/spec/feature/newitem.spec.js</em></p>
<pre><code><span class="hljs-function">it(<span class="hljs-string">'should return newly created model'</span>, <span class="hljs-function">function()</span> {

  var newItem = listController.<span class="hljs-function">createNewItem()</span>;

  // loosely (duck-ly)</span> verifying grocery-ls-item type.

  <span class="hljs-function">expect(newItem)</span><span class="hljs-class">.toEqual</span>(jasmine<span class="hljs-class">.any</span>(<span class="hljs-tag">Object</span>));

  <span class="hljs-function">expect(newItem.<span class="hljs-function">hasOwnProperty(<span class="hljs-string">'name'</span>)</span>)</span><span class="hljs-class">.toBe</span>(true);

  <span class="hljs-function">expect(newItem.<span class="hljs-function">hasOwnProperty(<span class="hljs-string">'id'</span>)</span>)</span><span class="hljs-class">.toBe</span>(true);

  <span class="hljs-function">expect(newItem.id)</span><span class="hljs-class">.not</span><span class="hljs-class">.toBeUndefined</span>();

});
</code></pre><p>The second spec tests that the newly created item is added to the collection exposed on list-controller:<br><em>/test/jasmine/spec/feature/newitem.spec.js</em></p>
<pre><code><span class="hljs-function">it(<span class="hljs-string">'should add newly created item to collection'</span>, <span class="hljs-function">function()</span> {

  var newItem = listController.<span class="hljs-function">createNewItem()</span>,

      itemList = listController.<span class="hljs-function">getItemList()</span>;

  <span class="hljs-function">expect(itemList.<span class="hljs-function">itemLength()</span>)</span>.not.<span class="hljs-function">toBe(<span class="hljs-number">0</span>)</span>;

  <span class="hljs-function">expect(itemList.<span class="hljs-function">getItemAt(itemList.<span class="hljs-function">itemLength()</span>-<span class="hljs-number">1</span>)</span>)</span>.<span class="hljs-function">toEqual(newItem)</span>;

})</span>;
</code></pre><p>And the third spec… well, it starts to address some of the expectations a User may have when using the <strong>Grocery List</strong> application, something we really haven’t tested for as of yet – you have to start somewhere, though, right? We are testing that in addition to a new model added to the collection, there is an associated view in the UI (or at least presumably):<br><em>/test/jasmine/spec/feature/newitem.spec.js</em></p>
<pre><code><span class="hljs-function">it(<span class="hljs-string">'should add new item controller to view'</span>, <span class="hljs-function">function()</span> {

  listController.<span class="hljs-function">createNewItem()</span>;

  <span class="hljs-function">expect($listView.<span class="hljs-function">children()</span>.length)</span>.<span class="hljs-function">toBe(<span class="hljs-number">1</span>)</span>;

})</span>;
</code></pre><p>I think we will start to see more of these type of tests as we start fleshing out the features more. </p>
<p>Actually, I have started taking steps in moving the separation of <em>integration tests</em> from <em>feature tests</em>, if you haven’t already noticed the update to the location of <em>newitem.spec.js</em>. In my mind, the difference is between what I consider tests of how a component behaves itself (and with others) and test which describe the actual use of the application, respectively.</p>
<p>Run the tests just as you have before with the updates to the feature spec locations:<br><em>/test/jasmine/specrunner.html</em></p>
<pre><code><span class="hljs-keyword">require</span>( [<span class="hljs-string">'spec/feature/additem.spec.js'</span>, <span class="hljs-string">'spec/feature/markitem.spec.js'</span>,

          <span class="hljs-string">'spec/item-controller.spec.js'</span>, <span class="hljs-string">'spec/grocery-ls-item.spec.js'</span>,

          <span class="hljs-string">'spec/collection.spec.js'</span>], <span class="hljs-keyword">function</span>() {



  var jasmineEnv = jasmine.getEnv(),

       <span class="hljs-keyword">...</span>

  jasmineEnv.execute();



});
</code></pre><p>And all is green! <img src="http://custardbelly.com/blog/wp-includes/images/smilies/icon_smile.gif" alt=":)"></p>
<p>Tagged <strong>0.1.7</strong> – <a href="https://github.com/bustardcelly/grocery-ls/tree/0.1.7"><a href="https://github.com/bustardcelly/grocery-ls/tree/0.1.7">https://github.com/bustardcelly/grocery-ls/tree/0.1.7</a></a></p>
<h3 id="list-controller-revisted">list-controller Revisted</h3>
<p>It’s great that the tests still pass, but we have yet to <strong>still</strong> modify <em>list-controller</em>. I can’t put it off any longer. If you have put up with the last couple posts and promises to get somewhere, you are very kind. The wait is over! … but it is also just the tip of the iceberg. sorry to be a downer <img src="http://custardbelly.com/blog/wp-includes/images/smilies/icon_smile.gif" alt=":)"></p>
<p>In looking at the API on <em>list-controller</em> we stubbed out from the <em>beforeEach()</em> of the <em>newitem.spec</em> and the expectations of its functionality verified in the specs, we are basically boiling down the responsibilities of the <em>list-controller</em> to:</p>
<ul>
<li>Create a new item</li>
<li>Add item views to a provided element</li>
<li>Manage and respond to changes on a collection of <em>grocery-ls-item</em></li>
</ul>
<p>As a start, we can include the new dependencies and refactor the <em>list-controller</em> component to support these requirements:<br><em>/script/controller/list-controller.js</em></p>
<pre><code>define([<span class="hljs-string">'jquery'</span>, <span class="hljs-string">'script/controller/list-item-controller'</span>, <span class="hljs-string">'script/collection/collection'</span>, <span class="hljs-string">'script/model/grocery-ls-item'</span>],

        <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">($, itemControllerFactory, collectionFactory, modelFactory)</span> {</span>



  <span class="hljs-keyword">var</span> collection = collectionFactory.create(),

      listController = {

        $view: <span class="hljs-literal">undefined</span>,

        getItemList: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

          <span class="hljs-keyword">return</span> collection;

        },

        createNewItem: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

          <span class="hljs-keyword">var</span> model = modelFactory.create();

          collection.addItem(model);

          <span class="hljs-keyword">return</span> model;

        },

        setView: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(view)</span> {</span>

          <span class="hljs-keyword">this</span>.$view = (view <span class="hljs-keyword">instanceof</span> $) ? view : $(view);

        }

      };



  <span class="hljs-keyword">return</span> listController;



});
</code></pre><p>Differing from the stub created for <em>createNewItem()</em> in the <em>newitem.spec</em>, the <em>list-controller</em> is only concerned with updating the collection model here. This is because the change to the collection will drive updates to the UI and we don’t want to have the UI operations within the <em>createNewItem()</em> method – that will basically create a doubling-up of efforts. It will be the responsibility of this module to observe changes to the collection and update state. That is done by adding an event handler to <em>collection-change</em> and operating accordingly based on event <em>kind</em>:</p>
<p><em>/script/controller/list-controller.js</em></p>
<pre><code>define([<span class="hljs-string">'jquery'</span>, <span class="hljs-string">'script/controller/list-item-controller'</span>, <span class="hljs-string">'script/collection/collection'</span>, <span class="hljs-string">'script/model/grocery-ls-item'</span>],

        <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">($, itemControllerFactory, collectionFactory, modelFactory)</span> {</span>



  <span class="hljs-keyword">var</span> collection = collectionFactory.create(),

      listController = {

        <span class="hljs-variable">$view</span>: undefined,

        getItemList: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

          <span class="hljs-keyword">return</span> collection;

        },

        createNewItem: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

          <span class="hljs-keyword">var</span> model = modelFactory.create();

          collection.addItem(model);

          <span class="hljs-keyword">return</span> model;

        },

        setView: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(view)</span> {</span>

          this.<span class="hljs-variable">$view</span> = (view <span class="hljs-keyword">instanceof</span> $) ? view : $(view);

        }

      };



  (<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">assignCollectionHandlers</span><span class="hljs-params">(<span class="hljs-variable">$collection</span>)</span> {</span>



    <span class="hljs-keyword">var</span> EventKindEnum = collectionFactory.collectionEventKind;



    <span class="hljs-variable">$collection</span>.on(<span class="hljs-string">'collection-change'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(event)</span> {</span>

      <span class="hljs-keyword">switch</span>( event.kind ) {

        <span class="hljs-keyword">case</span> EventKindEnum.ADD:

          <span class="hljs-keyword">var</span> model = event.items.shift(),

              <span class="hljs-variable">$itemView</span> = $(<span class="hljs-string">'&lt;li&gt;'</span>),

              itemController = itemControllerFactory.create(<span class="hljs-variable">$itemView</span>, model);



          <span class="hljs-variable">$itemView</span>.appendTo(listController.<span class="hljs-variable">$view</span>);

          itemController.state = itemControllerFactory.state.EDITABLE;

          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> EventKindEnum.REMOVE:

          <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> EventKindEnum.RESET:

          <span class="hljs-keyword">break</span>;

      }

    });



  }($(collection)));



  <span class="hljs-keyword">return</span> listController;



});
</code></pre><p>We are calling an <strong><a href="http://benalman.com/news/2010/11/immediately-invoked-function-expression/">IIFE</a></strong> with the <a href="http://jquery.org">jQuery</a> wrapped collection object and assigning an event handler to <em>collection-change</em> on the collection. Depending on the kind of <em>collection-change</em> event that has occurred, defined clauses with specified operations are entered – for the purposes of the current task and tests at hand, that is only the <em>ADD</em> event.</p>
<p>In the <em>EventKindEnum.ADD</em> switch..case you will see the UI modification, with the addition of the list item view and the editability state of its associated <em>list-item-controller</em> set to allow the User to edit the new item.</p>
<p>Now, with the implementation of the <em>Add Item</em> feature moved to <em>list-controller</em>, we can clean up our <em>newitem.spec.js</em>:<br><em>/test/jasmine/spec/feature/newitem.spec.js</em></p>
<pre><code><span class="hljs-function">define([<span class="hljs-string">'jquery'</span>, <span class="hljs-string">'script/controller/list-controller'</span>],

        <span class="hljs-function">function($, listController)</span> {



  <span class="hljs-function">describe(<span class="hljs-string">'New item creation from listController.createNewItem()'</span>, <span class="hljs-function">function()</span> {



    var $listView = $(<span class="hljs-string">'&lt;ul/&gt;'</span>)</span>;



    <span class="hljs-function">beforeEach( <span class="hljs-function">function()</span> {

      listController.<span class="hljs-function">setView($listView)</span>;

    })</span>;



    <span class="hljs-function">it(<span class="hljs-string">'should return newly created model'</span>, <span class="hljs-function">function()</span> {

      var newItem = listController.<span class="hljs-function">createNewItem()</span>;

      // loosely (duck-ly)</span> verifying grocery-ls-item type.

      <span class="hljs-function">expect(newItem)</span>.<span class="hljs-function">toEqual(jasmine.<span class="hljs-function">any(Object)</span>)</span>;

      <span class="hljs-function">expect(newItem.<span class="hljs-function">hasOwnProperty(<span class="hljs-string">'name'</span>)</span>)</span>.<span class="hljs-function">toBe(true)</span>;

      <span class="hljs-function">expect(newItem.<span class="hljs-function">hasOwnProperty(<span class="hljs-string">'id'</span>)</span>)</span>.<span class="hljs-function">toBe(true)</span>;

      <span class="hljs-function">expect(newItem.id)</span>.not.<span class="hljs-function">toBeUndefined()</span>;

    })</span>;



    <span class="hljs-function">it(<span class="hljs-string">'should add newly created item to collection'</span>, <span class="hljs-function">function()</span> {

      var newItem = listController.<span class="hljs-function">createNewItem()</span>,

          itemList = listController.<span class="hljs-function">getItemList()</span>;

      <span class="hljs-function">expect(itemList.<span class="hljs-function">itemLength()</span>)</span>.not.<span class="hljs-function">toBe(<span class="hljs-number">0</span>)</span>;

      <span class="hljs-function">expect(itemList.<span class="hljs-function">getItemAt(itemList.<span class="hljs-function">itemLength()</span>-<span class="hljs-number">1</span>)</span>)</span>.<span class="hljs-function">toEqual(newItem)</span>;

    })</span>;



    <span class="hljs-function">it(<span class="hljs-string">'should add new item controller to view'</span>, <span class="hljs-function">function()</span> {

      listController.<span class="hljs-function">createNewItem()</span>;

      <span class="hljs-function">expect($listView.<span class="hljs-function">children()</span>.length)</span>.<span class="hljs-function">toBe(<span class="hljs-number">1</span>)</span>;

    })</span>;



    <span class="hljs-function">afterEach( <span class="hljs-function">function()</span> {

      $listView.<span class="hljs-function">empty()</span>;

    })</span>;



  });



});
</code></pre><p>And we’ll modify the main application module to reflect the change to the <em>list-controller</em> now only governing over a list DOM element and not to manage events from the add button on the DOM:</p>
<p><em>/script/grocery-ls.js</em></p>
<pre><code><span class="hljs-list">(<span class="hljs-title">function</span><span class="hljs-list">(<span class="hljs-title">window</span>, require)</span> <span class="hljs-collection">{



  require.config<span class="hljs-list">(<span class="hljs-collection">{

    baseUrl: <span class="hljs-string">"."</span>,

    paths: <span class="hljs-collection">{

      <span class="hljs-string">"lib"</span>: <span class="hljs-string">"./lib"</span>,

      <span class="hljs-string">"script"</span>: <span class="hljs-string">"./script"</span>,

      <span class="hljs-string">"jquery"</span>: <span class="hljs-string">"./lib/jquery-1.8.3.min"</span>

    }</span>

  }</span>)</span><span class="hljs-comment">;</span>



  require<span class="hljs-list">( <span class="hljs-collection">['jquery', 'script/controller/list-controller', 'script/collection/collection']</span>,

            function<span class="hljs-list">(<span class="hljs-title">$</span>, listController, collectionFactory)</span> <span class="hljs-collection">{



    listController.setView<span class="hljs-list">(<span class="hljs-title">$</span><span class="hljs-list">(<span class="hljs-title">'section.groceries</span> ul')</span>)</span><span class="hljs-comment">;</span>

    $<span class="hljs-list">(<span class="hljs-title">'section.groceries</span> #add-item-button')</span>.on<span class="hljs-list">(<span class="hljs-title">'click'</span>, function<span class="hljs-list">(<span class="hljs-title">event</span>)</span> <span class="hljs-collection">{

      listController.createNewItem<span class="hljs-list">()</span><span class="hljs-comment">;</span>

    }</span>)</span><span class="hljs-comment">;</span>



  }</span>)</span><span class="hljs-comment">;</span>



}</span><span class="hljs-list">(<span class="hljs-title">window</span>, requirejs)</span>)</span><span class="hljs-comment">;</span>
</code></pre><p>Run the tests… and it will fail! Yay!<br><img src="http://custardbelly.com/blog/images/tdd_js/part_v_3.png" alt="Failing tests on list-controller refactor"></p>
<p><em>wait, what?!</em></p>
<p>Actually, most will pass – including the <em>newitem.spec</em> tests. It is the <em>markitem.spec</em> tests that will fail. We have modified the <em>list-controller</em> to accomodate the changes to the <em>Add Item</em> feature, but have not addressed the <em>Mark Off Item</em> feature in our refactoring.</p>
<p><img src="http://custardbelly.com/blog/images/tdd_js/part_v_4.png" alt="Mark-Off Item failure on list-controller refactor"></p>
<p>However, run the application and it will be just as usable as it was before – no change will be perceived by the end-user. The only thing that will change is now I have a nagging feeling knowing my tests are failing. Some naysayers may interject here and half-heartedly tell me to get rid of the tests, then. To them I say, ‘<em>pfffft</em>‘ <img src="http://custardbelly.com/blog/wp-includes/images/smilies/icon_smile.gif" alt=":)"></p>
<p>I hate to see the tests in such a state, but this post is rather long as it is. Also, I like to joke that sometimes having failing tests to look at first thing in the morning is the best way to pick up from where you left off. I promise we’ll get these to go green in the next article of this series, and invite you to get them to pass if you are for it.</p>
<p>Tagged <strong>0.1.8</strong> – <a href="https://github.com/bustardcelly/grocery-ls/tree/0.1.8"><a href="https://github.com/bustardcelly/grocery-ls/tree/0.1.8">https://github.com/bustardcelly/grocery-ls/tree/0.1.8</a></a></p>
<h2 id="conclusion">Conclusion</h2>
<p>We finally got around to refactoring the <em>list-controller</em> to relieve it of item model management and state. In the course of doing so, we created a <em>Collection</em> object that will serve as the model for the <em>list-controller</em>. </p>
<p>This post was a lengthy one, and I appreciate you sticking through my yackity-yack. I think we are in fine shape now to approach previously defined and new features, get our tests passing again, and finalize the <strong>Grocery List</strong> application… in as far as first iteration deliverables go <img src="http://custardbelly.com/blog/wp-includes/images/smilies/icon_smile.gif" alt=":)"></p>
<p>‘Til next time…</p>
<p>—</p>
<h1 id="link-dump">Link Dump</h1>
<h2 id="reference">Reference</h2>
<p><a href="http://tddjs.com/">Test-Driven JavaScript Development by Christian Johansen</a><br><a href="http://dannorth.net/introducing-bdd/">Introducing BDD by Dan North</a><br><a href="http://requirejs.org/">RequireJS</a><br><a href="https://github.com/amdjs/amdjs-api/wiki/AMD">AMD</a><br><a href="http://pivotal.github.com/jasmine/">Jasmine</a><br><a href="http://sinonjs.org/">Sinon</a><br><a href="https://github.com/derickbailey/jasmine.async">Jasmine.Async</a></p>
<h2 id="post-series">Post Series</h2>
<p><a href="https://github.com/bustardcelly/grocery-ls">grocery-ls github repo</a><br><a href="http://custardbelly.com/blog/2012/11/26/the-making-of-a-test-driven-grocery-list-application-in-javascript-part-i">Part I – Introduction</a><br><a href="http://custardbelly.com/blog/2012/11/26/the-making-of-a-test-driven-grocery-list-application-in-js-part-ii">Part II – Feature: Add Item</a><br><a href="http://custardbelly.com/blog/2012/12/06/the-making-of-a-test-driven-grocery-list-application-in-js-part-iii">Part III – Feature: Mark-Off Item</a><br><a href="http://custardbelly.com/blog/2012/12/17/the-making-of-a-test-driven-grocery-list-application-in-js-part-iv">Part IV – Feature: List-Item-Controller</a><br><a href="http://custardbelly.com/blog/2012/12/31/the-making-of-a-test-driven-grocery-list-application-in-js-part-v/">Part V – Feature: List-Controller Refactoring</a><br><a href="http://custardbelly.com/blog/2013/01/08/the-making-of-a-test-driven-grocery-list-application-in-js-part-vi/">Part VI – Back to Passing</a><br><a href="http://custardbelly.com/blog/2013/01/17/the-making-of-a-test-driven-grocery-list-application-in-js-part-vii/">Part VII – Remove Item</a><br><a href="http://custardbelly.com/blog/2013/01/22/the-making-of-a-test-driven-grocery-list-application-part-viii/">Part VIII – Bug Fixing</a><br><a href="http://custardbelly.com/blog/2013/02/15/the-making-of-a-test-driven-grocery-list-application-in-js-part-ix/">Part IX – Persistence</a><br><a href="http://custardbelly.com/blog/2013/03/06/the-making-of-a-test-driven-grocery-list-application-in-js-part-x/">Part X – It Lives!</a></p>
<p>Posted in <a href="http://custardbelly.com/blog/category/amd/">AMD</a>, <a href="http://custardbelly.com/blog/category/javascript/">JavaScript</a>, <a href="http://custardbelly.com/blog/category/requirejs/">RequireJS</a>, <a href="http://custardbelly.com/blog/category/grocery-ls/">grocery-ls</a>, <a href="http://custardbelly.com/blog/category/jasmine/">jasmine</a>, <a href="http://custardbelly.com/blog/category/unit-testing/">unit-testing</a>.</p>
]]></description><link>http://custardbelly.com/blog/blog-posts/2012/12/31/the-making-of-a-test-driven-grocery-list-application-in-js-part-v/index.html</link><guid isPermaLink="true">http://custardbelly.com/blog/blog-posts/2012/12/31/the-making-of-a-test-driven-grocery-list-application-in-js-part-v/index.html</guid><dc:creator><![CDATA[Todd Anderson]]></dc:creator><pubDate>Invalid Date</pubDate></item></channel></rss>