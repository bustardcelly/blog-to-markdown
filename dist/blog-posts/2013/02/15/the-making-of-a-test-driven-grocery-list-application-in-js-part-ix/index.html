<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
    <meta content="width=device-width, initial-scale=1, user-scalable=no" name="viewport">
    <meta name="description" content="Todd Anderson makes things for web, mobile, desktop and land with a passion of application architecture and development workflows.">
    <meta name="keywords" content="todd anderson, anderson, programmer, developer, architect, engineer, software, software development, programming, application, ria, architecture, javascript, html5, css, web, mobile, desktop, arduino, actionscript, flex, flash, python">
    <link rel="stylesheet" type="text/css" href="http://custardbelly.com/blog/style/main.css" media="all" />
    <link rel="stylesheet" type="text/css" href="http://custardbelly.com/blog/lib/highlight/styles/github.css" media="all" />
    <link rel="alternate" type="application/rss+xml" title="Todd Anderson - feed" href="http://custardbelly.com/blog/index.xml" />
    <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Playfair+Display">
    <title>Todd Anderson - The Making of a Test-Driven Grocery List Application in JS: Part IX</title>
  </head>
  <body>
    <header>
      <h1><a class="header-link" href="http://custardbelly.com/blog/">Todd Anderson</a></h1>
      <h2>I make things for the web, mobile, desktop and land.</h2>
      <ul id="media-list">
        <li>
          <a href="http://custardbelly.com/blog/index.xml">
            <img src="http://custardbelly.com/blog/asset/social70.svg" onerror="this.src=http://custardbelly.com/blog/asset/social70.png" width="32" height="32">
          </a>
        </li>
        <li>
          <a href="http://twitter.com/_toddanderson_">
            <img src="http://custardbelly.com/blog/asset/twitter12.svg" onerror="this.src=http://custardbelly.com/blog/asset/twitter12.png" width="32" height="32">
          </a>
        </li>
        <li>
          <a href="https://github.com/bustardcelly">
            <img src="http://custardbelly.com/blog/asset/github7.svg" onerror="this.src=http://custardbelly.com/blog/asset/github7.png" width="32" height="32">
          </a>
        </li>
        <li>
          <a href="https://plus.google.com/113716114429928674625/posts">
            <img src="http://custardbelly.com/blog/asset/google21.svg" onerror="this.src=http://custardbelly.com/blog/asset/google21.png" width="32" height="32">
          </a>
        </li>
        <li>
          <a href="http://lnkd.in/6GCvvR">
            <img src="http://custardbelly.com/blog/asset/linkedin2.svg" onerror="this.src=http://custardbelly.com/blog/asset/linkedin2.png" width="32" height="32">
          </a>
        </li>
      </ul>
    </header>
    <nav>
      <a href="http://custardbelly.com/blog/">home</a>&nbsp;&nbsp;|&nbsp;&nbsp;<a href="http://custardbelly.com/blog/archive.html">archives</a>&nbsp;&nbsp;|&nbsp;&nbsp;<a href="http://custardbelly.com/blog/blog-pages/about.html">about</a>
    </nav>

    <article class="post">
  <div class="title">
    <h1><a href="http://custardbelly.com/blog/blog-posts/2013/02/15/the-making-of-a-test-driven-grocery-list-application-in-js-part-ix/index.html">The Making of a Test-Driven Grocery List Application in JS: Part IX</a></h1>
    <p>
      2013 February 15th
      
        by todd anderson
      
    </p>
  </div>
  <section>
    <p><em>This is the ninth installment in a series of building a Test-Driven Grocery List application using <a href="http://pivotal.github.com/jasmine/">Jasmine</a> and <a href="http://requirejs.org">RequireJS</a>. To learn more about the intent and general concept of the series please visit <a href="http://custardbelly.com/blog/2012/11/26/the-making-of-a-test-driven-grocery-list-application-in-javascript-part-i/">The Making of a Test-Driven Grocery List Application in JavaScript: Part I</a></em><br>—</p>
<h1 id="introduction">Introduction</h1>
<p>In the <a href="http://custardbelly.com/blog/2013/01/22/the-making-of-a-test-driven-grocery-list-application-part-viii/">previous article</a>, we pretty much wrapped up all the user-based functionality and ended with a working <strong>Grocery List</strong> application that we could start using. There is one little snag though… no persistance. If you made this gloriously elaborate list that detailed everything you needed at the store, then closed the browser and reopened it, the list was gone! That will not do.</p>
<p>There are many factors and paradigms to consider in choosing the level of persistence when it comes to handling session and user based applications. Without introducing a discussion about authentication, when approaching the integration persistence you have to take into account system-based vs user-based persistence, client-side vs server-side storage, and – nowadays, more commonly – the cross pollination of the two: <a href="http://en.wikipedia.org/wiki/Occasionally_connected_computing">occasional-connectivity</a>. (<em>not to mention browser support in all this</em>) We won’t be getting into all of that <img src="http://custardbelly.com/blog/wp-includes/images/smilies/icon_smile.gif" alt=":)"> We’ll be using the <code>localStorage</code> of today’s modern browser.</p>
<p>The intent of this article in the series is to implement client-side, browser-based persistence for the <strong>Grocery List</strong> application. It would be nice to store our list remotely so it can be accessed by all browsers on all devices, but I feel it would introduce too many new libraries, software and concepts to this series. I will most likely add it personally after this series is over, and I invite you to as well – keeping in mind to do it using TDD <img src="http://custardbelly.com/blog/wp-includes/images/smilies/icon_smile.gif" alt=":)"> The most I can offer at this point, is to keep the code we will write clean enough to support such future endeavours.</p>
<h1 id="what-tests-to-modify-to-get-us-there-">What Tests to Modify to Get Us There?</h1>
<p>Good question. Let’s first think about what actions will prompt an update to the list in storage. Actually, if we look at the feature specs we have created throughout this series and separated out into the <code>/feature</code> directory itself, we pretty much have all the defined actions that will trigger an update to the stored list:<br><img src="http://custardbelly.com/blog/images/tdd_js/part_ix_1.png" alt="Spec listing"></p>
<p>All of these features are a result from interacting with the <code>list-controller</code>. My first inkling is to add responsibility to the <code>list-controller</code> so that, along with the other operations it handles in list management, it communicates with a service layer to update the <strong>Grocery List</strong> in storage. However, I think that would add too much burden on the <code>list-controller</code> and, when taking into account that requirements around storage may change, the introduction of such complexity into the <code>list-controller</code> may quickly make our tests feel chaotic.</p>
<p>As such, I propose that we should start off with the expectation that the <code>list-controller</code> will notify of its underlying collection having been modified, not only upon its change in length, but of the items within the collection, as well. We can then capture those events and forward them on to whichever service implementation we have without having to pass that dependency into the <code>list-controller</code> and burdening it with such communication.</p>
<h2 id="new-expectation-for-add-item">New Expectation for Add Item</h2>
<p>To start, let’s add a quick spec to the <em>Add Item</em> feature that defines an expectation from the <code>list-controller</code> to notify when an item has been added:</p>
<p><em>/test/jasmine/spec/feature/additem.spec.js</em></p>
<pre><code>async.<span class="keyword">it</span>('should dispatch a save-<span class="property">item</span> event', function(done) {

  var newItem;



  $(listController).<span class="keyword">on</span>('save-<span class="property">item</span>', function(event) {

    expect(event.<span class="property">item</span>).<span class="keyword">not</span>.toBeUndefined();

    $(listController).off('save-<span class="property">item</span>');

    done();

  });

  newItem = listController.createNewItem();

});</code></pre>
<p>In creating this expectation, we have also begun to define the actual make-up of the event we intend to receive: the event type being <code>save-item</code> and the access of the <code>item</code> that was saved.</p>
<p>Run it and we are red, as expected:<br><img src="http://custardbelly.com/blog/images/tdd_js/part_ix_2.png" alt="Failing test on add item event response"></p>
<p>Taking what we have defined as our expectation when an item is added, we’ll modify the list-controller to get this passing. First we’ll add a factory method to generate <code>save-item</code> events:</p>
<p><em>/script/controller/list-controller.js</em></p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">createSaveEvent</span><span class="params">(item)</span> {</span>

  <span class="keyword">var</span> event = $.Event(<span class="string">'save-item'</span>);

  event.item = item;

  <span class="keyword">return</span> event;

}</code></pre>
<p>Fairly straight-forward and similar to other event factory methods declared previously in this series. Since we are addressing an expectation of event notification on add of item, we know where in the list-controller we can add that dispatch – in response to the addition of an item on the collection:</p>
<p><em>/script/controller/list-controller.js</em></p>
<pre><code>$itemView<span class="preprocessor">.appendTo</span>(listController.$view)<span class="comment">;</span>

rendererList<span class="preprocessor">.addItem</span>(itemController)<span class="comment">;</span>

$(listController)<span class="preprocessor">.trigger</span>(createSaveEvent(model))<span class="comment">;</span>

itemController<span class="preprocessor">.state</span> = itemControllerFactory<span class="preprocessor">.state</span><span class="preprocessor">.EDITABLE</span><span class="comment">;</span></code></pre>
<p>Back in business.<br><img src="http://custardbelly.com/blog/images/tdd_js/part_ix_3.png" alt="Passing test on add item event response"></p>
<h2 id="new-expectation-for-remove-item">New Expectation for Remove Item</h2>
<p>Let’s quickly just do a similar modification to the <code>list-controller</code> with regards to the <em>Remove Item</em> feature. First we’ll append a spec in the <em>removeitem.spec</em> suite with an expectation of being notified on <code>remove-item</code>:</p>
<p><em>/test/jasmine/spec/feature/removeitem.spec.js</em></p>
<pre><code>async.<span class="keyword">it</span>('should dispatch a remove-<span class="property">item</span> event', function(done) {

  var removedItem;



  $(listController).<span class="keyword">on</span>('remove-<span class="property">item</span>', function(event) {

    expect(event.<span class="property">item</span>).<span class="keyword">not</span>.toBeUndefined();

    $(listController).off('remove-<span class="property">item</span>');

    done();

  });

  removedItem = listController.removeItem(groceryItem);

});</code></pre>
<p>Sparing you another image of the specrunner turning red, that will fail with the timeout that we saw before. We’ll fix that up by adding a trigger in the removal of an item from the collection handler in <code>list-controller</code>. First with the addition of a factory method for the <code>remove-item</code> event:</p>
<p><em>/script/controller/list-controller.js</em></p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">createRemoveEvent</span><span class="params">(item)</span> {</span>

  <span class="keyword">var</span> event = $.Event(<span class="string">'remove-item'</span>);

  event.item = item;

  <span class="keyword">return</span> event;

}</code></pre>
<p>And then with an additional line to the <code>remove</code> response on the collection:</p>
<p><em>/script/controller/list-controller.js</em></p>
<pre><code><span class="keyword">case</span> EventKindEnum.REMOVE:

  model = <span class="keyword">event</span>.items.shift();

  itemController = listController.getRendererFromItem(model),

  <span class="variable">$itemController</span> = <span class="variable">$(</span>itemController);



  <span class="keyword">if</span>(itemController) {

    <span class="variable">$itemView</span> = itemController.parentView;

    <span class="variable">$itemView</span>.remove();

    itemController.dispose();

    <span class="variable">$itemController</span>.off(<span class="string">'remove'</span>);

    <span class="variable">$itemController</span>.off(<span class="string">'commit'</span>);

    rendererList.removeItem(itemController);

    <span class="variable">$(</span>listController).trigger(createRemoveEvent(model));

  }

<span class="keyword">break</span>;</code></pre>
<p>Run the tests, and we are back to passing:<br><img src="http://custardbelly.com/blog/images/tdd_js/part_ix_4.png" alt="Passing on removal event from list-controller"></p>
<h2 id="new-expectation-for-save-item">New Expectation for Save Item</h2>
<p>Sort of repetitive, but we are on a roll… let’s go through the similar process to ensure that a notification for <code>save-item</code> is dispatched when the user has modified its name and committed it to the list – the <em>Save Item</em> feature we added in the <a href="http://custardbelly.com/blog/2013/01/22/the-making-of-a-test-driven-grocery-list-application-part-viii/">last article</a>.</p>
<p><em>/test/jasmine/spec/feature/saveitem.spec.js</em></p>
<pre><code>async.<span class="keyword">it</span>('should dispatch a save-<span class="property">item</span> event', function(done) {



  $(listController).<span class="keyword">on</span>('save-<span class="property">item</span>', function(event) {

    expect(event.<span class="property">item</span>).toEqual(<span class="property">item</span>);

    $(listController).off('save-<span class="property">item</span>');

    done();

  });



  <span class="property">item</span>.<span class="property">name</span> = itemName;

  itemRenderer.state = itemControllerFactory.state.UNEDITABLE;

});</code></pre>
<p>That’ll put us in the red with the same old timeout issue. Getting back to green, we’ll trigger the <code>save-item</code> event upon committal of the item to the list, which if you remember – and is described in the test – is in response to the <code>list-item-controller</code> notifying of change to the item model:</p>
<p><em>/test/jasmine/spec/feature/list-controller.js</em></p>
<pre><code><span class="variable">$itemController</span>.on(<span class="string">'commit'</span>, function(<span class="keyword">event</span>) {

  <span class="keyword">if</span>(!isValidValue(model.name)) {

    listController.removeItem(model);

  }

  <span class="keyword">else</span> {

    <span class="variable">$(</span>listController).trigger(createSaveEvent(model));

  }

});</code></pre>
<p>Back to green!<br><img src="http://custardbelly.com/blog/images/tdd_js/part_ix_5.png" alt="Passing on commital of item form list-item-controller"></p>
<p>The amount of those little dots just keeps growing. Makes you feel all warm inside. Cherish that, ’cause it will go away…</p>
<h3 id="hold-up">Hold Up</h3>
<p>Just stepping back, it may seem a little odd that we are calling <code>save-item</code> when we add and commit the item to the list; after all they are the same item, we do we need to notify on save multiple times? The reason being is that upon any modification to an item – including its existence – the store needs to be modified. We haven’t gotten into the service layer for storage yet, but it will be abstracted out that a response from save-item will be internally handled as whether to append the item (from add) or to update an item already existant (from commit). Until we get to that service layer implementation for <code>localStorage</code>, we’ll go about setting expectations of <code>save-item</code> notification on modification to an item.</p>
<p>Which actually brings up a good point… what about marking off an item? We will need to notify on change of an item being marked off, as well.</p>
<h2 id="new-expectation-for-mark-off-item">New Expectation for Mark-Off Item</h2>
<p>We tackled the <em>Mark-Off Item</em> feature a <a href="http://custardbelly.com/blog/2012/12/06/the-making-of-a-test-driven-grocery-list-application-in-js-part-iii/">while back</a> in this series. Just a quick refresher on the story:</p>
<p><em>// story</em><br>—<br><strong>Story</strong>: Item is marked off on grocery list</p>
<p><strong>In order to</strong> remember what items have already made it to the cart<br><strong>As a</strong> grocery shopper<br><strong>I want to</strong> mark an item as being attained on the grocery list.<br>—</p>
<p>We implemented the feature, and upon user press of the item while in non-edit mode, it toggles its <code>marked</code> property on the model and updates the UI to add or remove a <del>strikethrough</del> on the label.</p>
<p>We’ve got a spec suite for the <em>Mark-Off Item</em> feature already, so we’ll append an expectation for <code>save-item</code> to it just as we have done with the other feature specs in this article:</p>
<p><em>/test/jasmine/spec/feature/markitem.spec.js</em></p>
<pre><code>async.<span class="keyword">it</span>('should dispatch a save-<span class="property">item</span> event', function(done) {



   var <span class="keyword">timeout</span> = setTimeout(function() {

     clearTimeout(<span class="keyword">timeout</span>);

     $(listController).off('save-<span class="property">item</span>');

   }, jasmine.DEFAULT_TIMEOUT_INTERNAL);



  $(listController).<span class="keyword">on</span>('save-<span class="property">item</span>', function(event) {

    expect(event.<span class="property">item</span>).toBe(<span class="property">item</span>);

    $(listController).off('save-<span class="property">item</span>');

    done();

  });



  <span class="property">item</span>.marked = <span class="constant">true</span>;

});</code></pre>
<p>… and that will bring us back to failing.<br>The <code>timeout</code> placed in there is just to ensure that listener(s) to the <code>save-item</code> event are removed regardless of the async test timing out.</p>
<p>The resolution to the issue is a trickier one than those of the previous in this article, however. Currently the <code>list-item-controller</code> is the only component that actually concerned with this change in marked status. It is not concerned with notifying any other party of the change to its model. The model does, however, notify of any property changes. I see two ways in which we can get back to passing:</p>
<ol>
<li>Assign a handler for <code>property-change</code> on model when it is first created and returned from <code>listController.createNewItem()</code></li>
<li>Dispatch a <code>commit</code> event from <code>list-item-controller</code> on change to <code>marked</code> property on the underlying model</li>
</ol>
<p>While both options will most likely get us where we need to be, the former adds additional management to the <code>list-controller</code>; its already listening in on <code>commit</code> from its <code>list-item-controller</code> instance, so modifying the <code>list-item-controller</code> to notify of change to the <code>marked</code> property seems to be the path of least resistance.</p>
<p>We had previously set up the <code>commit</code> notification on response from leaving the <code>EDITABLE</code> state of the <code>list-item-controller</code>:</p>
<p><em>/script/controller/list-item-controller.js</em></p>
<pre><code>// append state-based item.

<span class="function"><span class="title">if</span><span class="params">(event.new<span class="variable">State</span> === state<span class="variable">Enum</span>.<span class="variable">UNEDITABLE</span>)</span> {

  <span class="title">controller</span>.<span class="title">parentView</span>.<span class="title">append</span><span class="params">(controller.$uneditable<span class="variable">View</span>)</span>;

  <span class="title">controller</span>.<span class="title">save</span><span class="params">()</span>;

}</code></pre>
<p>That implementation got us to passing previously in which we described the expectation of a user committing an item to the list with a valid name (un-empty string). Our issue at hand is to also invoke the <code>save()</code> method on <code>list-item-controller</code> when the <code>marked</code> property is modified. In thinking about it now, while the committal of an item is tied to the change of state, it runs a validation on the <code>name</code> property to ensure that the item can be added/kept in the collection – so, in actuality <code>commit</code> can be tied to property updates to the item model.</p>
<p>As such, let’s remove line <code>48</code> from the above snippet and insert the invocation of <code>save()</code> to the handler in <code>list-item-controller</code> for <code>property-change</code> on the model:</p>
<p><em>/script/controller/list-item-controller.js</em></p>
<pre><code>$(<span class="keyword">this</span>.model).<span class="literal">on</span>(<span class="string">'property-change'</span>, (<span class="reserved">function</span>(controller) {

  <span class="keyword">return</span> <span class="reserved">function</span>(event) {

    handlePropertyChange.call(<span class="literal">null</span>, controller, event);

    controller.save();

  };

}(<span class="keyword">this</span>)));</code></pre>
<p>Run the specrunner again…<br><img src="http://custardbelly.com/blog/images/tdd_js/part_ix_5_fail.png" alt="We broke it"></p>
<p>… and we broke it <img src="http://custardbelly.com/blog/wp-includes/images/smilies/icon_sad.gif" alt=":("></p>
<p>The reason for those X’s is due to the logic we have held in <code>list-controller</code> on save of an item: it checks it’s <code>name</code> property and removes it from the list if considered an invalid value – which an empty string is.</p>
<p>I sense some modification to such logic in the future, but for now we can get the tests back to passing by providing a <code>name</code> property value to the created item in our mark-item spec:</p>
<p>/tests/jasmine/spec/feature/markitem.spec.js</p>
<pre><code><span class="function"><span class="title">beforeEach</span><span class="params">( <span class="keyword">fun</span><span class="function_name">ction</span>() <span class="tuple">{

  item = list<span class="variable">Controller</span>.<span class="function_name">createNewItem</span>();

  item.name = 'apples';

}</span>);</code></pre>
<p><img src="http://custardbelly.com/blog/images/tdd_js/part_ix_6.png" alt="Passing on model property update"></p>
<p>We’re green!</p>
<p>Tagged <strong>0.1.13</strong>: <a href="https://github.com/bustardcelly/grocery-ls/tree/0.1.13"><a href="https://github.com/bustardcelly/grocery-ls/tree/0.1.13">https://github.com/bustardcelly/grocery-ls/tree/0.1.13</a></a></p>
<h3 id="settle-down">Settle Down</h3>
<p>We have verified our expectations of <code>save-item</code> and <code>remove-item</code> events being dispatched from <code>list-controller</code> – new and model updates issuing the former, removal issuing the later. The work we have done was to separate concerns and not burden the <code>list-controller</code> itself with service communication for persisting the <strong>Grocery List</strong> items across browser sessions, but we have yet to address the actual service layer implementation that will take all these notifications.</p>
<h2 id="storage-service">Storage Service</h2>
<p>The <code>storage-service</code> will provide a service layer for communication with storage – whether that be remote or local. It will serve as a facade to an existing storage of grocery list items persisted somewhere other than the current application session. For the purposes of this article, that persistence layer is going to be the <code>localStorage</code> of the browser.</p>
<p>While fleshing out the storage service and its API, we’ll <em>loosely</em> use the technique of <a href="http://coderetreat.org/facilitating/activities/tdd-as-if-you-meant-it">‘TDD as if you meant it’</a>. I say <em>loosely</em> in part because to fully do it and explain each step would be a lot of noise for this article; the main practice point to take away – and I hope I express – is that the component you are testing is actually being built while you make the expectations for it pass.</p>
<h3 id="tests">Tests</h3>
<p>To start, we’ll create a bare-bones module for our service layer:</p>
<p><em>/script/service/storage-service</em></p>
<pre><code><span class="function"><span class="title">define</span><span class="params">(['jquery'], <span class="keyword">fun</span><span class="function_name">ction</span>($) <span class="tuple">{



  var store = <span class="tuple">{}</span>;

  return store;



}</span>);</code></pre>
<p>And let’s create the beginnings of our test:</p>
<p><em>/test/jasmine/spec/storage-service.spec.js</em></p>
<pre><code><span class="title">define</span>(['jquery',<span class="string"> 'script/service/storage-service'</span>,<span class="string"> 'script/model/grocery-ls-item'</span>],

        function($, store, modelFactory) {



  describe('<span class="type">Grocery</span> <span class="type">List</span> storage-service', function() {



    describe('getItems()', function() {



      it('should return <span class="keyword">of</span> <span class="typedef"><span class="keyword">type</span> array', function<span class="container">()</span> <span class="container">{

        <span class="title">expect</span>(<span class="title">false</span>).<span class="title">toEqual</span>(<span class="title">true</span>);

      }</span>);</span>



      it('should return array <span class="keyword">of</span> grocery-ls-item <span class="typedef">types', function<span class="container">()</span> <span class="container">{

        <span class="title">expect</span>(<span class="title">false</span>).<span class="title">toEqual</span>(<span class="title">true</span>);

      }</span>);</span>



    });



  });



});</code></pre>
<p>In the test we have set up some tests for the <code>getItems()</code> method for the service. Prior to any implementation, it should be known that communication with the <code>storage-service</code> will be considered asynchronous – meaning all operations will return a <a href="http://api.jquery.com/category/deferred-object/">jQuery Deferred</a>. This will abstract out the storage proxy that will be employed by the <code>storage-service</code> and will respond in an asynchronous manner regardless of whether the store is immediately accessible – as in the case of <code>localStorage</code> – or remote.</p>
<p>Truthfully, in practice, I should only do one tests at a time, but we are testing the expectations for access of the same item listing; to save you from reading the ramblings of adding another test, I declared them both at the start.</p>
<p>Let’s stub out the API and start testing and building the <code>storage-service</code>:</p>
<p><em>/test/jasmine/spec/storage-service.spec.js</em></p>
<pre><code><span class="title">describe</span>('getItems()', function() {



  var items,

      itemOne = modelFactory.create(),

      itemTwo = modelFactory.create(),

      async = new <span class="type">AsyncSpec</span>(this);



  async.beforeEach( function(done) {

    var deferred = $.<span class="type">Deferred</span>(),

        getStub = sinon.stub().returns(deferred);



    deferred.resolve([itemOne, itemTwo]);

    store.getItems = getStub;



    store.getItems().<span class="keyword">then</span>(function(list) {

      items = list;

      done();

    });

  });



  afterEach( function() {

    //

  });



  it('should return <span class="keyword">of</span> <span class="typedef"><span class="keyword">type</span> array', function<span class="container">()</span> <span class="container">{

    <span class="title">expect</span>(<span class="type">Array</span>.<span class="title">isArray</span>(<span class="title">items</span>)).<span class="title">toEqual</span>(<span class="title">true</span>);

    <span class="title">expect</span>(<span class="title">items</span>.<span class="title">length</span>).<span class="title">toEqual</span>(2);

  }</span>);</span>



  it('should return array <span class="keyword">of</span> grocery-ls-item <span class="typedef">types', function<span class="container">()</span> <span class="container">{

    <span class="title">expect</span>(<span class="title">items</span>[0]).<span class="title">toBe</span>(<span class="title">itemOne</span>);

    <span class="title">expect</span>(<span class="title">items</span>[1]).<span class="title">toBe</span>(<span class="title">itemTwo</span>);

  }</span>);</span>



});</code></pre>
<p>In the <code>beforeEach()</code>, we’re using anonymous stubs from <a href="http://sinonjs.org/">SinonJS</a>, which allow us to stub out methods that may not necessarily already exist on an object. I have used it previously in this series, but we’ll be using it pretty much exclusively while we stub out the API for the <code>storage-service</code>.</p>
<p>Staying true to our idea that the service will provide an asynchronous communication layer, <code>getItems()</code> returns a deferred which has resolved to a listing of two <code>grocery-ls-item</code> instances in our tests.</p>
<p>Sometimes when working with a single feature, I like to isolate it out from my tests for a bit. Here is what the specrunner reports with running just <strong>storage-service.spec</strong>:<br><img src="http://custardbelly.com/blog/images/tdd_js/part_ix_7.png" alt="Passing on succss of getItems() in service"></p>
<p>We could move that implementation to <code>storage-service</code> module now, but we are sort of in a <a href="http://en.wikipedia.org/wiki/Chicken_or_the_egg">chicken-or-the-egg</a> scenario. We’ve canned the resolved <code>grocery-ls-item</code> list in the test, but how does the list get filled up in an actual scenario for <code>storage-service</code>? It’s an excellent question, and something I often puzzle myself with. I mean, we’ll need a <code>saveItem()</code> method no doubt in order to add items to the store. But shouldn’t that method now be stubbed out in a new test? And how do I test that <code>saveItem()</code> works without <code>getItems()</code> being already tested and verified? I could go in circles…</p>
<p>Let’s just stub out an <code>saveItem()</code> method on <code>storage-service</code> and, afterward, set expectations in another spec suite:</p>
<p><em>/test/jasmine/spec/storage-service.spec.js</em></p>
<pre><code>async<span class="preprocessor">.beforeEach</span>( function(done) {

  var <span class="keyword">call</span> = <span class="number">0</span>,

      tempList = [],

      deferred = $<span class="preprocessor">.Deferred</span>(),

      getStub = sinon<span class="preprocessor">.stub</span>()<span class="preprocessor">.returns</span>(deferred),

      saveStub = sinon<span class="preprocessor">.stub</span>()<span class="preprocessor">.callsArgOn</span>(<span class="number">0</span>, store),

      appendItem = function() {

        tempList<span class="preprocessor">.push</span>((<span class="keyword">call</span>++%<span class="number">2</span> === <span class="number">0</span>) ? itemOne : itemTwo)<span class="comment">;</span>

      }<span class="comment">;</span>



  store<span class="preprocessor">.saveItem</span> = saveStub<span class="comment">;</span>

  store<span class="preprocessor">.getItems</span> = getStub<span class="comment">;</span>



  store<span class="preprocessor">.saveItem</span>(appendItem)<span class="comment">;</span>

  store<span class="preprocessor">.saveItem</span>(appendItem)<span class="comment">;</span>

  store<span class="preprocessor">.getItems</span>()<span class="preprocessor">.then</span>(function(list) {

    items = list<span class="comment">;</span>

    done()<span class="comment">;</span>

  })<span class="comment">;</span>

  deferred<span class="preprocessor">.resolve</span>(tempList)<span class="comment">;</span>

})<span class="comment">;</span></code></pre>
<p>With these modifications, we have assigned an anonymous stub – <code>saveStub</code> – as the <code>saveItem</code> method on the <code>store</code> and specified that the function-local <code>appendItem</code> method should be invoked, appending items to the list prior to each of our tests. </p>
<p>A little more work in setup and slightly unrealistic in telling of the arguments to be given to <code>saveItem()</code>, but it kept us on green without having to hard code the result; it’s a litte truer to life than the previous setup, and still passes:</p>
<p><img src="http://custardbelly.com/blog/images/tdd_js/part_ix_7.png" alt="Passing on succss of getItems() in service"></p>
<h3 id="implementation">Implementation</h3>
<p>Alright, so I think we should move this out to <code>storage-service</code> now and trash the stubbing in the test – we’ve got our expectations:</p>
<p><em>/script/service/storage-service.js</em></p>
<pre><code><span class="function"><span class="title">define</span><span class="params">(['jquery'], <span class="keyword">fun</span><span class="function_name">ction</span>($) <span class="tuple">{



  var item<span class="variable">Cache</span> = [],

      store = <span class="tuple">{

        save<span class="variable">Item</span>: <span class="keyword">fun</span><span class="function_name">ction</span>(item) <span class="tuple">{

          var deferred = $.<span class="variable">Deferred</span>();

          item<span class="variable">Cache</span>[item<span class="variable">Cache</span>.length] = item;

          return deferred.<span class="function_name">resolve</span>(item);

        }</span>,

        get<span class="variable">Items</span>: <span class="keyword">fun</span><span class="function_name">ction</span>() <span class="tuple">{

          var deferred = $.<span class="variable">Deferred</span>();

          deferred.<span class="function_name">resolve</span>(item<span class="variable">Cache</span>);

          return deferred;

        }</span>

      };



  return store;



});</code></pre>
<p><em>/test/jasmine/spec/storage-service.spec.js</em></p>
<pre><code><span class="title">describe</span>('getItems()', function() {



  var items,

      itemOne = modelFactory.create(),

      itemTwo = modelFactory.create(),

      async = new <span class="type">AsyncSpec</span>(this);



  async.beforeEach( function(done) {

    store.saveItem(itemOne);

    store.saveItem(itemTwo);

    store.getItems().<span class="keyword">then</span>(function(value) {

      items = value;

      done();

    });

  });



  afterEach( function() {

    //

  });



  it('should return <span class="keyword">of</span> <span class="typedef"><span class="keyword">type</span> array', function<span class="container">()</span> <span class="container">{

    <span class="title">expect</span>(<span class="type">Array</span>.<span class="title">isArray</span>(<span class="title">items</span>)).<span class="title">toEqual</span>(<span class="title">true</span>);

    <span class="title">expect</span>(<span class="title">items</span>.<span class="title">length</span>).<span class="title">toEqual</span>(2);

  }</span>);</span>



  it('should return array <span class="keyword">of</span> grocery-ls-item <span class="typedef">types', function<span class="container">()</span> <span class="container">{

    <span class="title">expect</span>(<span class="title">items</span>[0]).<span class="title">toBe</span>(<span class="title">itemOne</span>);

    <span class="title">expect</span>(<span class="title">items</span>[1]).<span class="title">toBe</span>(<span class="title">itemTwo</span>);

  }</span>);</span>



});</code></pre>
<p>Run that, and we are still green!<br><img src="http://custardbelly.com/blog/images/tdd_js/part_ix_7.png" alt="Passing on succss of getItems() in service"></p>
<h3 id="tests">Tests</h3>
<p>Now that we can verify that <code>saveItem()</code> is working enough for our <code>getItem</code> spec, let’s properly set the expectations for <code>saveItem</code>, as well, in our tests:</p>
<p><em>/test/jasmine/spec/storage-service.spec.js</em></p>
<pre><code><span class="function"><span class="title">describe</span><span class="params">(<span class="function_name">'saveItem</span>()', <span class="keyword">fun</span><span class="function_name">ction</span>() <span class="tuple">{



  var item<span class="variable">One</span> = model<span class="variable">Factory</span>.<span class="function_name">create</span>(),

      item<span class="variable">Two</span> = model<span class="variable">Factory</span>.<span class="function_name">create</span>(),

      async = new <span class="variable">AsyncSpec</span>(this);



  <span class="function_name">beforeEach</span>( <span class="keyword">fun</span><span class="function_name">ction</span>() <span class="tuple">{

    store.<span class="function_name">saveItem</span>(item<span class="variable">One</span>);

  }</span>);



  <span class="function_name">afterEach</span>( <span class="keyword">fun</span><span class="function_name">ction</span>() <span class="tuple">{

    //

  }</span>);



  async.<span class="function_name">it</span>('should be grow the length of items', <span class="keyword">fun</span><span class="function_name">ction</span>(done) <span class="tuple">{

    store.<span class="function_name">getItems</span>().<span class="function_name">then</span>( <span class="keyword">fun</span><span class="function_name">ction</span>(items) <span class="tuple">{

      <span class="function_name">expect</span>(items.length).<span class="function_name">toEqual</span>(<span class="number">1</span>);

      <span class="function_name">done</span>();

    }</span>);

  });



});</code></pre>
<p>Simple enough. Back to the specrunner:<br><img src="http://custardbelly.com/blog/images/tdd_js/part_ix_8.png" alt="Failing on saveItem of storage-service"></p>
<p>Oh noes! Our expectation is that the length of items is only 1. We have only specified one addition of an item in the setup… where did the length of 5 come from!? Put down the abacus – there are better things to throw. But before that, I have an explanation: we haven’t been cleaning up. We have let <code>afterEach()</code> just quietly be invoked without a job to do.</p>
<p>To do just enough in getting our tests pass, we can update the <code>afterEach()</code> declarations in each spec suite to the following:</p>
<pre><code>async<span class="preprocessor">.afterEach</span>( function(done) {

  store<span class="preprocessor">.getItems</span>()<span class="preprocessor">.then</span>(function(items) {

    items<span class="preprocessor">.length</span> = <span class="number">0</span><span class="comment">;</span>

    done()<span class="comment">;</span>

  })<span class="comment">;</span>

})<span class="comment">;</span></code></pre>
<p>That will get us back to passing:<br><img src="http://custardbelly.com/blog/images/tdd_js/part_ix_9.png" alt="Passing on saveItem spec."></p>
<p>I am not particularly fond of that solution, however. Mainly because I think it conveys a usage of the API on <code>storage-service</code> that I would not condone: directly mutating the underlying list of <code>storage-service</code> from another party. </p>
<p>I’m not gonna get crazy with the lock-down and privacy of properties and start introducing the latest-and-greatest framework that tries to tout that they really are just a library all in the attempt to stop someone from directly accessing the underlying array of items on <code>storage-service</code>. If some developers gonna go crazy and do so, hopefully we can find it in more tests later or they can look at our tests as a guideline of how to do what they want. </p>
<p>As such, I think we should add a method to <code>storage-service</code> that simply allows for emptying the list. First the expectation:</p>
<p><em>/test/jasmine/spec/storage-service.spec.js</em></p>
<pre><code><span class="function"><span class="title">describe</span><span class="params">(<span class="function_name">'empty</span>()', <span class="keyword">fun</span><span class="function_name">ction</span>() <span class="tuple">{



  var item<span class="variable">One</span> = model<span class="variable">Factory</span>.<span class="function_name">create</span>(),

      item<span class="variable">Two</span> = model<span class="variable">Factory</span>.<span class="function_name">create</span>(),

      async = new <span class="variable">AsyncSpec</span>(this);



  <span class="function_name">beforeEach</span>( <span class="keyword">fun</span><span class="function_name">ction</span>() <span class="tuple">{

    store.<span class="function_name">saveItem</span>(item<span class="variable">One</span>);

    store.<span class="function_name">saveItem</span>(item<span class="variable">Two</span>);

  }</span>);



  <span class="function_name">afterEach</span>( <span class="keyword">fun</span><span class="function_name">ction</span>() <span class="tuple">{

    store.<span class="function_name">empty</span>();

  }</span>);



  async.<span class="function_name">it</span>('should be appended to the list of items', <span class="keyword">fun</span><span class="function_name">ction</span>(done) <span class="tuple">{

    store.<span class="function_name">empty</span>().<span class="function_name">then</span>( <span class="keyword">fun</span><span class="function_name">ction</span>(items) <span class="tuple">{

      <span class="function_name">expect</span>(items.length).<span class="function_name">toEqual</span>(<span class="number">0</span>);

      <span class="function_name">done</span>();

    }</span>);

  });



});</code></pre>
<p><img src="http://custardbelly.com/blog/images/tdd_js/part_ix_10.png" alt="Failing on empty()"></p>
<p><em>/script/service/storage-service.js</em></p>
<pre><code>define([<span class="string">'jquery'</span>], <span class="keyword">function</span>($) {



  <span class="keyword">var</span> itemCache = [],

      store = {

        saveItem: <span class="keyword">function</span>(item) {

          <span class="keyword">var</span> deferred = $.Deferred();

          itemCache[itemCache.length] = item;

          <span class="keyword">return</span> deferred.resolve(item);

        },

        getItems: <span class="keyword">function</span>() {

          <span class="keyword">var</span> deferred = $.Deferred();

          deferred.resolve(itemCache);

          <span class="keyword">return</span> deferred;

        },

        empty: <span class="keyword">function</span>() {

          <span class="keyword">var</span> deferred = $.Deferred();

          itemCache.length = <span class="number">0</span>;

          deferred.resolve(itemCache);

          <span class="keyword">return</span> deferred;

        }

      };



  <span class="keyword">return</span> store;

});</code></pre>
<p><img src="http://custardbelly.com/blog/images/tdd_js/part_ix_11.png" alt="Passing on empty()"></p>
<p>Alright! We are passing expectations on three parts of the API for <code>storage-service</code>. Now let’s think of what else we need… I think only a <code>removeItem()</code> method will suffice. In working as we have previously in this article – stubbing out methods to be added to the <code>storage-service</code> implementation – we can add a spec suite for <code>removeItem()</code> such as the following:</p>
<p><em>/test/jasmine/spec/storage-service.spec.js</em></p>
<pre><code><span class="function"><span class="title">describe</span><span class="params">(<span class="function_name">'removeItem</span>()', <span class="keyword">fun</span><span class="function_name">ction</span>() <span class="tuple">{



  var items,

      item<span class="variable">One</span> = model<span class="variable">Factory</span>.<span class="function_name">create</span>(),

      item<span class="variable">Two</span> = model<span class="variable">Factory</span>.<span class="function_name">create</span>(),

      async = new <span class="variable">AsyncSpec</span>(this),

      deferred = $.<span class="variable">Deferred</span>(),

      remove<span class="variable">ItemFromList</span> = <span class="keyword">fun</span><span class="function_name">ction</span>() <span class="tuple">{

        deferred.<span class="function_name">resolve</span>(items.<span class="function_name">splice</span>(<span class="number">0</span>, <span class="number">1</span>));

      }</span>;



  async.<span class="function_name">beforeEach</span>( <span class="keyword">fun</span><span class="function_name">ction</span>(done) <span class="tuple">{

    var remove<span class="variable">ItemStub</span> = sinon.<span class="function_name">stub</span>().<span class="function_name">returns</span>(deferred).<span class="function_name">callsArgOn</span>(<span class="number">0</span>, store);



    store.<span class="function_name">saveItem</span>(item<span class="variable">One</span>);

    store.<span class="function_name">saveItem</span>(item<span class="variable">Two</span>);

    store.remove<span class="variable">Item</span> = remove<span class="variable">ItemStub</span>;

    store.<span class="function_name">getItems</span>().<span class="function_name">then</span>( <span class="keyword">fun</span><span class="function_name">ction</span>(value) <span class="tuple">{

      items = value;

      <span class="function_name">done</span>();

    }</span>);

  });



  <span class="function_name">afterEach</span>( <span class="keyword">fun</span><span class="function_name">ction</span>() <span class="tuple">{

    store.<span class="function_name">empty</span>();

  }</span>);



  async.<span class="function_name">it</span>('should shorten length of the list', <span class="keyword">fun</span><span class="function_name">ction</span>(done) <span class="tuple">{

    store.<span class="function_name">removeItem</span>(remove<span class="variable">ItemFromList</span>).<span class="function_name">then</span>( <span class="keyword">fun</span><span class="function_name">ction</span>(item) <span class="tuple">{

      store.<span class="function_name">getItems</span>().<span class="function_name">then</span>( <span class="keyword">fun</span><span class="function_name">ction</span>(items) <span class="tuple">{

        <span class="function_name">expect</span>(items.length).<span class="function_name">toEqual</span>(<span class="number">1</span>);

        <span class="function_name">done</span>();

      }</span>);

    });

  });



});</code></pre>
<p><img src="http://custardbelly.com/blog/images/tdd_js/part_ix_12.png" alt="Passing on initial removeItem()"></p>
<p>I think there are more expectations to assert for the <code>removeItem()</code> spec suite, but for now we are passing and we’ll move the implementation over to <code>storage-service</code>:</p>
<p><em>/script/service/storage-service.js</em></p>
<pre><code>define([<span class="string">'jquery'</span>], <span class="keyword">function</span>($) {



  <span class="keyword">var</span> itemCache = [],

      store = {

        saveItem: <span class="keyword">function</span>(item) {

          <span class="keyword">var</span> deferred = $.Deferred();

          itemCache[itemCache.length] = item;

          <span class="keyword">return</span> deferred.resolve(item);

        },

        removeItem: <span class="keyword">function</span>(item) {

          <span class="keyword">var</span> deferred = $.Deferred(),

              itemIndex = itemCache.indexOf(item),

              removedItem;



          <span class="keyword">if</span>(itemIndex &gt; -<span class="number">1</span>) {

            itemCache.splice(itemIndex, <span class="number">1</span>);

            removedItem = item;

          }

          <span class="keyword">return</span> deferred.resolve(removedItem);

        },

        getItems: <span class="keyword">function</span>() {

          <span class="keyword">var</span> deferred = $.Deferred();

          deferred.resolve(itemCache);

          <span class="keyword">return</span> deferred;

        },

        empty: <span class="keyword">function</span>() {

          <span class="keyword">var</span> deferred = $.Deferred();

          itemCache.length = <span class="number">0</span>;

          deferred.resolve(itemCache);

          <span class="keyword">return</span> deferred;

        }

      };



  <span class="keyword">return</span> store;



});</code></pre>
<p>Now, we’ll update the spec suite for <code>removeItem()</code> and add a few more expectations to ensure the item removal process is correct:</p>
<p><em>/test/jasmine/spec/storage-service.spec.js</em></p>
<pre><code>describe('removeItem()', function() {



  var itemOne = modelFactory.create(),

      itemTwo = modelFactory.create(),

      async = new AsyncSpec(this);



  beforeEach( function() {

    itemOne.<span class="property">name</span> = 'one';

    store.saveItem(itemOne);

    store.saveItem(itemTwo);

  });



  afterEach( function() {

    store.empty();

  });



  async.<span class="keyword">it</span>('should shorten <span class="property">length</span> <span class="keyword">of</span> <span class="keyword">the</span> <span class="type">list</span>', function(done) {

    store.removeItem(itemOne).<span class="keyword">then</span>( function(<span class="property">item</span>) {

      store.getItems().<span class="keyword">then</span>( function(items) {

        expect(items.<span class="property">length</span>).toEqual(<span class="number">1</span>);

        done();

      });

    });

  });



  async.<span class="keyword">it</span>('should remove <span class="property">item</span> specified <span class="keyword">from</span> <span class="keyword">the</span> <span class="type">list</span>', function(done) {

    store.removeItem(itemOne).<span class="keyword">then</span>( function(<span class="property">item</span>) {

      store.getItems().<span class="keyword">then</span>( function(items) {

        expect(items.indexOf(itemOne)).toEqual(-<span class="number">1</span>);

        done();

      });

    });

  });



  async.<span class="keyword">it</span>('should <span class="constant">return</span> <span class="keyword">the</span> <span class="property">item</span> removed <span class="keyword">if</span> found', function(done) {

    store.removeItem(itemOne).<span class="keyword">then</span>( function(<span class="property">item</span>) {

      expect(<span class="property">item</span>).toEqual(itemOne);

      done();

    });

  });



  async.<span class="keyword">it</span>('should <span class="constant">return</span> undefined <span class="keyword">if</span> <span class="property">item</span> <span class="keyword">not</span> found', function(done) {

    store.removeItem(modelFactory.create()).<span class="keyword">then</span>( function(<span class="property">item</span>) {

      expect(<span class="property">item</span>).toBeUndefined();

      done();

    });

  });



});</code></pre>
<p>… and we’re still in business!<br><img src="http://custardbelly.com/blog/images/tdd_js/part_ix_13.png" alt="Complete and passing removeItem specs"></p>
<h3 id="revisiting-saveitem-">Revisiting saveItem()</h3>
<p>When we setup the <code>saveItem</code> stub for our <code>getItem()</code> spec suite, we really only focused on getting the expectations to pass. To get back to green – at the time – we were only concerned with appending items to the list. I think this needs to be looked at again.</p>
<p>If we remember back to the notifications we set up for the <code>list-controller</code>, it will dispatch a <code>save-item</code> event upon the existence of a new item, as well as the modification to an existing item. So we will pass that item through the <code>storage-service</code> using <code>saveItem()</code> but we don’t want to continually append items that are previously stored to the list – if so, we’d be buying a lot of <del>spinich</del> <del>spinnash</del> spinach.</p>
<p>Normally I wouldn’t cut corners: a feature spec should be written up for what I have described here prior to modifying the tests. To save you some scrolling, however, I decided to not include walking through one and letting the expectations that we define in the following speak for the specification.</p>
<p><em>/test/jasmine/spec/storage-service.spec.js</em></p>
<pre><code>describe('saveItem()', function() {



  var itemOne = modelFactory.create(),

      itemTwo = modelFactory.create(),

      async = new AsyncSpec(this);



  beforeEach( function() {

    store.saveItem(itemOne);

  });



  afterEach( function() {

    store.empty();

  });



  async.<span class="keyword">it</span>('should grow <span class="keyword">the</span> <span class="property">length</span> <span class="keyword">of</span> items <span class="function_start"><span class="keyword">on</span> <span class="title">new</span></span> <span class="property">item</span>', function(done) {

    store.getItems().<span class="keyword">then</span>( function(items) {

      expect(items.<span class="property">length</span>).toEqual(<span class="number">1</span>);

      done();

    });

  });



  async.<span class="keyword">it</span>('should <span class="keyword">not</span> grow <span class="keyword">the</span> <span class="property">length</span> <span class="keyword">of</span> items <span class="function_start"><span class="keyword">on</span> <span class="title">pre</span></span>-existing <span class="property">item</span>', function(done) {

    itemOne.<span class="property">name</span> = 'oranges';

    store.saveItem(itemOne).<span class="keyword">then</span>( function(<span class="property">item</span>) {

      store.getItems().<span class="keyword">then</span>( function(items) {

        expect(items.<span class="property">length</span>).toEqual(<span class="number">1</span>);

        done();

      });

    });

  });



});</code></pre>
<p>We modified the description of the original expectation to state that the items list should only grow on new existence and added a new expectation that previously stored items do not get appended to the stored list:</p>
<p><img src="http://custardbelly.com/blog/images/tdd_js/part_ix_14.png" alt="Failing update to saveItem() specs."></p>
<p>As expected <img src="http://custardbelly.com/blog/wp-includes/images/smilies/icon_smile.gif" alt=":)"> Let’s update <code>saveItem()</code> on the <code>storage-service</code> to account for this:</p>
<p><em>/script/service/storage-service.js</em></p>
<pre><code><span class="attribute">saveItem</span>: <span class="string">function(item) {</span>

<span class="avrasm">  var deferred = $<span class="preprocessor">.Deferred</span>(),

      index = itemCache<span class="preprocessor">.indexOf</span>(item)<span class="comment">;</span>

  if(index === -<span class="number">1</span>) {

    itemCache[itemCache<span class="preprocessor">.length</span>] = item<span class="comment">;</span>

  }

  return deferred<span class="preprocessor">.resolve</span>(item)<span class="comment">;</span>

}</span></code></pre>
<p><img src="http://custardbelly.com/blog/images/tdd_js/part_ix_15.png" alt="Passing on new expectation for saveItem()"></p>
<p>Not leaving any to chance, let’s add a couple more expectations as to how items are placed and how they remain in their places:</p>
<p><em>/test/jasmine/spec/storage-service.spec.js</em></p>
<pre><code><span class="function"><span class="title">describe</span><span class="params">(<span class="function_name">'saveItem</span>() multiples', <span class="keyword">fun</span><span class="function_name">ction</span>() <span class="tuple">{



  var item<span class="variable">One</span> = model<span class="variable">Factory</span>.<span class="function_name">create</span>(),

      item<span class="variable">Two</span> = model<span class="variable">Factory</span>.<span class="function_name">create</span>(),

      async = new <span class="variable">AsyncSpec</span>(this);



  <span class="function_name">beforeEach</span>( <span class="keyword">fun</span><span class="function_name">ction</span>() <span class="tuple">{

    store.<span class="function_name">saveItem</span>(item<span class="variable">One</span>);

    store.<span class="function_name">saveItem</span>(item<span class="variable">Two</span>);

  }</span>);



  <span class="function_name">afterEach</span>( <span class="keyword">fun</span><span class="function_name">ction</span>() <span class="tuple">{

    store.<span class="function_name">empty</span>();

  }</span>);



  async.<span class="function_name">it</span>('should append new items to the end of the list', <span class="keyword">fun</span><span class="function_name">ction</span>(done) <span class="tuple">{

    store.<span class="function_name">getItems</span>().<span class="function_name">then</span>( <span class="keyword">fun</span><span class="function_name">ction</span>(items) <span class="tuple">{

      <span class="function_name">expect</span>(items[items.length-<span class="number">1</span>]).<span class="function_name">toBe</span>(item<span class="variable">Two</span>);

      <span class="function_name">done</span>();

    }</span>);

  });



  async.<span class="function_name">it</span>('should update existing item at position', <span class="keyword">fun</span><span class="function_name">ction</span>(done) <span class="tuple">{

    item<span class="variable">One</span>.name = 'oranges';

    store.<span class="function_name">saveItem</span>(item<span class="variable">One</span>).<span class="function_name">then</span>( <span class="keyword">fun</span><span class="function_name">ction</span>(item) <span class="tuple">{

      store.<span class="function_name">getItems</span>().<span class="function_name">then</span>( <span class="keyword">fun</span><span class="function_name">ction</span>(items) <span class="tuple">{

        <span class="function_name">expect</span>(items.<span class="function_name">indexOf</span>(item<span class="variable">One</span>)).<span class="function_name">toEqual</span>(<span class="number">0</span>);

        <span class="function_name">done</span>();

      }</span>);

    });

  });



});</code></pre>
<p>I had begun to add these expectations for multiple items in the list to the <code>saveItem()</code> spec suite, but I saw a similar setup for them both that differed from the origin setup for the <code>saveItem()</code> suite. As such, I moved these expectations to their own spec suite and particular setup.</p>
<p>Without any new modification to <code>storage-service</code> implementation, run that and we are still green!<br><img src="http://custardbelly.com/blog/images/tdd_js/part_ix_16.png" alt="Passing with new expectations for saveItem()"></p>
<p>Tagged <strong>0.1.14</strong>: <a href="https://github.com/bustardcelly/grocery-ls/tree/0.1.14"><a href="https://github.com/bustardcelly/grocery-ls/tree/0.1.14">https://github.com/bustardcelly/grocery-ls/tree/0.1.14</a></a></p>
<h2 id="this-is-all-great-but-we-still-haven-t-done-anything">This Is All Great But We Still Haven’t Done Anything</h2>
<p>In other words, what this subsection header is trying to say, the <code>storage-service</code> – even after we hook up communication to it from <code>list-controller</code> events – will do <em>nothing</em> but keep a session-cache of items: <strong>there still is no persistence across sessions</strong>.</p>
<p>Seeing as this is the case, let’s start integrating communication with <code>localStorage</code> into our <code>storage-service</code>. I am not going to modify the tests in order to verify the utilization of <code>localStorage</code> in relation to the operations available on <code>storage-service</code> – I am simply going to modify the <code>storage-service</code> and posible change expectations. The reason being that I do not really care about whether the storage-service relies on <code>localStorage</code> or a remote resource to read and write items to storage; I am only concerned with communication to <code>storage-service</code> being supported. </p>
<p>In truth, if this were a real world application and had to support occasional connectivity, i’d have two service modules: local-storage-service and remove-storage-service. They would both support the same API and there would be a service layer facade that would manage the ‘live’ instance and sync of both. That is a little too much for this series, so we’ll stick with a proxy to <code>localStorage</code> without modifying our tests to assume that the <code>storage-service</code> requires communication with it.</p>
<h3 id="storage-service-modification">storage-service modification</h3>
<p>To begin with, a <code>String</code> value is used as a key to read and write to an object held on <a href="https://developer.mozilla.org/en-US/docs/DOM/Storage">localStorage</a>. The API of <code>localStorage</code> is fairly simple and we’ll only be concerned with <code>getItem()</code> and <code>setItem()</code> to read and write to the store, respectively. We’ll use a key that we hope is unique to our application and won’t overwrite any object stored previously by another and use that key to access the stored grocery list items:</p>
<p><em>/script/service/storage-service.js</em></p>
<pre><code>define(['jquery', '<span class="keyword">script</span>/model/grocery-ls-<span class="property">item</span>'], function($, modelFactory) {



  var itemCache,

      groceryListKey = 'com.custardbelly.grocerylist',

      parseToCollection = function(json) {

        var i,

            <span class="property">length</span>,

            <span class="type">list</span> = (json &amp;&amp; typeof json === '<span class="type">string</span>') ? JSON.parse(json) : [];

        <span class="property">length</span> = <span class="type">list</span>.<span class="property">length</span>;

        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="property">length</span>; i++) {

          <span class="type">list</span>[i] = $.extend(modelFactory.create(), <span class="type">list</span>[i]);

        }
<span class="command">
        return</span> <span class="type">list</span>;

      },

      store = {

        saveItem: function(<span class="property">item</span>) {

          var deferred = $.Deferred();
<span class="command">
          return</span> deferred.resolve(<span class="property">item</span>);

        },

        removeItem: function(<span class="property">item</span>) {

          var deferred = $.Deferred(),

              itemIndex = itemCache.indexOf(<span class="property">item</span>),

              removedItem;



          <span class="keyword">if</span>(itemIndex &gt; -<span class="number">1</span>) {

            itemCache.splice(itemIndex, <span class="number">1</span>);

            removedItem = <span class="property">item</span>;

          }
<span class="command">
          return</span> deferred.resolve(removedItem);

        },

        getItems: function() {

          var deferred = $.Deferred();

          <span class="keyword">if</span>(itemCache === undefined) {

             <span class="keyword">try</span> {

              itemCache = parseToCollection(window.localStorage.getItem(groceryListKey));

              deferred.resolve(itemCache);

            }

            catch(e) {

              deferred.reject('Could <span class="keyword">not</span> access items: ' + e.message);

            }

          }

          <span class="keyword">else</span> {

            deferred.resolve(itemCache);

          }
<span class="command">
          return</span> deferred;

        },

        empty: function() {

          var deferred = $.Deferred();

          itemCache.<span class="property">length</span> = <span class="number">0</span>;

          deferred.resolve(itemCache);
<span class="command">
          return</span> deferred;

        }

      };
<span class="command">


  return</span> store;



});</code></pre>
<p>That will light up our tests in pretty red… but that was expected. Actually, if it didn’t make our tests fail horribly, I would have been worried.<br><img src="http://custardbelly.com/blog/images/tdd_js/part_ix_23.png" alt="Failing on sotrage modification."></p>
<p>There are a couple things going on in this modification to <code>storage-service</code> that we should go over, however – the first being <code>parseToCollection()</code>:</p>
<p><em>/script/service/storage-service.js</em></p>
<pre><code>parseToCollection = function(json) {

  var i,

      <span class="property">length</span>,

      <span class="type">list</span> = (json &amp;&amp; typeof json === '<span class="type">string</span>') ? JSON.parse(json) : [];



  <span class="property">length</span> = <span class="type">list</span>.<span class="property">length</span>;

  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="property">length</span>; i++) {

    <span class="type">list</span>[i] = $.extend(modelFactory.create(), <span class="type">list</span>[i]);

  }
<span class="command">
  return</span> <span class="type">list</span>;

}</code></pre>
<p>This method is invoked from <code>getItems()</code> and is provided the value of the object held in <code>localStorage</code> with the key <code>com.custardbelly.grocerylist</code>. We’ll be saving our data down in <a href="http://www.json.org/">JSON</a> format, and as such, <code>parseCollection()</code> is responsible for parsing that data back out; as well, if it is the first time accessing the data it will be coming in as undefined so a new list is created. What is particularly important in this parsing is how the objects on the list held in <code>localStorage</code> are converted to instances of our <code>grocery-ls-item</code> model: we create a new instance using the <code>modelFactory</code> and extend it with the object values from the item held on the list. The reason for this is because <code>grocery-ls-items</code> are decorated with getters and setters to allow for <code>property-change</code> events to be notified. In serializing down to JSON, this object structure is not perserved – it is just a <strong>POJSO</strong>.</p>
<p>The <code>parseToCollection()</code> method is invoked from <code>getItems()</code>:</p>
<p><em>/script/service/storage-service.js</em></p>
<pre><code><span class="attribute">getItems</span>: <span class="string">function() {</span>

<span class="javascript">  <span class="keyword">var</span> deferred = $.Deferred();

  <span class="keyword">if</span>(itemCache === <span class="literal">undefined</span>) {

    <span class="keyword">try</span> {

      itemCache = parseToCollection(window.localStorage.getItem(groceryListKey));

      deferred.resolve(itemCache);

    }

    <span class="keyword">catch</span>(e) {

      deferred.reject(<span class="string">'Could not access items: '</span> + e.message);

    }

  }

  <span class="keyword">else</span> {

    deferred.resolve(itemCache);

  }

  <span class="keyword">return</span> deferred;

}</span></code></pre>
<p>When <code>getItems()</code> is first invoked in a session, it will go about trying to access and parse the data held on <code>localStorage</code>; any subsequent invocations will immediately return the currently held reference to the store. In essence, during a session of creating and curating a <strong>Grocery List</strong>, we are working with live and current data so there is no need to keep accessing the list of grocery items from local storage every time – we’ll just return the live record.</p>
<p>Speaking of which, a lot of the failing tests I suspect are due to not actually not saving the list down to <code>localStorage</code>. Let’s just modify <code>storage-service</code> a little to do so and see where that gets us:</p>
<p><em>/script/service/storage-service.js</em></p>
<pre><code>define(['jquery', '<span class="keyword">script</span>/model/grocery-ls-<span class="property">item</span>'], function($, modelFactory) {



  var itemCache,

      groceryListKey = 'com.custardbelly.grocerylist',

      parseToCollection = function(json) {

        var i,

            <span class="property">length</span>,

            <span class="type">list</span> = (json &amp;&amp; typeof json === '<span class="type">string</span>') ? JSON.parse(json) : [];



        <span class="property">length</span> = <span class="type">list</span>.<span class="property">length</span>;

        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="property">length</span>; i++) {

          <span class="type">list</span>[i] = $.extend(modelFactory.create(), <span class="type">list</span>[i]);

        }
<span class="command">
        return</span> <span class="type">list</span>;

      },

      serialize = function(key, data) {

        window.localStorage.setItem(key, JSON.stringify(data));

      },

      store = {

        saveItem: function(<span class="property">item</span>) {

          var deferred = $.Deferred();

          $.when(this.getItems()).<span class="keyword">then</span>(function(cache) {

            var index = cache.indexOf(<span class="property">item</span>);

            <span class="keyword">try</span> {

              <span class="keyword">if</span>(index === -<span class="number">1</span>) {

                cache[cache.<span class="property">length</span>] = <span class="property">item</span>;

              }

              serialize(groceryListKey, cache);

              deferred.resolve(<span class="property">item</span>);

            }

            catch(e) {

              deferred.reject('Could <span class="keyword">not</span> save <span class="property">item</span>: ' + e.message);

            }

          });
<span class="command">
          return</span> deferred;

        },

        removeItem: function(<span class="property">item</span>) {

          // implementation removed <span class="keyword">to</span> reduce noise

        },

        getItems: function() {

          // implementation removed <span class="keyword">to</span> reduce noise

        },

        empty: function() {

          // implementation removed <span class="keyword">to</span> reduce noise

        }

      };
<span class="command">


  return</span> store;



});</code></pre>
<p><code>saveItem()</code> was modified to access the held list using <code>getItems()</code>, operate on that list as it had done previously and then try to serialize the list back to storage. Fairly simple. It’s important to note that we don’t access the <code>itemCache</code> directly in saveItem(), the reason being that we can’t ensure that <code>saveItem()</code> will only be called after a request to <code>getItems()</code>. As such, we need to be sure we’re always working with the same data and do so by requesting that cached list from <code>getItems()</code> within <code>saveItem()</code>.</p>
<p>That gets us closer to green, but we still have some work to do…<br><img src="http://custardbelly.com/blog/images/tdd_js/part_ix_24.png" alt="Closer to green for storage-service modifications."></p>
<p>Let’s modify <code>removeItem()</code> and <code>empty()</code> to work with the cached list returned from <code>getItems()</code> just as the modification to <code>saveItems()</code> has:</p>
<p><em>/script/service/storage-service.js</em></p>
<pre><code><span class="attribute">removeItem</span>: <span class="string">function(item) {</span>

<span class="coffeescript">  <span class="reserved">var</span> deferred = $.Deferred();

  $.<span class="keyword">when</span>(<span class="keyword">this</span>.getItems()).<span class="keyword">then</span>(<span class="reserved">function</span>(cache) {

    <span class="reserved">var</span> itemIndex = cache.indexOf(item),

        removedItem;

    <span class="keyword">try</span> {

      <span class="keyword">if</span>(itemIndex &gt; -<span class="number">1</span>) {

        cache.splice(itemIndex, <span class="number">1</span>);

        removedItem = item;

        serialize(groceryListKey, cache);

      }

      deferred.resolve(removedItem);

    }

    <span class="keyword">catch</span>(e) {

      cache.splice(itemIndex, <span class="number">0</span>, removedItem);

      deferred.reject(<span class="string">'Could not remove item: '</span> + e.message);

    }

  });

  <span class="keyword">return</span> deferred;

}</span></code></pre>
<p><em>/script/service/storage-service.js</em></p>
<pre><code><span class="attribute">empty</span>: <span class="string">function() {</span>

<span class="coffeescript">  <span class="reserved">var</span> deferred = $.Deferred();

  $.<span class="keyword">when</span>(<span class="keyword">this</span>.getItems()).<span class="keyword">then</span>(<span class="reserved">function</span>(cache) {

    <span class="keyword">try</span> {

      cache.length = <span class="number">0</span>;

      serialize(groceryListKey, cache);

      deferred.resolve(cache);

    }

    <span class="keyword">catch</span>(e) {

      deferred.reject(<span class="string">'Could not empty cache: '</span> + e.message);

    }

  });

  <span class="keyword">return</span> deferred;

}</span></code></pre>
<p>That oughta do. Basically doing the same as we had done with <code>saveItem()</code>: accessing the cached list through <code>getItems()</code>, then modifying that list and serializing back done to <code>localStorage</code>.</p>
<p>Run those tests again, and we are back to green!<br><img src="http://custardbelly.com/blog/images/tdd_js/part_ix_25.png" alt="Passing storage-service tests after modification!"></p>
<p>… at least for our <code>storage-service</code>. Let’s turn on all our tests again and see if our previous expectations are met:<br><img src="http://custardbelly.com/blog/images/tdd_js/part_ix_26.png" alt="Passing tests!"></p>
<p>Whoopie!</p>
<p>Tagged <strong>0.1.15</strong>: <a href="https://github.com/bustardcelly/grocery-ls/tree/0.1.15"><a href="https://github.com/bustardcelly/grocery-ls/tree/0.1.15">https://github.com/bustardcelly/grocery-ls/tree/0.1.15</a></a></p>
<p>We’re not done yet: we have still to hook up <code>list-controller</code> notification to <code>storage-service</code> operations. However, I want to end this article here on a good note <img src="http://custardbelly.com/blog/wp-includes/images/smilies/icon_smile.gif" alt=":)"></p>
<h2 id="conclusion">Conclusion</h2>
<p>We have yet to reach our goal of incorporating session persistence within our <strong>Grocery List</strong> application – but that is not to say we have gotten nowhere. We implemented our <code>storage-service</code> layer for <code>localStorage</code> communication and modified the <code>list-controller</code> to notify of change events to its collection related to <code>grocery-ls-item</code> existence. Not to shabby. </p>
<p>I know we want to get a finished product out the door, but we’ll get there… just a few more things to tie up in the next article…</p>
<p>Cheers! </p>
<p>—-</p>
<h1 id="link-dump">Link Dump</h1>
<h2 id="reference">Reference</h2>
<p><a href="http://tddjs.com/">Test-Driven JavaScript Development by Christian Johansen</a><br><a href="http://dannorth.net/introducing-bdd/">Introducing BDD by Dan North</a><br><a href="http://cumulative-hypotheses.org/2011/08/30/tdd-as-if-you-meant-it/">TDD as if you Meant it by Keith Braithwaite</a><br><a href="http://requirejs.org/">RequireJS</a><br><a href="https://github.com/amdjs/amdjs-api/wiki/AMD">AMD</a><br><a href="http://pivotal.github.com/jasmine/">Jasmine</a><br><a href="http://sinonjs.org/">Sinon</a><br><a href="https://github.com/derickbailey/jasmine.async">Jasmine.Async</a></p>
<h2 id="post-series">Post Series</h2>
<p><a href="https://github.com/bustardcelly/grocery-ls">grocery-ls github repo</a><br><a href="http://custardbelly.com/blog/2012/11/26/the-making-of-a-test-driven-grocery-list-application-in-javascript-part-i">Part I – Introduction</a><br><a href="http://custardbelly.com/blog/2012/11/26/the-making-of-a-test-driven-grocery-list-application-in-js-part-ii">Part II – Feature: Add Item</a><br><a href="http://custardbelly.com/blog/2012/12/06/the-making-of-a-test-driven-grocery-list-application-in-js-part-iii">Part III – Feature: Mark-Off Item</a><br><a href="http://custardbelly.com/blog/2012/12/17/the-making-of-a-test-driven-grocery-list-application-in-js-part-iv">Part IV – Feature: List-Item-Controller</a><br><a href="http://custardbelly.com/blog/2012/12/31/the-making-of-a-test-driven-grocery-list-application-in-js-part-v/">Part V – Feature: List-Controller Refactoring</a><br><a href="http://custardbelly.com/blog/2013/01/08/the-making-of-a-test-driven-grocery-list-application-in-js-part-vi/">Part VI – Back to Passing</a><br><a href="http://custardbelly.com/blog/2013/01/17/the-making-of-a-test-driven-grocery-list-application-in-js-part-vii/">Part VII – Remove Item</a><br><a href="http://custardbelly.com/blog/2013/01/22/the-making-of-a-test-driven-grocery-list-application-part-viii/">Part VIII – Bug Fixing</a><br><a href="http://custardbelly.com/blog/2013/02/15/the-making-of-a-test-driven-grocery-list-application-in-js-part-ix/">Part IX – Persistence</a><br><a href="http://custardbelly.com/blog/2013/03/06/the-making-of-a-test-driven-grocery-list-application-in-js-part-x/">Part X – It Lives!</a></p>
<p>Posted in <a href="http://custardbelly.com/blog/category/amd/">AMD</a>, <a href="http://custardbelly.com/blog/category/javascript/">JavaScript</a>, <a href="http://custardbelly.com/blog/category/requirejs/">RequireJS</a>, <a href="http://custardbelly.com/blog/category/grocery-ls/">grocery-ls</a>, <a href="http://custardbelly.com/blog/category/jasmine/">jasmine</a>, <a href="http://custardbelly.com/blog/category/unit-testing/">unit-testing</a>.</p>

  </section>
  <section class="navigation">
      
        <span class="newer"><a href="http://custardbelly.com/blog/blog-posts/2013/03/06/the-making-of-a-test-driven-grocery-list-application-in-js-part-x/index.html">&#8672;&nbsp;newer</a></span>
      
      
        <span class="older"><a href="http://custardbelly.com/blog/blog-posts/2013/02/04/madmin-for-ease-of-creating-and-documenting-restful-service-uris/index.html">older&nbsp;&#8674;</a></span>
      
    </section>
  <section class="comments">
    
      <div id="disqus_thread"></div>
      <script type="text/javascript">
        window.disqus_identifier="";
        window.disqus_url="http://custardbelly.com/blog/blog-posts/2013/02/15/the-making-of-a-test-driven-grocery-list-application-in-js-part-ix/index.html";
        window.disqus_title="The Making of a Test-Driven Grocery List Application in JS: Part IX";
      </script>
        <script type="text/javascript" src="http://disqus.com/forums/custardbelly/embed.js"></script>
        <noscript><a href="http://custardbelly.disqus.com/?url=ref">View the discussion thread.</a></noscript>
    
  </section>
</article>

    <footer>
      Copyright Todd Anderson, 2014.
      <div>Icon made by <a href="http://www.flaticon.com/free-icon/google-plus-symbol-in-a-circle_24171" title="Icomoon">Icomoon</a> from <a href="http://www.flaticon.com" title="Flaticon">www.flaticon.com</a></div>
      <div>Icon made by <a href="http://www.flaticon.com/free-icon/social-rss-circle-internet_10010" title="Elegant Themes">Elegant Themes</a> from <a href="http://www.flaticon.com" title="Flaticon">www.flaticon.com</a></div>
    </footer>
    <script src="http://custardbelly.com/blog/lib/highlight/highlight.pack.js"></script>
    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-29061897-1']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();

    </script>
  </body>
</html>
