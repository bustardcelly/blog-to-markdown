<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
    <meta content="width=device-width, initial-scale=1, user-scalable=no" name="viewport">
    <meta name="description" content="Todd Anderson makes things for web, mobile, desktop and land with a passion of application architecture and development workflows.">
    <meta name="keywords" content="todd anderson, anderson, programmer, developer, architect, engineer, software, software development, programming, application, ria, architecture, javascript, html5, css, web, mobile, desktop, arduino, actionscript, flex, flash, python, java, objective-c, ios, android">
    <meta http-equiv="cleartype" content="on">
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="alternate" type="application/rss+xml" title="Todd Anderson - feed" href="/index.xml" />
    <title>Todd Anderson - The Making of a Test-Driven Grocery List Application in JS: Part IV</title>
    <!--[if lte IE 8]><script src="assets/js/ie/html5shiv.js"></script><![endif]-->
    <link rel="stylesheet" href="/assets/css/main.css" />
    <!--[if lte IE 8]><link rel="stylesheet" href="assets/css/ie8.css" /><![endif]-->
    <link rel="stylesheet" href="/style/post.css" />
    <link rel="stylesheet" type="text/css" href="/lib/highlight/styles/github.css" media="all" />
  </head>
  <body>

    <!-- Header -->
      <section id="header">
        <header>
          <span class="image avatar"><img src="images/avatar.jpg" alt="" /></span>
          <h1 id="logo"><a href="#">Todd Anderson</a></h1>
          <p>Making things for web, mobile,<br />
          desktop and land</p>
        </header>
        <nav id="nav">
          <ul>
            <li><a href="#one" class="active">About</a></li>
            <li><a href="#two">Things I Do</a></li>
            <!-- <li><a href="#three">A Few Accomplishments</a></li> -->
            <li><a href="https://github.com/bustardcelly/custardbelly-dot-comv2/tree/master/contact" target="_blank">Contact</a></li>
          </ul>
        </nav>
        <footer>
          <ul class="icons">
            <li><a href="https://twitter.com/_toddanderson_" class="icon fa-twitter" target="_blank"><span class="label">Twitter</span></a></li>
            <li><a href="https://github.com/bustardcelly" class="icon fa-github" target="_blank"><span class="label">Github</span></a></li>
            <li><a href="https://www.custardbelly.com/blog" class="icon fa-rss-square" target="_blank"><span class="label">Blog</span></a></li>
            <li><a href="https://github.com/bustardcelly/custardbelly-dot-comv2/tree/master/contact" target="_blank" class="icon fa-envelope"><span class="label">Email</span></a></li>
          </ul>
        </footer>
      </section>

    <!-- Wrapper -->
      <div id="wrapper">

        <!-- Main -->
          <div id="main">

            <!-- One -->
              <section id="one">
                <div class="container">

                  <article class="post">
  <div class="title">
    <h1><a href="/blog-posts/2012/12/17/the-making-of-a-test-driven-grocery-list-application-in-js-part-iv/index.html">The Making of a Test-Driven Grocery List Application in JS: Part IV</a></h1>
    <p>
      2012 December 17th
      
        by todd anderson
      
    </p>
  </div>
  <section>
    <p><em>This is the fourth installment in a series of building a Test-Driven Grocery List application using <a href="http://pivotal.github.com/jasmine/">Jasmine</a> and <a href="http://requirejs.org">RequireJS</a>. To learn more about the intent and general concept of the series please visit <a href="https://custardbelly.com/blog/2012/11/26/the-making-of-a-test-driven-grocery-list-application-in-javascript-part-i/">The Making of a Test-Driven Grocery List Application in JavaScript: Part I</a></em><br>—</p>
<h1 id="introduction">Introduction</h1>
<p>In the <a href="https://custardbelly.com/blog/2012/12/06/the-making-of-a-test-driven-grocery-list-application-in-js-part-iii/">previous</a> article we developed a new feature for the <strong>Grocery List</strong> application: <em>Mark Off Item</em>. In the process of doing so, or at least when we went from the tests to implementation, we added more responsibility to the <em>list-controller</em> as it pertained to individual view and model items.</p>
<p>In this article, we are going to refactor out that responsibility into its own <em>list-item-controller</em> that will be responsible for managing the relationship of a list item view to a single <em>grocery-ls-item</em> model.</p>
<h2 id="refactoring">Refactoring</h2>
<p>As it stands , I think the design of the <em>list-controller</em> is fine: exposing an API to modify the list. It’s the internals that are starting to bug me. If the current behaviour and responsibilities were all that was needed, I suppose we could walk away and feel confident about our application as is. However, in forward thinking other operations that could involve list items – such as deletion – I feel the responsibilities of the <em>list-controller</em> will quickly outgrow its intent. </p>
<p>I suppose, some would argue, that if the responsibilities of the list-controller grow to more operations that are tightly coupled with singular pieces of data, then we could just write more tests to verify its soundness. Not entirely a bad argument – i mean that is what we are trying to justify in this series, essentially. But it is not a 1:1 correlation of more tests to better design. It is preferred to separate concerns as much as possible in order to properly test. The maintenance of complex tests can be a bigger burden than the maintenance of complex code – so much so that testing stops all together.</p>
<h3 id="list-item-controller">list-item-controller</h3>
<p>Before we dive in to creating a <em>list-item-controller</em>, let’s take a look at what concerns within <em>list-controller</em> we want to move out. Looking from the <a href="https://github.com/bustardcelly/grocery-ls/blob/0.1.3/script/controller/list-controller.js">0.1.3 tagged list-controller</a>, we mainly want to cut out the item view creation – so the following node declarations and any associated item creation and item management:</p>
<p><em>/script/controller/list-controller.js tagged at 0.1.3</em></p>
<pre><code>itemFragment          = <span class="hljs-string">'&lt;li class="</span>grocery-item<span class="hljs-string">" /&gt;'</span>,

editableItemFragment  = <span class="hljs-string">'&lt;li class="</span>editable-grocery-item<span class="hljs-string">"&gt;'</span> +

                                           <span class="hljs-string">'&lt;input id="</span>editableItem<span class="hljs-string">" name="</span>editableItem<span class="hljs-string">" '</span> +

                                               <span class="hljs-string">'class="</span>editable-item<span class="hljs-string">" placeholder="</span>Enter item <span class="hljs-transposed_variable">name...</span><span class="hljs-string">"&gt;'</span> +

                                          <span class="hljs-string">'&lt;/input&gt;'</span> +

                                        <span class="hljs-string">'&lt;/li&gt;'</span>
</code></pre><p>These declarations and management of view will be moved to the <em>list-item-controller</em>. The UI and usability of a list item will be driven by the model and should provide an API that is a level of abstraction from the model for any outside parties (ie, the <em>list-controller</em>). As well, the model drives the internal state of edit-ability and marked-off-ed-ness (<em>they’re words, alright</em>!), and the <em>list-item-controller</em> will dispatch events related to its change of state. Lofty goals, but let’s see if we can’t address them.</p>
<h4 id="a-bit-of-uncertainty">a bit of uncertainty</h4>
<p>We currently created specs for <em>Add Item</em> and <em>Mark Off Item</em> features. These were a little high-level in that they described features using the BDD syntax of <a href="http://pivotal.github.com/jasmine/">Jasmine</a> but did involve tests around how to interact with the <em>list-controller</em> API; so they do involve integration to some respect – we kind of ignore the whole UI and User Interaction aspect within the tests. </p>
<p>Now here is where I have an internal struggle with writing specs: should the tests we need for the <em>list-item-controller</em> be added to these specs? Or should a new spec focused on <em>list-item-controller</em> API and usability be born? I ask, because from outside-looking-in, the creation, editability and mark-off of an item will still be feasible through the <em>list-controller</em> and to any other third parties – that API provides a facade to modifying a grocery list. So, the current specs we have serve as a nice example of how to interact with the application from the outside… and if they are passing, we know that from higher-level things <em>should</em>* work <img src="https://custardbelly.com/blog/wp-includes/images/smilies/icon_smile.gif" alt=":)"></p>
<p>When we get down to the implementation of the <em>list-item-controller</em>, from a design perspective we know that a dependency will be introduced: <em>list-controller</em> will have n-number of <em>list-item-controller</em> instances, and will be responsible for the creation and maintenance of each <em>list-item-controller</em>. The state and <em>grocery-ls-item</em> model maintenance which we established in the previous articles as the responsibility of the <em>list-controller</em> will, as well, become the responsibility of the <em>list-item-controller</em>.</p>
<p>Knowing this, I start to feel that this is closer to testing the implementation and behaviour of a component, rather then one of the ’system’, and would push for its own spec. But I am very much open to ideas, so please leave a comment.</p>
<h3 id="list-item-controller-design">list-item-controller design</h3>
<p>In my <em>bit of uncertainty</em>, I basically described the design of the <em>list-item-controller</em>. Now, we’ll flesh out its behaviour and API in a spec and eventually move it to its own AMD implementation. To start out slowly we’ll create a new spec suite and define the <em>list-item-controller</em> attributes:</p>
<p><em>/test/jasmine/spec/list-item-controller.spec.js</em></p>
<pre><code>define([<span class="hljs-string">'jquery'</span>, <span class="hljs-string">'script/model/grocery-ls-item'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">($, modelFactory)</span> {</span>



  describe(<span class="hljs-string">'list-item-controller'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>



    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createStateEvent</span><span class="hljs-params">(oldState, newState)</span> {</span>

        <span class="hljs-keyword">var</span> event = <span class="hljs-keyword">new</span> $.Event(<span class="hljs-string">'state-change'</span>);

        event.oldState = oldState;

        event.newState = newState;

        <span class="hljs-keyword">return</span> event;

    }



    <span class="hljs-keyword">var</span> itemControllerFactory = {

        create: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(node, model)</span> {</span>

          <span class="hljs-keyword">var</span> itemController = <span class="hljs-built_in">Object</span>.create(<span class="hljs-built_in">Object</span>.prototype);



          (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(controller, stateEventCreator)</span> {</span>

            <span class="hljs-keyword">var</span> _state = <span class="hljs-string">'normal'</span>;

            <span class="hljs-built_in">Object</span>.defineProperties(controller, {

              <span class="hljs-string">"model"</span>: {

                value: model,

                writable: <span class="hljs-literal">false</span>,

                enumerable: <span class="hljs-literal">true</span>

              },

              <span class="hljs-string">"parentView"</span>: {

                value: node,

                writable: <span class="hljs-literal">false</span>,

                enumerable: <span class="hljs-literal">true</span>

              },

              <span class="hljs-string">"state"</span>: {

                set: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(value)</span> {</span>

                  <span class="hljs-keyword">var</span> event = stateEventCreator.call(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>.state, value);

                  _state = value;

                  $(<span class="hljs-keyword">this</span>).trigger(event);

                },

                get: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

                  <span class="hljs-keyword">return</span> _state;

                }

              }

            });

          }(itemController, createStateEvent));



          <span class="hljs-keyword">return</span> itemController;

        }

      };

  });

});
</code></pre><p>The object declared – <em>itemControllerFactory</em> – is a factory instance that will generate new instances of a <em>list-item-controller</em>. The factory pattern should be familiar to you if you look at the <em>grocery-ls-item</em> AMD we created in the second article in the series. When creating an instance of a <em>list-item-controller</em>, we have defined that a parent DOM node and a model should be passed in during creation, as can be seen in <em>itemControllerFactory:create()</em>. If we look at the <em>defineProperties</em>, we have also defined a few characteristics of the <em>list-item-controller</em> here. It has:</p>
<ul>
<li>Parent Node reference – DOM instance of which to modify view state.</li>
<li>Model reference – Model of which the View is driven by.</li>
<li>State – State of View within the DOM representing the Model.</li>
</ul>
<p>We have designed the <em>state</em> property a little differently than you may have seen before, at least in this series. We declared the implicit getter/setters so as to keep track of state internally and dispatch an event of <em>’state-change’</em>. By ‘<em>internally</em>‘, I mean I used an <a href="http://benalman.com/news/2010/11/immediately-invoked-function-expression/">IIFE</a> to enclose a ‘<em>private</em>‘ member storing state.</p>
<p>If you know of event-driven design – whether or not you are familiar with <a href="http://api.jquery.com/category/Events/?rdfrom=http%3A%2F%2Fdocs.jquery.com%2Fmw%2Findex.php%3Ftitle%3DAPI%2F1.3%2FEvents%26redirect%3Dno">jQuery Events</a>, which the <em>state</em> property employs – then this will look familiar. Essentially, we want to allow any client who wants to know about the change of state to a <em>list-item-controller</em> instance to be notified through an event of <em>’state-change’</em>. This will become more apparent later on in development, but just keep in mind that it is the responsibility of the <em>list-controller</em> to maintain n-number of _list-item-controller_s; and part of that maintenance is being aware of each <em>list-item-controller</em>’s state – and since binding is not inherently available in JavaScript, and I don’t want to introduce any new libraries that could handle binding, listening on events is an easy way to go about tracking state. _You feel adventurous enough, we can build a binding mechanism on top of this event system… just make sure it’s got tests <img src="https://custardbelly.com/blog/wp-includes/images/smilies/icon_smile.gif" alt=":)"> _</p>
<h2 id="tests">Tests</h2>
<p>Before we begin creating the tests for the <em>list-item-controller</em>, you may be wondering where the feature stories and scenarios are. We could definitely define those, however – and of course, I can always be wrong – I feel those are more business-facing… well, stories at least. They are used to define some type of behaviour that is accepted as part of the software, with scenarios describing the various outcomes of a behaviour. Still valid for the case in hand of integrating the <em>list-item-controller</em>, but I tend to think this closer to testing on the implementation of behaviour. It’s a gray area to me, as well, if this all sounds confusing – I invite someone to step in and either clarify my understanding to set me straight. </p>
<p>Basically, our goal here is to verify the design and implementation of <em>list-item-controller</em>. If done properly this will pass, as well as the specs for the <em>Add Item</em> and <em>Mark Off Item</em> features we created in <a href="https://custardbelly.com/blog/2012/11/26/the-making-of-a-test-driven-grocery-list-application-in-js-part-ii/">previous</a> <a href="https://custardbelly.com/blog/2012/12/06/the-making-of-a-test-driven-grocery-list-application-in-js-part-iii/">articles</a>.</p>
<p>That said, let’s flesh out some tests that verify:</p>
<ol>
<li>Factory generates unique instances of list-item-controller</li>
<li>Model is preserved and immutable on list-item-controller</li>
<li>State is mutable through implicit getter/setters</li>
<li>Change to state is dispatched</li>
</ol>
<p><em>/test/jasmine/spec/list-item-controller.spec.js</em></p>
<pre><code><span class="hljs-function">describe(<span class="hljs-string">'Grocery list-item-controller'</span>, <span class="hljs-function">function()</span> {



  var model,

      newController,

      async = new <span class="hljs-function">AsyncSpec(this)</span>;



  <span class="hljs-function">beforeEach( <span class="hljs-function">function()</span> {

    model = modelFactory.<span class="hljs-function">create()</span>;

    newController = itemControllerFactory.<span class="hljs-function">create(parentNode, model)</span>;

  })</span>;



  <span class="hljs-function">describe(<span class="hljs-string">'list-item-controller factory creation'</span>, <span class="hljs-function">function()</span> {



    <span class="hljs-function">it(<span class="hljs-string">'should return a new instance of list-item-controller'</span>, <span class="hljs-function">function()</span> {

      <span class="hljs-function">expect(newController)</span>.not.<span class="hljs-function">toBeUndefined()</span>;

    })</span>;



    <span class="hljs-function">it(<span class="hljs-string">'should return unique instances of list-item-controllers'</span>, <span class="hljs-function">function()</span> {

      var nextController = itemControllerFactory.<span class="hljs-function">create(parentNode, model)</span>;

      nextController.state = <span class="hljs-string">'testing'</span>;

      <span class="hljs-function">expect(nextController)</span>.not.<span class="hljs-function">toBe(newController)</span>;

      <span class="hljs-function">expect(nextController.state)</span>.not.<span class="hljs-function">toBe(newController.state)</span>;

    })</span>;



  })</span>;



  <span class="hljs-function">describe(<span class="hljs-string">'new list-item-controller instance'</span>, <span class="hljs-function">function()</span> {



    <span class="hljs-function">it(<span class="hljs-string">'should expose model provided in creation'</span>, <span class="hljs-function">function()</span> {

      <span class="hljs-function">expect(newController.model)</span>.not.<span class="hljs-function">toBeUndefined()</span>;

      <span class="hljs-function">expect(newController.model)</span>.<span class="hljs-function">toBe(model)</span>;

    })</span>;



    <span class="hljs-function">it(<span class="hljs-string">'should expose non-writable model'</span>, <span class="hljs-function">function()</span> {

      var newModel = modelFactory.<span class="hljs-function">create()</span>;

      newController.model = newModel;

      <span class="hljs-function">expect(newController.model)</span>.not.<span class="hljs-function">toBe(newModel)</span>;

      <span class="hljs-function">expect(newController.model)</span>.<span class="hljs-function">toBe(model)</span>;

    })</span>;



  <span class="hljs-function">describe(<span class="hljs-string">'list-item-controller notifies on state-change'</span>, <span class="hljs-function">function()</span> {



    async.<span class="hljs-function">it(<span class="hljs-string">'should provide old and new state values on state-change'</span>, <span class="hljs-function">function(done)</span> {

      var previousState = newController.state,

          newState = <span class="hljs-string">'editable'</span>;



      $(newController)</span>.<span class="hljs-function">on(<span class="hljs-string">'state-change'</span>, <span class="hljs-function">function(event)</span> {

        $(newController)</span>.<span class="hljs-function">off(<span class="hljs-string">'state-change'</span>)</span>;



        <span class="hljs-function">expect(event.oldState)</span>.<span class="hljs-function">toBe(previousState)</span>;

        <span class="hljs-function">expect(event.newState)</span>.<span class="hljs-function">toBe(newState)</span>;

        <span class="hljs-function">expect(newController.state)</span>.<span class="hljs-function">toBe(newState)</span>;

        <span class="hljs-function">done()</span>;

      })</span>;

      newController.state = newState;

    })</span>;



  })</span>;



  });



  <span class="hljs-function">afterEach( <span class="hljs-function">function()</span> {

    model = undefined;

    newController = undefined;

  })</span>;



});
</code></pre><p>The last spec declared, as you may notice, runs asynchronously in order to test the state notification:</p>
<pre><code>async.it(<span class="hljs-string">'should provide old and new state values on state-change'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(done)</span> {</span>
</code></pre><p>The <em>AsyncSpec</em> object comes from the <a href="https://github.com/derickbailey/jasmine.async">jasmine.async library</a> we’ve previously included in the specrunner page. By invoking the spec (<em>it()</em>) through an instance of <em>AsyncSpec</em>, the spec is suspended until either it fails or the <em>done</em> delegate method is invoked. Since notification of state change is event-based, we use it in the spec to verify that the <em>list-item-controller</em> does dispatch that event.</p>
<p>Add that spec to the list:<br><em>/test/jasmine/specrunner.html</em></p>
<pre><code><span class="hljs-keyword">require</span>( [<span class="hljs-string">'spec/newitem.spec.js'</span>, <span class="hljs-string">'spec/markitem.spec.js'</span>, <span class="hljs-string">'spec/list-item-controller.spec.js'</span>], <span class="hljs-keyword">function</span>() {



  var jasmineEnv = jasmine.getEnv(),

     <span class="hljs-keyword">...</span>

  jasmineEnv.execute();



});
</code></pre><p><img src="https://custardbelly.com/blog/images/tdd_js/part_iv_1.png" alt="passing list-item-controller spec"></p>
<h2 id="list-item-controller-implementation">list-item-controller implementation</h2>
<p>We’ve verified our design for the <em>list-item-controller</em> with passing tests, but we have yet to incorporate it into our system and offload the responsibilities (addressed earlier in this article) from the <em>list-controller</em> to it. Before we get there, however, let’s move the implementation of the <em>list-item-controller</em> (and the factory) out into its own AMD module. To start we’ll just move the <em>itemControllerFactory</em> declaration into a new file:</p>
<p><em>/script/controller/list-item-controller.js</em></p>
<pre><code>define([<span class="hljs-string">'jquery'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">($)</span> {</span>



  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createStateEvent</span><span class="hljs-params">(oldState, newState)</span> {</span>

    <span class="hljs-keyword">var</span> event = <span class="hljs-keyword">new</span> $.Event(<span class="hljs-string">'state-change'</span>);

    event.oldState = oldState;

    event.newState = newState;

    <span class="hljs-keyword">return</span> event;

  }



  <span class="hljs-keyword">return</span> {

    create: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(node, model)</span> {</span>

      <span class="hljs-keyword">var</span> itemController = <span class="hljs-built_in">Object</span>.create(<span class="hljs-built_in">Object</span>.prototype);



      (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(controller, stateEventCreator)</span> {</span>

        <span class="hljs-keyword">var</span> _state;

        <span class="hljs-built_in">Object</span>.defineProperties(controller, {

          <span class="hljs-string">"model"</span>: {

            value: model,

            writable: <span class="hljs-literal">false</span>,

            enumerable: <span class="hljs-literal">true</span>

          },

          <span class="hljs-string">"parentView"</span>: {

            value: node,

            writable: <span class="hljs-literal">false</span>,

            enumerable: <span class="hljs-literal">true</span>

          },

          <span class="hljs-string">"state"</span>: {

            set: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(value)</span> {</span>

              <span class="hljs-keyword">var</span> event = stateEventCreator.call(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>.state, value);

              _state = value;

              $(<span class="hljs-keyword">this</span>).trigger(event);

            },

            get: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

              <span class="hljs-keyword">return</span> _state;

            }

          }

        });

      }(itemController, createStateEvent));



      <span class="hljs-keyword">return</span> itemController.init();

    }

  };



});
</code></pre><p>With that in place, we could modify the <em>list-item-controller.spec.js</em> file to include the <em>list-item-controller</em> dependency for testing:</p>
<p><em>/test/jasmine/spec/list-item-controller.spec.js</em></p>
<pre><code>define([<span class="hljs-string">'jquery'</span>, <span class="hljs-string">'script/model/grocery-ls-item'</span>, <span class="hljs-string">'script/controller/list-item-controller'</span>],

          <span class="hljs-keyword">function</span>($, modelFactory, itemControllerFactory) {

  // moved to script/controller/list-item-controller.js



  describe(<span class="hljs-string">'Grocery list-item-controller'</span>, <span class="hljs-keyword">function</span>() {

    <span class="hljs-keyword">...</span>

  });

});
</code></pre><p>And our tests still pass! But… we want to move all the view and item management out of <em>list-controller</em> and have that handled by a <em>list-item-controller</em>. So let’s transfer over those view fragments and flesh out the <em>list-item-controller</em> object that is generated from the factory:</p>
<p><em>/script/controller/list-item-controller.js</em></p>
<pre><code>define([<span class="hljs-string">'jquery'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">($)</span> {</span>



  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createStateEvent</span><span class="hljs-params">(oldState, newState)</span> {</span>

    <span class="hljs-keyword">var</span> event = <span class="hljs-keyword">new</span> $.Event(<span class="hljs-string">'state-change'</span>);

    event.oldState = oldState;

    event.newState = newState;

    <span class="hljs-keyword">return</span> event;

  }



   <span class="hljs-keyword">var</span> stateEnum = {

        UNEDITABLE: <span class="hljs-number">0</span>,

        EDITABLE: <span class="hljs-number">1</span>

      },

      uneditableItemFragment  = <span class="hljs-string">'&lt;p class="grocery-item" /&gt;'</span>,

      editableItemFragment    = <span class="hljs-string">'&lt;p class="editable-grocery-item"&gt;'</span> +

                                                  <span class="hljs-string">'&lt;input name="editableItem" '</span> +

                                                      <span class="hljs-string">'class="editable-item" placeholder="Enter item name..."&gt;'</span> +

                                                  <span class="hljs-string">'&lt;/input&gt;'</span> +

                                               <span class="hljs-string">'&lt;/p&gt;'</span>,

      listItemController = {

        $editableView: <span class="hljs-literal">undefined</span>,

        $uneditableView: <span class="hljs-literal">undefined</span>,

        init: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

          <span class="hljs-keyword">this</span>.$editableView = $(editableItemFragment);

          <span class="hljs-keyword">this</span>.$uneditableView = $(uneditableItemFragment);



          <span class="hljs-comment">// default to undeditable state.</span>

          <span class="hljs-keyword">this</span>.state = stateEnum.UNEDITABLE;

          <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;

        }

      };



  <span class="hljs-keyword">return</span> {

    state: stateEnum,

    create: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(node, model)</span> {</span>

      <span class="hljs-keyword">var</span> itemController = <span class="hljs-built_in">Object</span>.create(listItemController);



      (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(controller, stateEventCreator)</span> {</span>

        <span class="hljs-keyword">var</span> _state = <span class="hljs-string">'normal'</span>;

        <span class="hljs-built_in">Object</span>.defineProperties(controller, {

          <span class="hljs-string">"model"</span>: {

            value: model,

            writable: <span class="hljs-literal">false</span>,

            enumerable: <span class="hljs-literal">true</span>

          },

          <span class="hljs-string">"parentView"</span>: {

            value: node,

            writable: <span class="hljs-literal">false</span>,

            enumerable: <span class="hljs-literal">true</span>

          },

          <span class="hljs-string">"state"</span>: {

            set: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(value)</span> {</span>

              <span class="hljs-keyword">var</span> event = stateEventCreator.call(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>.state, value);

              _state = value;

              $(<span class="hljs-keyword">this</span>).trigger(event);

            },

            get: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

              <span class="hljs-keyword">return</span> _state;

            }

          }

        });

      }(itemController, createStateEvent));



      <span class="hljs-keyword">return</span> itemController.init();

    }

  };



});
</code></pre><p>The <em>init()</em> method of a new <em>list-item-controller</em> is invoked upon creation and return in order to define the view references and default state. The fragment declarations have changed slightly as well – the list item wrappers have been removed. Basically, even though the name suggest that the view will reside in a list, we don’t want to tie the idea that they need to be <em>li</em> DOM elements since they also have no concept of what type of DOM element the <em>parentView</em> is.</p>
<p>As it stands with <a href="https://github.com/bustardcelly/grocery-ls/blob/0.1.3">our current work from the previous article</a>, the <em>list-controller</em> was responsible for listening on UI events of a list item – such as <em>‘blur’</em> on input and <em>‘click’</em>. It is the intent to relive the <em>list-controller</em> of such responsibility so we’ll transfer that over, as well:</p>
<p><em>/script/controller/list-item-controller.js</em></p>
<pre><code>listItemController = {

  $editableView: <span class="hljs-literal">undefined</span>,

  $uneditableView: <span class="hljs-literal">undefined</span>,

  init: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

    <span class="hljs-keyword">this</span>.$editableView = $(editableItemFragment);

    <span class="hljs-keyword">this</span>.$uneditableView = $(uneditableItemFragment);



    <span class="hljs-comment">// view handlers.</span>

    <span class="hljs-keyword">this</span>.$uneditableView.on(<span class="hljs-string">'click'</span>, (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(controller)</span> {</span>

      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(event)</span> {</span>

        <span class="hljs-keyword">var</span> toggled = controller.$uneditableView.css(<span class="hljs-string">'text-decoration'</span>) === <span class="hljs-string">'line-through'</span>;

        controller.model.marked = !toggled;

      };

    }(<span class="hljs-keyword">this</span>)));

    $(<span class="hljs-string">'input'</span>, <span class="hljs-keyword">this</span>.$editableView).on(<span class="hljs-string">'blur'</span>, (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(controller)</span> {</span>

      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(event)</span> {</span>

        controller.model.name = $(<span class="hljs-keyword">this</span>).val();

        controller.state = stateEnum.UNEDITABLE;

      };

    }(<span class="hljs-keyword">this</span>)));



    <span class="hljs-comment">// default to undeditable state.</span>

    <span class="hljs-keyword">this</span>.state = stateEnum.UNEDITABLE;

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;

  }

};
</code></pre><p>Again, we are using an <strong>IIFE</strong>, and in this case to pass in a reference to the controller instance. I could have easily defined a new variable like</p>
<pre><code><span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
</code></pre><p>but that always makes me cry a little inside. Anyway, so we are listening on click of the uneditable view item in order to update value of the <em>marked</em> property on the model and we have assigned a <em>blur</em> handler on the input of the editable view item that updates the value of the <em>name</em> property of the model and flips the state. Now we have to respond to those changes <img src="https://custardbelly.com/blog/wp-includes/images/smilies/icon_smile.gif" alt=":)"></p>
<p><em>/script/controller/list-item-controller.js</em></p>
<pre><code>init: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

  <span class="hljs-keyword">this</span>.$editableView = $(editableItemFragment);

  <span class="hljs-keyword">this</span>.$uneditableView = $(uneditableItemFragment);



  <span class="hljs-comment">// view handlers.</span>

  <span class="hljs-keyword">this</span>.$uneditableView.on(<span class="hljs-string">'click'</span>, (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(controller)</span> {</span>

    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(event)</span> {</span>

      <span class="hljs-keyword">var</span> toggled = controller.$uneditableView.css(<span class="hljs-string">'text-decoration'</span>) === <span class="hljs-string">'line-through'</span>;

      controller.model.marked = !toggled;

    };

  }(<span class="hljs-keyword">this</span>)));

  $(<span class="hljs-string">'input'</span>, <span class="hljs-keyword">this</span>.$editableView).on(<span class="hljs-string">'blur'</span>, (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(controller)</span> {</span>

    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(event)</span> {</span>

      controller.model.name = $(<span class="hljs-keyword">this</span>).val();

      controller.state = stateEnum.UNEDITABLE;

    };

  }(<span class="hljs-keyword">this</span>)));

  <span class="hljs-comment">// state &amp; model handlers.</span>

  $(<span class="hljs-keyword">this</span>).on(<span class="hljs-string">'state-change'</span>,  (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(controller)</span> {</span>

    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(event)</span> {</span>

      handleStateChange.call(<span class="hljs-literal">null</span>, controller, event);

    };

  }(<span class="hljs-keyword">this</span>)));

  $(<span class="hljs-keyword">this</span>.model).on(<span class="hljs-string">'property-change'</span>, (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(controller)</span> {</span>

    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(event)</span> {</span>

      handlePropertyChange.call(<span class="hljs-literal">null</span>, controller, event);

    };

  }(<span class="hljs-keyword">this</span>)));

  <span class="hljs-comment">// default to undeditable state.</span>

  <span class="hljs-keyword">this</span>.state = stateEnum.UNEDITABLE;

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;

}
</code></pre><p>The <em>handleStateChange</em> delegate is responsible for updating the view based on a change to state: either <em>EDITABLE</em> or <em>UNEDITABLE</em> from the <em>stateEnum</em> object:</p>
<pre><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleStateChange</span><span class="hljs-params">(controller, event)</span> {</span>

  <span class="hljs-comment">// remove state-based item.</span>

  <span class="hljs-keyword">if</span>( typeof event.oldState !== <span class="hljs-string">'undefined'</span>) {

    <span class="hljs-keyword">if</span>(event.oldState === stateEnum.UNEDITABLE) {

      controller.<span class="hljs-variable">$uneditableView</span>.detach();

    }

    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(event.oldState === stateEnum.EDITABLE) {

      controller.<span class="hljs-variable">$editableView</span>.detach();

    }

  }

  <span class="hljs-comment">// append state-based item.</span>

  <span class="hljs-keyword">if</span>(event.newState === stateEnum.UNEDITABLE) {

    controller.parentView.append(controller.<span class="hljs-variable">$uneditableView</span>);

  }

  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(event.newState === stateEnum.EDITABLE) {

    <span class="hljs-keyword">var</span> inputTimeout = setTimeout( <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>  {</span>

      clearTimeout(inputTimeout);

      $(<span class="hljs-string">'input'</span>, controller.<span class="hljs-variable">$editableView</span>).focus();

    }, <span class="hljs-number">100</span>);

    controller.parentView.append(controller.<span class="hljs-variable">$editableView</span>);

  }

}
</code></pre><p>The <em>handlePropertyChange</em> delegate is responsible for updating the views based on the <em>model</em> property values:</p>
<pre><code>function handlePropertyChange(controller, <span class="hljs-keyword">event</span>) {

  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">event</span>.property === <span class="hljs-string">"name"</span>) {

    <span class="hljs-comment">// update view based on model change.</span>

    <span class="hljs-variable">$(</span><span class="hljs-string">'input'</span>, controller.<span class="hljs-variable">$editableView</span>).val(controller.model.name);

    controller.<span class="hljs-variable">$uneditableView</span>.<span class="hljs-keyword">text</span>(<span class="hljs-keyword">event</span>.newValue);

  }

  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">event</span>.property === <span class="hljs-string">"marked"</span>) {

    <span class="hljs-comment">// update view based on model change.</span>

    controller.<span class="hljs-variable">$uneditableView</span>.css(<span class="hljs-string">'text-decoration'</span>, (<span class="hljs-keyword">event</span>.newValue) ? <span class="hljs-string">'line-through'</span> : <span class="hljs-string">'none'</span>);

  }

}
</code></pre><p>That pretty much shores up the implementation for the <em>list-item-controller</em> taking on the responsibilities of view creation and management based on state and model updates. But running the tests from this point will fail. The reason being a change to design on the model.</p>
<h2 id="grocery-ls-item-modification">grocery-ls-item Modification</h2>
<p>One particular change to design introduced in the implementation for <em>list-item-controller</em> is response to <em>‘property-change’</em> event from the model. In our work up to this point, the <em>grocery-ls-item</em> is a basic object; we’ll use the same paradigm that we implemented for notification of state for the <em>grocery-ls-item</em> in order to respond to changes on model properties. Although a simple change, we need to first test our design before modifying the code for the <em>grocery-ls-item</em>. Lets create a new spec file for our model:</p>
<p><em>/test/jasmine/spec/grocery-ls-item.spec.js</em></p>
<pre><code>define([<span class="hljs-string">'jquery'</span>, <span class="hljs-string">'script/model/grocery-ls-item'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">($, modelFactory)</span> {</span>



  describe(<span class="hljs-string">'Grocery grocery-ls-item model'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>



    <span class="hljs-keyword">var</span> model,

        name = <span class="hljs-string">'grapes'</span>,

        async = <span class="hljs-keyword">new</span> AsyncSpec(<span class="hljs-keyword">this</span>);



    beforeEach( <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

      model = modelFactory.create();

      model.name = name;

      model.marked = <span class="hljs-literal">false</span>;

    });



    describe(<span class="hljs-string">'grocery-ls-item factory model creation'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>



      it(<span class="hljs-string">'should generate unique instances of model'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

        <span class="hljs-keyword">var</span> newModel = modelFactory.create();

        expect(model).not.toBeUndefined();

        expect(newModel).not.toBeUndefined();

        expect(model).not.toBe(newModel);

      });



      async.it(<span class="hljs-string">'should auto generate unique ids on models'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(done)</span> {</span>

        <span class="hljs-keyword">var</span> newModel,

            creationTimeout;



        <span class="hljs-comment">// Offload creation because ids are generated based on time.</span>

        <span class="hljs-comment">// This allows for timestamp to progess.</span>

        creationTimeout = setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

          clearTimeout(creationTimeout);

          newModel = modelFactory.create();

          expect(model.id).not.toBeUndefined();

          expect(<span class="hljs-keyword">typeof</span> model.id).toBe(<span class="hljs-string">'number'</span>);

          expect(model.id).not.toEqual(newModel.id);

          done();

        }, <span class="hljs-number">100</span>);

      });



    });



    describe(<span class="hljs-string">'grocery-ls-item properties'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>



      it(<span class="hljs-string">'should contain an immutable id property, created at instantiation'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

        <span class="hljs-keyword">var</span> newID = <span class="hljs-number">1234567</span>;

        model.id = newID;



        expect(model.id).not.toEqual(newID);

      });



    });



    describe(<span class="hljs-string">'grocery-ls-item property change notification'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>



      async.it(<span class="hljs-string">'should notify with \'property-change\' upon change to name property'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(done)</span> {</span>

        <span class="hljs-keyword">var</span> oldName = model.name,

            newName = <span class="hljs-string">'apples'</span>;

        $(model).on(<span class="hljs-string">'property-change'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(event)</span> {</span>

          expect(event.property).toEqual(<span class="hljs-string">'name'</span>);

          expect(event.oldValue).toEqual(oldName);

          expect(event.newValue).toEqual(newName);

          $(model).off(<span class="hljs-string">'property-change'</span>);

          done();

        });

        model.name = newName;

      });



      async.it(<span class="hljs-string">'should notify with \'property-change\' upon change to marked property'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(done)</span> {</span>

        <span class="hljs-keyword">var</span> oldValue = model.marked,

            newValue = <span class="hljs-literal">true</span>;

        $(model).on(<span class="hljs-string">'property-change'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(event)</span> {</span>

          expect(event.property).toEqual(<span class="hljs-string">'marked'</span>);

          expect(event.oldValue).toEqual(oldValue);

          expect(event.newValue).toEqual(newValue);

          $(model).off(<span class="hljs-string">'property-change'</span>);

          done();

        });

        model.marked = newValue;

      });



    });



    afterEach( <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

      model = <span class="hljs-literal">undefined</span>;

    });



  });



});
</code></pre><p>We have a few suites there to verify:</p>
<ol>
<li>Model generation from factory produces unique items</li>
<li>Model property immutability for auto-assigned IDs</li>
<li>Event notification on property change</li>
</ol>
<p>We add that to our spec runner:</p>
<pre><code><span class="hljs-keyword">require</span>( [<span class="hljs-string">'spec/newitem.spec.js'</span>, <span class="hljs-string">'spec/markitem.spec.js'</span>,

          <span class="hljs-string">'spec/item-controller.spec.js'</span>, <span class="hljs-string">'spec/grocery-ls-item.spec.js'</span>], <span class="hljs-keyword">function</span>() {



  var jasmineEnv = jasmine.getEnv(),

     <span class="hljs-keyword">...</span>

  jasmineEnv.execute();



});
</code></pre><p>… and it fails. Whoopee! It’s supposed to. Now we just take the knowledge we know of wiring up event notification on state of the <em>list-item-controller</em>, and apply it to <em>property-change</em> on the model:</p>
<p><em>/script/model/grocery-ls-item.js</em></p>
<pre><code>define([<span class="hljs-string">'jquery'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">($)</span> {</span>



  <span class="hljs-keyword">var</span> propertyEvent = {

      create: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(property, oldValue, newValue)</span> {</span>

        <span class="hljs-keyword">var</span> event = $.Event(<span class="hljs-string">'property-change'</span>);

        event.property = property;

        event.oldValue = oldValue;

        event.newValue = newValue;

        <span class="hljs-keyword">return</span> event;

      }

    },

    properties = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(id)</span> {</span>

      <span class="hljs-keyword">return</span> {

        <span class="hljs-string">"id"</span>: {

          value: id,

          writable: <span class="hljs-literal">false</span>,

          enumerable: <span class="hljs-literal">true</span>

        },

        <span class="hljs-string">"name"</span>: {

          enumerable: <span class="hljs-literal">true</span>,

          set: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(value)</span> {</span>

            <span class="hljs-keyword">var</span> oldValue = <span class="hljs-keyword">this</span>._name;

            <span class="hljs-keyword">this</span>._name = value;

            $(<span class="hljs-keyword">this</span>).trigger(propertyEvent.create(<span class="hljs-string">'name'</span>, oldValue, value));

          },

          get: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._name;

          }

        },

        <span class="hljs-string">"marked"</span>: {

          enumerable: <span class="hljs-literal">true</span>,

          set: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(value)</span> {</span>

            <span class="hljs-keyword">var</span> oldValue = <span class="hljs-keyword">this</span>._marked;

            <span class="hljs-keyword">this</span>._marked = value;

            $(<span class="hljs-keyword">this</span>).trigger(propertyEvent.create(<span class="hljs-string">'marked'</span>, oldValue, value));

          },

          get: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._marked;

          }

        }

      };

    };



  <span class="hljs-keyword">return</span> {

    create: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.create(<span class="hljs-built_in">Object</span>.prototype, properties(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime()));

    }

  };



});
</code></pre><p>The modification to <em>grocery-ls-item</em> was perhaps our first introduction to writing failing tests due to a change in design prior to actually modifying the implementation. That feeling you’re feeling right now… that’s what makes this all worth it <img src="https://custardbelly.com/blog/wp-includes/images/smilies/icon_wink.gif" alt=";)"></p>
<p>Anyway… hold on to that feeling until the next post, because we are not done and it will go away quickly… just kidding <img src="https://custardbelly.com/blog/wp-includes/images/smilies/icon_smile.gif" alt=":)"></p>
<p><strong>Tagged</strong>: 0.1.5 <a href="https://github.com/bustardcelly/grocery-ls/tree/0.1.5">https://github.com/bustardcelly/grocery-ls/tree/0.1.5</a></p>
<h2 id="blinders">Blinders</h2>
<p>If you were to run the tests again… they still pass!<br><img src="https://custardbelly.com/blog/images/tdd_js/part_iv_2.png" alt="passing grocery-ls-item spec"></p>
<p>That is because we have not changed <em>list-controller</em> at all <img src="https://custardbelly.com/blog/wp-includes/images/smilies/icon_smile.gif" alt=":)"></p>
<p>Our <em>list-item-controller.spec.js</em> is happily oblivious to our recent additions and modifications, and the tests we wrote previously for the <em>Add Item</em> and <em>Mark Off Item</em> features still pass. </p>
<p>Before we just start chopping out and inserting code from <em>list-controller</em>, I want to go over the API and specs currently defined and see if they still hold water – meaning we might be able to cut some tests out. We might not. We might even add more… That’s what i plan to address in the next article of this series.</p>
<p>—</p>
<h1 id="link-dump">Link Dump</h1>
<h2 id="reference">Reference</h2>
<p><a href="http://tddjs.com/">Test-Driven JavaScript Development by Christian Johansen</a><br><a href="http://dannorth.net/introducing-bdd/">Introducing BDD by Dan North</a><br><a href="http://benalman.com/news/2010/11/immediately-invoked-function-expression/">Immediately-Invoked Function Expression (IIFE) by Ben Alman</a><br><a href="http://requirejs.org/">RequireJS</a><br><a href="https://github.com/amdjs/amdjs-api/wiki/AMD">AMD</a><br><a href="http://pivotal.github.com/jasmine/">Jasmine</a><br><a href="http://sinonjs.org/">Sinon</a><br><a href="https://github.com/derickbailey/jasmine.async">Jasmine.Async</a></p>
<h2 id="post-series">Post Series</h2>
<p><a href="https://github.com/bustardcelly/grocery-ls">grocery-ls github repo</a><br><a href="https://custardbelly.com/blog/2012/11/26/the-making-of-a-test-driven-grocery-list-application-in-javascript-part-i">Part I – Introduction</a><br><a href="https://custardbelly.com/blog/2012/11/26/the-making-of-a-test-driven-grocery-list-application-in-js-part-ii">Part II – Feature: Add Item</a><br><a href="https://custardbelly.com/blog/2012/12/06/the-making-of-a-test-driven-grocery-list-application-in-js-part-iii">Part III – Feature: Mark-Off Item</a><br><a href="https://custardbelly.com/blog/2012/12/17/the-making-of-a-test-driven-grocery-list-application-in-js-part-iv">Part IV – Feature: List-Item-Controller</a><br><a href="https://custardbelly.com/blog/2012/12/31/the-making-of-a-test-driven-grocery-list-application-in-js-part-v/">Part V – Feature: List-Controller Refactoring</a><br><a href="https://custardbelly.com/blog/2013/01/08/the-making-of-a-test-driven-grocery-list-application-in-js-part-vi/">Part VI – Back to Passing</a><br><a href="https://custardbelly.com/blog/2013/01/17/the-making-of-a-test-driven-grocery-list-application-in-js-part-vii/">Part VII – Remove Item</a><br><a href="https://custardbelly.com/blog/2013/01/22/the-making-of-a-test-driven-grocery-list-application-part-viii/">Part VIII – Bug Fixing</a><br><a href="https://custardbelly.com/blog/2013/02/15/the-making-of-a-test-driven-grocery-list-application-in-js-part-ix/">Part IX – Persistence</a><br><a href="https://custardbelly.com/blog/2013/03/06/the-making-of-a-test-driven-grocery-list-application-in-js-part-x/">Part X – It Lives!</a></p>
<p>Posted in <a href="https://custardbelly.com/blog/category/amd/">AMD</a>, <a href="https://custardbelly.com/blog/category/javascript/">JavaScript</a>, <a href="https://custardbelly.com/blog/category/requirejs/">RequireJS</a>, <a href="https://custardbelly.com/blog/category/grocery-ls/">grocery-ls</a>, <a href="https://custardbelly.com/blog/category/jasmine/">jasmine</a>, <a href="https://custardbelly.com/blog/category/unit-testing/">unit-testing</a>.</p>

  </section>
  <section class="navigation">
      
        <span class="newer"><a href="/blog-posts/2012/12/31/the-making-of-a-test-driven-grocery-list-application-in-js-part-v/index.html"><i class="fa fa-arrow-left"></i>&nbsp;newer posts</a></span>
      
      
        <span class="older"><a href="/blog-posts/2012/12/06/the-making-of-a-test-driven-grocery-list-application-in-js-part-iii/index.html">older posts&nbsp;<i class="fa fa-arrow-right"></i></a></span>
      
  </section>
  <section class="comments">
    
      <div id="disqus_thread"></div>
      <script type="text/javascript">
        window.disqus_identifier="";
        window.disqus_url="https://www.custardbelly.com/blog/blog-posts/2012/12/17/the-making-of-a-test-driven-grocery-list-application-in-js-part-iv/index.html";
        window.disqus_title="The Making of a Test-Driven Grocery List Application in JS: Part IV";
      </script>
        <script type="text/javascript" src="https://disqus.com/forums/custardbelly/embed.js"></script>
        <noscript><a href="http://custardbelly.disqus.com/?url=ref">View the discussion thread.</a></noscript>
    
  </section>
</article>
                </div>
              </section>
          </div>
      </div>
        <!-- Footer -->
          <section id="footer">
            <div class="container">
              <ul class="copyright">
                <li>&copy; Todd Anderson 2002-2017. All rights reserved.</li><li>Design: <a href="http://html5up.net">HTML5 UP</a></li>
              </ul>
            </div>
          </section>
      </div>

    <!-- Scripts -->
      <script src="/assets/js/jquery.min.js"></script>
      <script src="/assets/js/jquery.scrollzer.min.js"></script>
      <script src="/assets/js/jquery.scrolly.min.js"></script>
      <script src="/assets/js/skel.min.js"></script>
      <script src="/assets/js/util.js"></script>
      <!--[if lte IE 8]><script src="assets/js/ie/respond.min.js"></script><![endif]-->
      <script src="/assets/js/main.js"></script>
      <script src="/lib/highlight/highlight.pack.js"></script>
    <script>
        // custardbelly.com
        var _gaq=[["_setAccount","UA-29061897-1"],["_trackPageview"]];
        (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];g.async=1;
        g.src=("https:"==location.protocol?"//ssl":"//www")+".google-analytics.com/ga.js";
        s.parentNode.insertBefore(g,s)}(document,"script"));
   </script>

  </body>
</html>
